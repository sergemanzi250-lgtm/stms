
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model TeacherSubject
 * 
 */
export type TeacherSubject = $Result.DefaultSelection<Prisma.$TeacherSubjectPayload>
/**
 * Model TrainerModule
 * 
 */
export type TrainerModule = $Result.DefaultSelection<Prisma.$TrainerModulePayload>
/**
 * Model ClassSubject
 * 
 */
export type ClassSubject = $Result.DefaultSelection<Prisma.$ClassSubjectPayload>
/**
 * Model TimeSlot
 * 
 */
export type TimeSlot = $Result.DefaultSelection<Prisma.$TimeSlotPayload>
/**
 * Model Timetable
 * 
 */
export type Timetable = $Result.DefaultSelection<Prisma.$TimetablePayload>
/**
 * Model TeacherClassSubject
 * 
 */
export type TeacherClassSubject = $Result.DefaultSelection<Prisma.$TeacherClassSubjectPayload>
/**
 * Model TrainerClassModule
 * 
 */
export type TrainerClassModule = $Result.DefaultSelection<Prisma.$TrainerClassModulePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs>;

  /**
   * `prisma.teacherSubject`: Exposes CRUD operations for the **TeacherSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherSubjects
    * const teacherSubjects = await prisma.teacherSubject.findMany()
    * ```
    */
  get teacherSubject(): Prisma.TeacherSubjectDelegate<ExtArgs>;

  /**
   * `prisma.trainerModule`: Exposes CRUD operations for the **TrainerModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainerModules
    * const trainerModules = await prisma.trainerModule.findMany()
    * ```
    */
  get trainerModule(): Prisma.TrainerModuleDelegate<ExtArgs>;

  /**
   * `prisma.classSubject`: Exposes CRUD operations for the **ClassSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSubjects
    * const classSubjects = await prisma.classSubject.findMany()
    * ```
    */
  get classSubject(): Prisma.ClassSubjectDelegate<ExtArgs>;

  /**
   * `prisma.timeSlot`: Exposes CRUD operations for the **TimeSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSlots
    * const timeSlots = await prisma.timeSlot.findMany()
    * ```
    */
  get timeSlot(): Prisma.TimeSlotDelegate<ExtArgs>;

  /**
   * `prisma.timetable`: Exposes CRUD operations for the **Timetable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Timetables
    * const timetables = await prisma.timetable.findMany()
    * ```
    */
  get timetable(): Prisma.TimetableDelegate<ExtArgs>;

  /**
   * `prisma.teacherClassSubject`: Exposes CRUD operations for the **TeacherClassSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherClassSubjects
    * const teacherClassSubjects = await prisma.teacherClassSubject.findMany()
    * ```
    */
  get teacherClassSubject(): Prisma.TeacherClassSubjectDelegate<ExtArgs>;

  /**
   * `prisma.trainerClassModule`: Exposes CRUD operations for the **TrainerClassModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainerClassModules
    * const trainerClassModules = await prisma.trainerClassModule.findMany()
    * ```
    */
  get trainerClassModule(): Prisma.TrainerClassModuleDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    School: 'School',
    Class: 'Class',
    Subject: 'Subject',
    Module: 'Module',
    TeacherSubject: 'TeacherSubject',
    TrainerModule: 'TrainerModule',
    ClassSubject: 'ClassSubject',
    TimeSlot: 'TimeSlot',
    Timetable: 'Timetable',
    TeacherClassSubject: 'TeacherClassSubject',
    TrainerClassModule: 'TrainerClassModule'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "school" | "class" | "subject" | "module" | "teacherSubject" | "trainerModule" | "classSubject" | "timeSlot" | "timetable" | "teacherClassSubject" | "trainerClassModule"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      TeacherSubject: {
        payload: Prisma.$TeacherSubjectPayload<ExtArgs>
        fields: Prisma.TeacherSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          findFirst: {
            args: Prisma.TeacherSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          findMany: {
            args: Prisma.TeacherSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>[]
          }
          create: {
            args: Prisma.TeacherSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          createMany: {
            args: Prisma.TeacherSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>[]
          }
          delete: {
            args: Prisma.TeacherSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          update: {
            args: Prisma.TeacherSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          deleteMany: {
            args: Prisma.TeacherSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          aggregate: {
            args: Prisma.TeacherSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherSubject>
          }
          groupBy: {
            args: Prisma.TeacherSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherSubjectCountAggregateOutputType> | number
          }
        }
      }
      TrainerModule: {
        payload: Prisma.$TrainerModulePayload<ExtArgs>
        fields: Prisma.TrainerModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainerModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainerModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerModulePayload>
          }
          findFirst: {
            args: Prisma.TrainerModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainerModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerModulePayload>
          }
          findMany: {
            args: Prisma.TrainerModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerModulePayload>[]
          }
          create: {
            args: Prisma.TrainerModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerModulePayload>
          }
          createMany: {
            args: Prisma.TrainerModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainerModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerModulePayload>[]
          }
          delete: {
            args: Prisma.TrainerModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerModulePayload>
          }
          update: {
            args: Prisma.TrainerModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerModulePayload>
          }
          deleteMany: {
            args: Prisma.TrainerModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainerModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainerModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerModulePayload>
          }
          aggregate: {
            args: Prisma.TrainerModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainerModule>
          }
          groupBy: {
            args: Prisma.TrainerModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainerModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainerModuleCountArgs<ExtArgs>
            result: $Utils.Optional<TrainerModuleCountAggregateOutputType> | number
          }
        }
      }
      ClassSubject: {
        payload: Prisma.$ClassSubjectPayload<ExtArgs>
        fields: Prisma.ClassSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          findFirst: {
            args: Prisma.ClassSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          findMany: {
            args: Prisma.ClassSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>[]
          }
          create: {
            args: Prisma.ClassSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          createMany: {
            args: Prisma.ClassSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>[]
          }
          delete: {
            args: Prisma.ClassSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          update: {
            args: Prisma.ClassSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          deleteMany: {
            args: Prisma.ClassSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          aggregate: {
            args: Prisma.ClassSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSubject>
          }
          groupBy: {
            args: Prisma.ClassSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<ClassSubjectCountAggregateOutputType> | number
          }
        }
      }
      TimeSlot: {
        payload: Prisma.$TimeSlotPayload<ExtArgs>
        fields: Prisma.TimeSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          findFirst: {
            args: Prisma.TimeSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          findMany: {
            args: Prisma.TimeSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          create: {
            args: Prisma.TimeSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          createMany: {
            args: Prisma.TimeSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          delete: {
            args: Prisma.TimeSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          update: {
            args: Prisma.TimeSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          deleteMany: {
            args: Prisma.TimeSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimeSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          aggregate: {
            args: Prisma.TimeSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeSlot>
          }
          groupBy: {
            args: Prisma.TimeSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeSlotCountArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotCountAggregateOutputType> | number
          }
        }
      }
      Timetable: {
        payload: Prisma.$TimetablePayload<ExtArgs>
        fields: Prisma.TimetableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimetableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimetableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          findFirst: {
            args: Prisma.TimetableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimetableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          findMany: {
            args: Prisma.TimetableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>[]
          }
          create: {
            args: Prisma.TimetableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          createMany: {
            args: Prisma.TimetableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimetableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>[]
          }
          delete: {
            args: Prisma.TimetableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          update: {
            args: Prisma.TimetableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          deleteMany: {
            args: Prisma.TimetableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimetableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimetableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          aggregate: {
            args: Prisma.TimetableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimetable>
          }
          groupBy: {
            args: Prisma.TimetableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimetableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimetableCountArgs<ExtArgs>
            result: $Utils.Optional<TimetableCountAggregateOutputType> | number
          }
        }
      }
      TeacherClassSubject: {
        payload: Prisma.$TeacherClassSubjectPayload<ExtArgs>
        fields: Prisma.TeacherClassSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherClassSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherClassSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassSubjectPayload>
          }
          findFirst: {
            args: Prisma.TeacherClassSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherClassSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassSubjectPayload>
          }
          findMany: {
            args: Prisma.TeacherClassSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassSubjectPayload>[]
          }
          create: {
            args: Prisma.TeacherClassSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassSubjectPayload>
          }
          createMany: {
            args: Prisma.TeacherClassSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherClassSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassSubjectPayload>[]
          }
          delete: {
            args: Prisma.TeacherClassSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassSubjectPayload>
          }
          update: {
            args: Prisma.TeacherClassSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassSubjectPayload>
          }
          deleteMany: {
            args: Prisma.TeacherClassSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherClassSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherClassSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassSubjectPayload>
          }
          aggregate: {
            args: Prisma.TeacherClassSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherClassSubject>
          }
          groupBy: {
            args: Prisma.TeacherClassSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherClassSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherClassSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherClassSubjectCountAggregateOutputType> | number
          }
        }
      }
      TrainerClassModule: {
        payload: Prisma.$TrainerClassModulePayload<ExtArgs>
        fields: Prisma.TrainerClassModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainerClassModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerClassModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainerClassModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerClassModulePayload>
          }
          findFirst: {
            args: Prisma.TrainerClassModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerClassModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainerClassModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerClassModulePayload>
          }
          findMany: {
            args: Prisma.TrainerClassModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerClassModulePayload>[]
          }
          create: {
            args: Prisma.TrainerClassModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerClassModulePayload>
          }
          createMany: {
            args: Prisma.TrainerClassModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainerClassModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerClassModulePayload>[]
          }
          delete: {
            args: Prisma.TrainerClassModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerClassModulePayload>
          }
          update: {
            args: Prisma.TrainerClassModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerClassModulePayload>
          }
          deleteMany: {
            args: Prisma.TrainerClassModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainerClassModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainerClassModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainerClassModulePayload>
          }
          aggregate: {
            args: Prisma.TrainerClassModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainerClassModule>
          }
          groupBy: {
            args: Prisma.TrainerClassModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainerClassModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainerClassModuleCountArgs<ExtArgs>
            result: $Utils.Optional<TrainerClassModuleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    teacherSubjects: number
    trainerModules: number
    teacherClassSubjects: number
    trainerClassModules: number
    timetablesAsTeacher: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacherSubjects?: boolean | UserCountOutputTypeCountTeacherSubjectsArgs
    trainerModules?: boolean | UserCountOutputTypeCountTrainerModulesArgs
    teacherClassSubjects?: boolean | UserCountOutputTypeCountTeacherClassSubjectsArgs
    trainerClassModules?: boolean | UserCountOutputTypeCountTrainerClassModulesArgs
    timetablesAsTeacher?: boolean | UserCountOutputTypeCountTimetablesAsTeacherArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeacherSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainerModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainerModuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeacherClassSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherClassSubjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainerClassModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainerClassModuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimetablesAsTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
  }


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    users: number
    classes: number
    subjects: number
    modules: number
    timeSlots: number
    timetables: number
    teacherClassSubjects: number
    trainerClassModules: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SchoolCountOutputTypeCountUsersArgs
    classes?: boolean | SchoolCountOutputTypeCountClassesArgs
    subjects?: boolean | SchoolCountOutputTypeCountSubjectsArgs
    modules?: boolean | SchoolCountOutputTypeCountModulesArgs
    timeSlots?: boolean | SchoolCountOutputTypeCountTimeSlotsArgs
    timetables?: boolean | SchoolCountOutputTypeCountTimetablesArgs
    teacherClassSubjects?: boolean | SchoolCountOutputTypeCountTeacherClassSubjectsArgs
    trainerClassModules?: boolean | SchoolCountOutputTypeCountTrainerClassModulesArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTimetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTeacherClassSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherClassSubjectWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTrainerClassModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainerClassModuleWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    subjects: number
    timetables: number
    teacherClassSubjects: number
    trainerClassModules: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | ClassCountOutputTypeCountSubjectsArgs
    timetables?: boolean | ClassCountOutputTypeCountTimetablesArgs
    teacherClassSubjects?: boolean | ClassCountOutputTypeCountTeacherClassSubjectsArgs
    trainerClassModules?: boolean | ClassCountOutputTypeCountTrainerClassModulesArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSubjectWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountTimetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountTeacherClassSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherClassSubjectWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountTrainerClassModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainerClassModuleWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    teachers: number
    classSubjects: number
    timetables: number
    teacherClassSubjects: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | SubjectCountOutputTypeCountTeachersArgs
    classSubjects?: boolean | SubjectCountOutputTypeCountClassSubjectsArgs
    timetables?: boolean | SubjectCountOutputTypeCountTimetablesArgs
    teacherClassSubjects?: boolean | SubjectCountOutputTypeCountTeacherClassSubjectsArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountClassSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSubjectWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountTimetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountTeacherClassSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherClassSubjectWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    trainers: number
    timetables: number
    trainerClassModules: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainers?: boolean | ModuleCountOutputTypeCountTrainersArgs
    timetables?: boolean | ModuleCountOutputTypeCountTimetablesArgs
    trainerClassModules?: boolean | ModuleCountOutputTypeCountTrainerClassModulesArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountTrainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainerModuleWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountTimetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountTrainerClassModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainerClassModuleWhereInput
  }


  /**
   * Count Type TimeSlotCountOutputType
   */

  export type TimeSlotCountOutputType = {
    timetables: number
  }

  export type TimeSlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timetables?: boolean | TimeSlotCountOutputTypeCountTimetablesArgs
  }

  // Custom InputTypes
  /**
   * TimeSlotCountOutputType without action
   */
  export type TimeSlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlotCountOutputType
     */
    select?: TimeSlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TimeSlotCountOutputType without action
   */
  export type TimeSlotCountOutputTypeCountTimetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    maxWeeklyHours: number | null
  }

  export type UserSumAggregateOutputType = {
    maxWeeklyHours: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    schoolId: string | null
    isActive: boolean | null
    maxWeeklyHours: number | null
    teachingStreams: string | null
    unavailableDays: string | null
    unavailablePeriods: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    schoolId: string | null
    isActive: boolean | null
    maxWeeklyHours: number | null
    teachingStreams: string | null
    unavailableDays: string | null
    unavailablePeriods: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    schoolId: number
    isActive: number
    maxWeeklyHours: number
    teachingStreams: number
    unavailableDays: number
    unavailablePeriods: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    maxWeeklyHours?: true
  }

  export type UserSumAggregateInputType = {
    maxWeeklyHours?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    schoolId?: true
    isActive?: true
    maxWeeklyHours?: true
    teachingStreams?: true
    unavailableDays?: true
    unavailablePeriods?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    schoolId?: true
    isActive?: true
    maxWeeklyHours?: true
    teachingStreams?: true
    unavailableDays?: true
    unavailablePeriods?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    schoolId?: true
    isActive?: true
    maxWeeklyHours?: true
    teachingStreams?: true
    unavailableDays?: true
    unavailablePeriods?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    role: string
    schoolId: string | null
    isActive: boolean
    maxWeeklyHours: number | null
    teachingStreams: string | null
    unavailableDays: string | null
    unavailablePeriods: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    schoolId?: boolean
    isActive?: boolean
    maxWeeklyHours?: boolean
    teachingStreams?: boolean
    unavailableDays?: boolean
    unavailablePeriods?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | User$schoolArgs<ExtArgs>
    teacherSubjects?: boolean | User$teacherSubjectsArgs<ExtArgs>
    trainerModules?: boolean | User$trainerModulesArgs<ExtArgs>
    teacherClassSubjects?: boolean | User$teacherClassSubjectsArgs<ExtArgs>
    trainerClassModules?: boolean | User$trainerClassModulesArgs<ExtArgs>
    timetablesAsTeacher?: boolean | User$timetablesAsTeacherArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    schoolId?: boolean
    isActive?: boolean
    maxWeeklyHours?: boolean
    teachingStreams?: boolean
    unavailableDays?: boolean
    unavailablePeriods?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | User$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    schoolId?: boolean
    isActive?: boolean
    maxWeeklyHours?: boolean
    teachingStreams?: boolean
    unavailableDays?: boolean
    unavailablePeriods?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | User$schoolArgs<ExtArgs>
    teacherSubjects?: boolean | User$teacherSubjectsArgs<ExtArgs>
    trainerModules?: boolean | User$trainerModulesArgs<ExtArgs>
    teacherClassSubjects?: boolean | User$teacherClassSubjectsArgs<ExtArgs>
    trainerClassModules?: boolean | User$trainerClassModulesArgs<ExtArgs>
    timetablesAsTeacher?: boolean | User$timetablesAsTeacherArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | User$schoolArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs> | null
      teacherSubjects: Prisma.$TeacherSubjectPayload<ExtArgs>[]
      trainerModules: Prisma.$TrainerModulePayload<ExtArgs>[]
      teacherClassSubjects: Prisma.$TeacherClassSubjectPayload<ExtArgs>[]
      trainerClassModules: Prisma.$TrainerClassModulePayload<ExtArgs>[]
      timetablesAsTeacher: Prisma.$TimetablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      role: string
      schoolId: string | null
      isActive: boolean
      maxWeeklyHours: number | null
      teachingStreams: string | null
      unavailableDays: string | null
      unavailablePeriods: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends User$schoolArgs<ExtArgs> = {}>(args?: Subset<T, User$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    teacherSubjects<T extends User$teacherSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    trainerModules<T extends User$trainerModulesArgs<ExtArgs> = {}>(args?: Subset<T, User$trainerModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "findMany"> | Null>
    teacherClassSubjects<T extends User$teacherClassSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherClassSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    trainerClassModules<T extends User$trainerClassModulesArgs<ExtArgs> = {}>(args?: Subset<T, User$trainerClassModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "findMany"> | Null>
    timetablesAsTeacher<T extends User$timetablesAsTeacherArgs<ExtArgs> = {}>(args?: Subset<T, User$timetablesAsTeacherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly schoolId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly maxWeeklyHours: FieldRef<"User", 'Int'>
    readonly teachingStreams: FieldRef<"User", 'String'>
    readonly unavailableDays: FieldRef<"User", 'String'>
    readonly unavailablePeriods: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.school
   */
  export type User$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * User.teacherSubjects
   */
  export type User$teacherSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    cursor?: TeacherSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * User.trainerModules
   */
  export type User$trainerModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    where?: TrainerModuleWhereInput
    orderBy?: TrainerModuleOrderByWithRelationInput | TrainerModuleOrderByWithRelationInput[]
    cursor?: TrainerModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainerModuleScalarFieldEnum | TrainerModuleScalarFieldEnum[]
  }

  /**
   * User.teacherClassSubjects
   */
  export type User$teacherClassSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    where?: TeacherClassSubjectWhereInput
    orderBy?: TeacherClassSubjectOrderByWithRelationInput | TeacherClassSubjectOrderByWithRelationInput[]
    cursor?: TeacherClassSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherClassSubjectScalarFieldEnum | TeacherClassSubjectScalarFieldEnum[]
  }

  /**
   * User.trainerClassModules
   */
  export type User$trainerClassModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    where?: TrainerClassModuleWhereInput
    orderBy?: TrainerClassModuleOrderByWithRelationInput | TrainerClassModuleOrderByWithRelationInput[]
    cursor?: TrainerClassModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainerClassModuleScalarFieldEnum | TrainerClassModuleScalarFieldEnum[]
  }

  /**
   * User.timetablesAsTeacher
   */
  export type User$timetablesAsTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    cursor?: TimetableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    address: string | null
    province: string | null
    district: string | null
    sector: string | null
    email: string | null
    phone: string | null
    status: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    address: string | null
    province: string | null
    district: string | null
    sector: string | null
    email: string | null
    phone: string | null
    status: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    type: number
    address: number
    province: number
    district: number
    sector: number
    email: number
    phone: number
    status: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    province?: true
    district?: true
    sector?: true
    email?: true
    phone?: true
    status?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    province?: true
    district?: true
    sector?: true
    email?: true
    phone?: true
    status?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    province?: true
    district?: true
    sector?: true
    email?: true
    phone?: true
    status?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    name: string
    type: string
    address: string | null
    province: string | null
    district: string | null
    sector: string | null
    email: string
    phone: string | null
    status: string
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    province?: boolean
    district?: boolean
    sector?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | School$usersArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    subjects?: boolean | School$subjectsArgs<ExtArgs>
    modules?: boolean | School$modulesArgs<ExtArgs>
    timeSlots?: boolean | School$timeSlotsArgs<ExtArgs>
    timetables?: boolean | School$timetablesArgs<ExtArgs>
    teacherClassSubjects?: boolean | School$teacherClassSubjectsArgs<ExtArgs>
    trainerClassModules?: boolean | School$trainerClassModulesArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    province?: boolean
    district?: boolean
    sector?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    province?: boolean
    district?: boolean
    sector?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | School$usersArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    subjects?: boolean | School$subjectsArgs<ExtArgs>
    modules?: boolean | School$modulesArgs<ExtArgs>
    timeSlots?: boolean | School$timeSlotsArgs<ExtArgs>
    timetables?: boolean | School$timetablesArgs<ExtArgs>
    teacherClassSubjects?: boolean | School$teacherClassSubjectsArgs<ExtArgs>
    trainerClassModules?: boolean | School$trainerClassModulesArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      modules: Prisma.$ModulePayload<ExtArgs>[]
      timeSlots: Prisma.$TimeSlotPayload<ExtArgs>[]
      timetables: Prisma.$TimetablePayload<ExtArgs>[]
      teacherClassSubjects: Prisma.$TeacherClassSubjectPayload<ExtArgs>[]
      trainerClassModules: Prisma.$TrainerClassModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      address: string | null
      province: string | null
      district: string | null
      sector: string | null
      email: string
      phone: string | null
      status: string
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends School$usersArgs<ExtArgs> = {}>(args?: Subset<T, School$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    classes<T extends School$classesArgs<ExtArgs> = {}>(args?: Subset<T, School$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends School$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, School$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany"> | Null>
    modules<T extends School$modulesArgs<ExtArgs> = {}>(args?: Subset<T, School$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany"> | Null>
    timeSlots<T extends School$timeSlotsArgs<ExtArgs> = {}>(args?: Subset<T, School$timeSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findMany"> | Null>
    timetables<T extends School$timetablesArgs<ExtArgs> = {}>(args?: Subset<T, School$timetablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany"> | Null>
    teacherClassSubjects<T extends School$teacherClassSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, School$teacherClassSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    trainerClassModules<T extends School$trainerClassModulesArgs<ExtArgs> = {}>(args?: Subset<T, School$trainerClassModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */ 
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly type: FieldRef<"School", 'String'>
    readonly address: FieldRef<"School", 'String'>
    readonly province: FieldRef<"School", 'String'>
    readonly district: FieldRef<"School", 'String'>
    readonly sector: FieldRef<"School", 'String'>
    readonly email: FieldRef<"School", 'String'>
    readonly phone: FieldRef<"School", 'String'>
    readonly status: FieldRef<"School", 'String'>
    readonly approvedAt: FieldRef<"School", 'DateTime'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
  }

  /**
   * School.users
   */
  export type School$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * School.classes
   */
  export type School$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * School.subjects
   */
  export type School$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * School.modules
   */
  export type School$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * School.timeSlots
   */
  export type School$timeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    where?: TimeSlotWhereInput
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    cursor?: TimeSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * School.timetables
   */
  export type School$timetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    cursor?: TimetableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * School.teacherClassSubjects
   */
  export type School$teacherClassSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    where?: TeacherClassSubjectWhereInput
    orderBy?: TeacherClassSubjectOrderByWithRelationInput | TeacherClassSubjectOrderByWithRelationInput[]
    cursor?: TeacherClassSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherClassSubjectScalarFieldEnum | TeacherClassSubjectScalarFieldEnum[]
  }

  /**
   * School.trainerClassModules
   */
  export type School$trainerClassModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    where?: TrainerClassModuleWhereInput
    orderBy?: TrainerClassModuleOrderByWithRelationInput | TrainerClassModuleOrderByWithRelationInput[]
    cursor?: TrainerClassModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainerClassModuleScalarFieldEnum | TrainerClassModuleScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    name: string | null
    level: string | null
    stream: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    name: string | null
    level: string | null
    stream: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    level: number
    stream: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    stream?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    stream?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    stream?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    name: string
    level: string | null
    stream: string | null
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    stream?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    subjects?: boolean | Class$subjectsArgs<ExtArgs>
    timetables?: boolean | Class$timetablesArgs<ExtArgs>
    teacherClassSubjects?: boolean | Class$teacherClassSubjectsArgs<ExtArgs>
    trainerClassModules?: boolean | Class$trainerClassModulesArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    stream?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    stream?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    subjects?: boolean | Class$subjectsArgs<ExtArgs>
    timetables?: boolean | Class$timetablesArgs<ExtArgs>
    teacherClassSubjects?: boolean | Class$teacherClassSubjectsArgs<ExtArgs>
    trainerClassModules?: boolean | Class$trainerClassModulesArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      subjects: Prisma.$ClassSubjectPayload<ExtArgs>[]
      timetables: Prisma.$TimetablePayload<ExtArgs>[]
      teacherClassSubjects: Prisma.$TeacherClassSubjectPayload<ExtArgs>[]
      trainerClassModules: Prisma.$TrainerClassModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      level: string | null
      stream: string | null
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subjects<T extends Class$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Class$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    timetables<T extends Class$timetablesArgs<ExtArgs> = {}>(args?: Subset<T, Class$timetablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany"> | Null>
    teacherClassSubjects<T extends Class$teacherClassSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, Class$teacherClassSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    trainerClassModules<T extends Class$trainerClassModulesArgs<ExtArgs> = {}>(args?: Subset<T, Class$trainerClassModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */ 
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly level: FieldRef<"Class", 'String'>
    readonly stream: FieldRef<"Class", 'String'>
    readonly schoolId: FieldRef<"Class", 'String'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
  }

  /**
   * Class.subjects
   */
  export type Class$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    where?: ClassSubjectWhereInput
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    cursor?: ClassSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * Class.timetables
   */
  export type Class$timetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    cursor?: TimetableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Class.teacherClassSubjects
   */
  export type Class$teacherClassSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    where?: TeacherClassSubjectWhereInput
    orderBy?: TeacherClassSubjectOrderByWithRelationInput | TeacherClassSubjectOrderByWithRelationInput[]
    cursor?: TeacherClassSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherClassSubjectScalarFieldEnum | TeacherClassSubjectScalarFieldEnum[]
  }

  /**
   * Class.trainerClassModules
   */
  export type Class$trainerClassModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    where?: TrainerClassModuleWhereInput
    orderBy?: TrainerClassModuleOrderByWithRelationInput | TrainerClassModuleOrderByWithRelationInput[]
    cursor?: TrainerClassModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainerClassModuleScalarFieldEnum | TrainerClassModuleScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    periodsPerWeek: number | null
  }

  export type SubjectSumAggregateOutputType = {
    periodsPerWeek: number | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    level: string | null
    periodsPerWeek: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    level: string | null
    periodsPerWeek: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    code: number
    level: number
    periodsPerWeek: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    periodsPerWeek?: true
  }

  export type SubjectSumAggregateInputType = {
    periodsPerWeek?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    level?: true
    periodsPerWeek?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    level?: true
    periodsPerWeek?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    level?: true
    periodsPerWeek?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    name: string
    code: string | null
    level: string | null
    periodsPerWeek: number
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    periodsPerWeek?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teachers?: boolean | Subject$teachersArgs<ExtArgs>
    classSubjects?: boolean | Subject$classSubjectsArgs<ExtArgs>
    timetables?: boolean | Subject$timetablesArgs<ExtArgs>
    teacherClassSubjects?: boolean | Subject$teacherClassSubjectsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    periodsPerWeek?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    periodsPerWeek?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    teachers?: boolean | Subject$teachersArgs<ExtArgs>
    classSubjects?: boolean | Subject$classSubjectsArgs<ExtArgs>
    timetables?: boolean | Subject$timetablesArgs<ExtArgs>
    teacherClassSubjects?: boolean | Subject$teacherClassSubjectsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      teachers: Prisma.$TeacherSubjectPayload<ExtArgs>[]
      classSubjects: Prisma.$ClassSubjectPayload<ExtArgs>[]
      timetables: Prisma.$TimetablePayload<ExtArgs>[]
      teacherClassSubjects: Prisma.$TeacherClassSubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      level: string | null
      periodsPerWeek: number
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teachers<T extends Subject$teachersArgs<ExtArgs> = {}>(args?: Subset<T, Subject$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    classSubjects<T extends Subject$classSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$classSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    timetables<T extends Subject$timetablesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$timetablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany"> | Null>
    teacherClassSubjects<T extends Subject$teacherClassSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$teacherClassSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */ 
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly level: FieldRef<"Subject", 'String'>
    readonly periodsPerWeek: FieldRef<"Subject", 'Int'>
    readonly schoolId: FieldRef<"Subject", 'String'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
  }

  /**
   * Subject.teachers
   */
  export type Subject$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    cursor?: TeacherSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * Subject.classSubjects
   */
  export type Subject$classSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    where?: ClassSubjectWhereInput
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    cursor?: ClassSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * Subject.timetables
   */
  export type Subject$timetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    cursor?: TimetableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Subject.teacherClassSubjects
   */
  export type Subject$teacherClassSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    where?: TeacherClassSubjectWhereInput
    orderBy?: TeacherClassSubjectOrderByWithRelationInput | TeacherClassSubjectOrderByWithRelationInput[]
    cursor?: TeacherClassSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherClassSubjectScalarFieldEnum | TeacherClassSubjectScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    totalHours: number | null
    blockSize: number | null
  }

  export type ModuleSumAggregateOutputType = {
    totalHours: number | null
    blockSize: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    level: string | null
    trade: string | null
    totalHours: number | null
    category: string | null
    blockSize: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    level: string | null
    trade: string | null
    totalHours: number | null
    category: string | null
    blockSize: number | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    name: number
    code: number
    level: number
    trade: number
    totalHours: number
    category: number
    blockSize: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    totalHours?: true
    blockSize?: true
  }

  export type ModuleSumAggregateInputType = {
    totalHours?: true
    blockSize?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    level?: true
    trade?: true
    totalHours?: true
    category?: true
    blockSize?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    level?: true
    trade?: true
    totalHours?: true
    category?: true
    blockSize?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    level?: true
    trade?: true
    totalHours?: true
    category?: true
    blockSize?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: string
    name: string
    code: string | null
    level: string | null
    trade: string | null
    totalHours: number
    category: string
    blockSize: number
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    trade?: boolean
    totalHours?: boolean
    category?: boolean
    blockSize?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    trainers?: boolean | Module$trainersArgs<ExtArgs>
    timetables?: boolean | Module$timetablesArgs<ExtArgs>
    trainerClassModules?: boolean | Module$trainerClassModulesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    trade?: boolean
    totalHours?: boolean
    category?: boolean
    blockSize?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    level?: boolean
    trade?: boolean
    totalHours?: boolean
    category?: boolean
    blockSize?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    trainers?: boolean | Module$trainersArgs<ExtArgs>
    timetables?: boolean | Module$timetablesArgs<ExtArgs>
    trainerClassModules?: boolean | Module$trainerClassModulesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      trainers: Prisma.$TrainerModulePayload<ExtArgs>[]
      timetables: Prisma.$TimetablePayload<ExtArgs>[]
      trainerClassModules: Prisma.$TrainerClassModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      level: string | null
      trade: string | null
      totalHours: number
      category: string
      blockSize: number
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trainers<T extends Module$trainersArgs<ExtArgs> = {}>(args?: Subset<T, Module$trainersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "findMany"> | Null>
    timetables<T extends Module$timetablesArgs<ExtArgs> = {}>(args?: Subset<T, Module$timetablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany"> | Null>
    trainerClassModules<T extends Module$trainerClassModulesArgs<ExtArgs> = {}>(args?: Subset<T, Module$trainerClassModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */ 
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly name: FieldRef<"Module", 'String'>
    readonly code: FieldRef<"Module", 'String'>
    readonly level: FieldRef<"Module", 'String'>
    readonly trade: FieldRef<"Module", 'String'>
    readonly totalHours: FieldRef<"Module", 'Int'>
    readonly category: FieldRef<"Module", 'String'>
    readonly blockSize: FieldRef<"Module", 'Int'>
    readonly schoolId: FieldRef<"Module", 'String'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
  }

  /**
   * Module.trainers
   */
  export type Module$trainersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    where?: TrainerModuleWhereInput
    orderBy?: TrainerModuleOrderByWithRelationInput | TrainerModuleOrderByWithRelationInput[]
    cursor?: TrainerModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainerModuleScalarFieldEnum | TrainerModuleScalarFieldEnum[]
  }

  /**
   * Module.timetables
   */
  export type Module$timetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    cursor?: TimetableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Module.trainerClassModules
   */
  export type Module$trainerClassModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    where?: TrainerClassModuleWhereInput
    orderBy?: TrainerClassModuleOrderByWithRelationInput | TrainerClassModuleOrderByWithRelationInput[]
    cursor?: TrainerClassModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainerClassModuleScalarFieldEnum | TrainerClassModuleScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model TeacherSubject
   */

  export type AggregateTeacherSubject = {
    _count: TeacherSubjectCountAggregateOutputType | null
    _min: TeacherSubjectMinAggregateOutputType | null
    _max: TeacherSubjectMaxAggregateOutputType | null
  }

  export type TeacherSubjectMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    subjectId: string | null
  }

  export type TeacherSubjectMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    subjectId: string | null
  }

  export type TeacherSubjectCountAggregateOutputType = {
    id: number
    teacherId: number
    subjectId: number
    _all: number
  }


  export type TeacherSubjectMinAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
  }

  export type TeacherSubjectMaxAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
  }

  export type TeacherSubjectCountAggregateInputType = {
    id?: true
    teacherId?: true
    subjectId?: true
    _all?: true
  }

  export type TeacherSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherSubject to aggregate.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherSubjects
    **/
    _count?: true | TeacherSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherSubjectMaxAggregateInputType
  }

  export type GetTeacherSubjectAggregateType<T extends TeacherSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherSubject[P]>
      : GetScalarType<T[P], AggregateTeacherSubject[P]>
  }




  export type TeacherSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithAggregationInput | TeacherSubjectOrderByWithAggregationInput[]
    by: TeacherSubjectScalarFieldEnum[] | TeacherSubjectScalarFieldEnum
    having?: TeacherSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherSubjectCountAggregateInputType | true
    _min?: TeacherSubjectMinAggregateInputType
    _max?: TeacherSubjectMaxAggregateInputType
  }

  export type TeacherSubjectGroupByOutputType = {
    id: string
    teacherId: string
    subjectId: string
    _count: TeacherSubjectCountAggregateOutputType | null
    _min: TeacherSubjectMinAggregateOutputType | null
    _max: TeacherSubjectMaxAggregateOutputType | null
  }

  type GetTeacherSubjectGroupByPayload<T extends TeacherSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherSubjectGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherSubject"]>

  export type TeacherSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherSubject"]>

  export type TeacherSubjectSelectScalar = {
    id?: boolean
    teacherId?: boolean
    subjectId?: boolean
  }

  export type TeacherSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type TeacherSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $TeacherSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherSubject"
    objects: {
      teacher: Prisma.$UserPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      subjectId: string
    }, ExtArgs["result"]["teacherSubject"]>
    composites: {}
  }

  type TeacherSubjectGetPayload<S extends boolean | null | undefined | TeacherSubjectDefaultArgs> = $Result.GetResult<Prisma.$TeacherSubjectPayload, S>

  type TeacherSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherSubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherSubjectCountAggregateInputType | true
    }

  export interface TeacherSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherSubject'], meta: { name: 'TeacherSubject' } }
    /**
     * Find zero or one TeacherSubject that matches the filter.
     * @param {TeacherSubjectFindUniqueArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherSubjectFindUniqueArgs>(args: SelectSubset<T, TeacherSubjectFindUniqueArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeacherSubject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherSubjectFindUniqueOrThrowArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeacherSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindFirstArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherSubjectFindFirstArgs>(args?: SelectSubset<T, TeacherSubjectFindFirstArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeacherSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindFirstOrThrowArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeacherSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherSubjects
     * const teacherSubjects = await prisma.teacherSubject.findMany()
     * 
     * // Get first 10 TeacherSubjects
     * const teacherSubjects = await prisma.teacherSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherSubjectWithIdOnly = await prisma.teacherSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherSubjectFindManyArgs>(args?: SelectSubset<T, TeacherSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeacherSubject.
     * @param {TeacherSubjectCreateArgs} args - Arguments to create a TeacherSubject.
     * @example
     * // Create one TeacherSubject
     * const TeacherSubject = await prisma.teacherSubject.create({
     *   data: {
     *     // ... data to create a TeacherSubject
     *   }
     * })
     * 
     */
    create<T extends TeacherSubjectCreateArgs>(args: SelectSubset<T, TeacherSubjectCreateArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeacherSubjects.
     * @param {TeacherSubjectCreateManyArgs} args - Arguments to create many TeacherSubjects.
     * @example
     * // Create many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherSubjectCreateManyArgs>(args?: SelectSubset<T, TeacherSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherSubjects and returns the data saved in the database.
     * @param {TeacherSubjectCreateManyAndReturnArgs} args - Arguments to create many TeacherSubjects.
     * @example
     * // Create many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherSubjects and only return the `id`
     * const teacherSubjectWithIdOnly = await prisma.teacherSubject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeacherSubject.
     * @param {TeacherSubjectDeleteArgs} args - Arguments to delete one TeacherSubject.
     * @example
     * // Delete one TeacherSubject
     * const TeacherSubject = await prisma.teacherSubject.delete({
     *   where: {
     *     // ... filter to delete one TeacherSubject
     *   }
     * })
     * 
     */
    delete<T extends TeacherSubjectDeleteArgs>(args: SelectSubset<T, TeacherSubjectDeleteArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeacherSubject.
     * @param {TeacherSubjectUpdateArgs} args - Arguments to update one TeacherSubject.
     * @example
     * // Update one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherSubjectUpdateArgs>(args: SelectSubset<T, TeacherSubjectUpdateArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeacherSubjects.
     * @param {TeacherSubjectDeleteManyArgs} args - Arguments to filter TeacherSubjects to delete.
     * @example
     * // Delete a few TeacherSubjects
     * const { count } = await prisma.teacherSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherSubjectDeleteManyArgs>(args?: SelectSubset<T, TeacherSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherSubjectUpdateManyArgs>(args: SelectSubset<T, TeacherSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherSubject.
     * @param {TeacherSubjectUpsertArgs} args - Arguments to update or create a TeacherSubject.
     * @example
     * // Update or create a TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.upsert({
     *   create: {
     *     // ... data to create a TeacherSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherSubject we want to update
     *   }
     * })
     */
    upsert<T extends TeacherSubjectUpsertArgs>(args: SelectSubset<T, TeacherSubjectUpsertArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeacherSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectCountArgs} args - Arguments to filter TeacherSubjects to count.
     * @example
     * // Count the number of TeacherSubjects
     * const count = await prisma.teacherSubject.count({
     *   where: {
     *     // ... the filter for the TeacherSubjects we want to count
     *   }
     * })
    **/
    count<T extends TeacherSubjectCountArgs>(
      args?: Subset<T, TeacherSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherSubjectAggregateArgs>(args: Subset<T, TeacherSubjectAggregateArgs>): Prisma.PrismaPromise<GetTeacherSubjectAggregateType<T>>

    /**
     * Group by TeacherSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherSubjectGroupByArgs['orderBy'] }
        : { orderBy?: TeacherSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherSubject model
   */
  readonly fields: TeacherSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherSubject model
   */ 
  interface TeacherSubjectFieldRefs {
    readonly id: FieldRef<"TeacherSubject", 'String'>
    readonly teacherId: FieldRef<"TeacherSubject", 'String'>
    readonly subjectId: FieldRef<"TeacherSubject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeacherSubject findUnique
   */
  export type TeacherSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject findUniqueOrThrow
   */
  export type TeacherSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject findFirst
   */
  export type TeacherSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherSubjects.
     */
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject findFirstOrThrow
   */
  export type TeacherSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherSubjects.
     */
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject findMany
   */
  export type TeacherSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubjects to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject create
   */
  export type TeacherSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherSubject.
     */
    data: XOR<TeacherSubjectCreateInput, TeacherSubjectUncheckedCreateInput>
  }

  /**
   * TeacherSubject createMany
   */
  export type TeacherSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherSubjects.
     */
    data: TeacherSubjectCreateManyInput | TeacherSubjectCreateManyInput[]
  }

  /**
   * TeacherSubject createManyAndReturn
   */
  export type TeacherSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeacherSubjects.
     */
    data: TeacherSubjectCreateManyInput | TeacherSubjectCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherSubject update
   */
  export type TeacherSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherSubject.
     */
    data: XOR<TeacherSubjectUpdateInput, TeacherSubjectUncheckedUpdateInput>
    /**
     * Choose, which TeacherSubject to update.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject updateMany
   */
  export type TeacherSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherSubjects.
     */
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyInput>
    /**
     * Filter which TeacherSubjects to update
     */
    where?: TeacherSubjectWhereInput
  }

  /**
   * TeacherSubject upsert
   */
  export type TeacherSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherSubject to update in case it exists.
     */
    where: TeacherSubjectWhereUniqueInput
    /**
     * In case the TeacherSubject found by the `where` argument doesn't exist, create a new TeacherSubject with this data.
     */
    create: XOR<TeacherSubjectCreateInput, TeacherSubjectUncheckedCreateInput>
    /**
     * In case the TeacherSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherSubjectUpdateInput, TeacherSubjectUncheckedUpdateInput>
  }

  /**
   * TeacherSubject delete
   */
  export type TeacherSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter which TeacherSubject to delete.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject deleteMany
   */
  export type TeacherSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherSubjects to delete
     */
    where?: TeacherSubjectWhereInput
  }

  /**
   * TeacherSubject without action
   */
  export type TeacherSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
  }


  /**
   * Model TrainerModule
   */

  export type AggregateTrainerModule = {
    _count: TrainerModuleCountAggregateOutputType | null
    _min: TrainerModuleMinAggregateOutputType | null
    _max: TrainerModuleMaxAggregateOutputType | null
  }

  export type TrainerModuleMinAggregateOutputType = {
    id: string | null
    trainerId: string | null
    moduleId: string | null
  }

  export type TrainerModuleMaxAggregateOutputType = {
    id: string | null
    trainerId: string | null
    moduleId: string | null
  }

  export type TrainerModuleCountAggregateOutputType = {
    id: number
    trainerId: number
    moduleId: number
    _all: number
  }


  export type TrainerModuleMinAggregateInputType = {
    id?: true
    trainerId?: true
    moduleId?: true
  }

  export type TrainerModuleMaxAggregateInputType = {
    id?: true
    trainerId?: true
    moduleId?: true
  }

  export type TrainerModuleCountAggregateInputType = {
    id?: true
    trainerId?: true
    moduleId?: true
    _all?: true
  }

  export type TrainerModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainerModule to aggregate.
     */
    where?: TrainerModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainerModules to fetch.
     */
    orderBy?: TrainerModuleOrderByWithRelationInput | TrainerModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainerModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainerModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainerModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainerModules
    **/
    _count?: true | TrainerModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainerModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainerModuleMaxAggregateInputType
  }

  export type GetTrainerModuleAggregateType<T extends TrainerModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainerModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainerModule[P]>
      : GetScalarType<T[P], AggregateTrainerModule[P]>
  }




  export type TrainerModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainerModuleWhereInput
    orderBy?: TrainerModuleOrderByWithAggregationInput | TrainerModuleOrderByWithAggregationInput[]
    by: TrainerModuleScalarFieldEnum[] | TrainerModuleScalarFieldEnum
    having?: TrainerModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainerModuleCountAggregateInputType | true
    _min?: TrainerModuleMinAggregateInputType
    _max?: TrainerModuleMaxAggregateInputType
  }

  export type TrainerModuleGroupByOutputType = {
    id: string
    trainerId: string
    moduleId: string
    _count: TrainerModuleCountAggregateOutputType | null
    _min: TrainerModuleMinAggregateOutputType | null
    _max: TrainerModuleMaxAggregateOutputType | null
  }

  type GetTrainerModuleGroupByPayload<T extends TrainerModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainerModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainerModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainerModuleGroupByOutputType[P]>
            : GetScalarType<T[P], TrainerModuleGroupByOutputType[P]>
        }
      >
    >


  export type TrainerModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainerId?: boolean
    moduleId?: boolean
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainerModule"]>

  export type TrainerModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainerId?: boolean
    moduleId?: boolean
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainerModule"]>

  export type TrainerModuleSelectScalar = {
    id?: boolean
    trainerId?: boolean
    moduleId?: boolean
  }

  export type TrainerModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type TrainerModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $TrainerModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainerModule"
    objects: {
      trainer: Prisma.$UserPayload<ExtArgs>
      module: Prisma.$ModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainerId: string
      moduleId: string
    }, ExtArgs["result"]["trainerModule"]>
    composites: {}
  }

  type TrainerModuleGetPayload<S extends boolean | null | undefined | TrainerModuleDefaultArgs> = $Result.GetResult<Prisma.$TrainerModulePayload, S>

  type TrainerModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainerModuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainerModuleCountAggregateInputType | true
    }

  export interface TrainerModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainerModule'], meta: { name: 'TrainerModule' } }
    /**
     * Find zero or one TrainerModule that matches the filter.
     * @param {TrainerModuleFindUniqueArgs} args - Arguments to find a TrainerModule
     * @example
     * // Get one TrainerModule
     * const trainerModule = await prisma.trainerModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainerModuleFindUniqueArgs>(args: SelectSubset<T, TrainerModuleFindUniqueArgs<ExtArgs>>): Prisma__TrainerModuleClient<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainerModule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainerModuleFindUniqueOrThrowArgs} args - Arguments to find a TrainerModule
     * @example
     * // Get one TrainerModule
     * const trainerModule = await prisma.trainerModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainerModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainerModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainerModuleClient<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainerModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerModuleFindFirstArgs} args - Arguments to find a TrainerModule
     * @example
     * // Get one TrainerModule
     * const trainerModule = await prisma.trainerModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainerModuleFindFirstArgs>(args?: SelectSubset<T, TrainerModuleFindFirstArgs<ExtArgs>>): Prisma__TrainerModuleClient<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainerModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerModuleFindFirstOrThrowArgs} args - Arguments to find a TrainerModule
     * @example
     * // Get one TrainerModule
     * const trainerModule = await prisma.trainerModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainerModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainerModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainerModuleClient<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainerModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainerModules
     * const trainerModules = await prisma.trainerModule.findMany()
     * 
     * // Get first 10 TrainerModules
     * const trainerModules = await prisma.trainerModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainerModuleWithIdOnly = await prisma.trainerModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainerModuleFindManyArgs>(args?: SelectSubset<T, TrainerModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainerModule.
     * @param {TrainerModuleCreateArgs} args - Arguments to create a TrainerModule.
     * @example
     * // Create one TrainerModule
     * const TrainerModule = await prisma.trainerModule.create({
     *   data: {
     *     // ... data to create a TrainerModule
     *   }
     * })
     * 
     */
    create<T extends TrainerModuleCreateArgs>(args: SelectSubset<T, TrainerModuleCreateArgs<ExtArgs>>): Prisma__TrainerModuleClient<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainerModules.
     * @param {TrainerModuleCreateManyArgs} args - Arguments to create many TrainerModules.
     * @example
     * // Create many TrainerModules
     * const trainerModule = await prisma.trainerModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainerModuleCreateManyArgs>(args?: SelectSubset<T, TrainerModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainerModules and returns the data saved in the database.
     * @param {TrainerModuleCreateManyAndReturnArgs} args - Arguments to create many TrainerModules.
     * @example
     * // Create many TrainerModules
     * const trainerModule = await prisma.trainerModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainerModules and only return the `id`
     * const trainerModuleWithIdOnly = await prisma.trainerModule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainerModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainerModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainerModule.
     * @param {TrainerModuleDeleteArgs} args - Arguments to delete one TrainerModule.
     * @example
     * // Delete one TrainerModule
     * const TrainerModule = await prisma.trainerModule.delete({
     *   where: {
     *     // ... filter to delete one TrainerModule
     *   }
     * })
     * 
     */
    delete<T extends TrainerModuleDeleteArgs>(args: SelectSubset<T, TrainerModuleDeleteArgs<ExtArgs>>): Prisma__TrainerModuleClient<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainerModule.
     * @param {TrainerModuleUpdateArgs} args - Arguments to update one TrainerModule.
     * @example
     * // Update one TrainerModule
     * const trainerModule = await prisma.trainerModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainerModuleUpdateArgs>(args: SelectSubset<T, TrainerModuleUpdateArgs<ExtArgs>>): Prisma__TrainerModuleClient<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainerModules.
     * @param {TrainerModuleDeleteManyArgs} args - Arguments to filter TrainerModules to delete.
     * @example
     * // Delete a few TrainerModules
     * const { count } = await prisma.trainerModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainerModuleDeleteManyArgs>(args?: SelectSubset<T, TrainerModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainerModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainerModules
     * const trainerModule = await prisma.trainerModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainerModuleUpdateManyArgs>(args: SelectSubset<T, TrainerModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainerModule.
     * @param {TrainerModuleUpsertArgs} args - Arguments to update or create a TrainerModule.
     * @example
     * // Update or create a TrainerModule
     * const trainerModule = await prisma.trainerModule.upsert({
     *   create: {
     *     // ... data to create a TrainerModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainerModule we want to update
     *   }
     * })
     */
    upsert<T extends TrainerModuleUpsertArgs>(args: SelectSubset<T, TrainerModuleUpsertArgs<ExtArgs>>): Prisma__TrainerModuleClient<$Result.GetResult<Prisma.$TrainerModulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainerModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerModuleCountArgs} args - Arguments to filter TrainerModules to count.
     * @example
     * // Count the number of TrainerModules
     * const count = await prisma.trainerModule.count({
     *   where: {
     *     // ... the filter for the TrainerModules we want to count
     *   }
     * })
    **/
    count<T extends TrainerModuleCountArgs>(
      args?: Subset<T, TrainerModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainerModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainerModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainerModuleAggregateArgs>(args: Subset<T, TrainerModuleAggregateArgs>): Prisma.PrismaPromise<GetTrainerModuleAggregateType<T>>

    /**
     * Group by TrainerModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainerModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainerModuleGroupByArgs['orderBy'] }
        : { orderBy?: TrainerModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainerModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainerModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainerModule model
   */
  readonly fields: TrainerModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainerModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainerModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainerModule model
   */ 
  interface TrainerModuleFieldRefs {
    readonly id: FieldRef<"TrainerModule", 'String'>
    readonly trainerId: FieldRef<"TrainerModule", 'String'>
    readonly moduleId: FieldRef<"TrainerModule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TrainerModule findUnique
   */
  export type TrainerModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainerModule to fetch.
     */
    where: TrainerModuleWhereUniqueInput
  }

  /**
   * TrainerModule findUniqueOrThrow
   */
  export type TrainerModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainerModule to fetch.
     */
    where: TrainerModuleWhereUniqueInput
  }

  /**
   * TrainerModule findFirst
   */
  export type TrainerModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainerModule to fetch.
     */
    where?: TrainerModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainerModules to fetch.
     */
    orderBy?: TrainerModuleOrderByWithRelationInput | TrainerModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainerModules.
     */
    cursor?: TrainerModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainerModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainerModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainerModules.
     */
    distinct?: TrainerModuleScalarFieldEnum | TrainerModuleScalarFieldEnum[]
  }

  /**
   * TrainerModule findFirstOrThrow
   */
  export type TrainerModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainerModule to fetch.
     */
    where?: TrainerModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainerModules to fetch.
     */
    orderBy?: TrainerModuleOrderByWithRelationInput | TrainerModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainerModules.
     */
    cursor?: TrainerModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainerModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainerModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainerModules.
     */
    distinct?: TrainerModuleScalarFieldEnum | TrainerModuleScalarFieldEnum[]
  }

  /**
   * TrainerModule findMany
   */
  export type TrainerModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainerModules to fetch.
     */
    where?: TrainerModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainerModules to fetch.
     */
    orderBy?: TrainerModuleOrderByWithRelationInput | TrainerModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainerModules.
     */
    cursor?: TrainerModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainerModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainerModules.
     */
    skip?: number
    distinct?: TrainerModuleScalarFieldEnum | TrainerModuleScalarFieldEnum[]
  }

  /**
   * TrainerModule create
   */
  export type TrainerModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainerModule.
     */
    data: XOR<TrainerModuleCreateInput, TrainerModuleUncheckedCreateInput>
  }

  /**
   * TrainerModule createMany
   */
  export type TrainerModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainerModules.
     */
    data: TrainerModuleCreateManyInput | TrainerModuleCreateManyInput[]
  }

  /**
   * TrainerModule createManyAndReturn
   */
  export type TrainerModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainerModules.
     */
    data: TrainerModuleCreateManyInput | TrainerModuleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainerModule update
   */
  export type TrainerModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainerModule.
     */
    data: XOR<TrainerModuleUpdateInput, TrainerModuleUncheckedUpdateInput>
    /**
     * Choose, which TrainerModule to update.
     */
    where: TrainerModuleWhereUniqueInput
  }

  /**
   * TrainerModule updateMany
   */
  export type TrainerModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainerModules.
     */
    data: XOR<TrainerModuleUpdateManyMutationInput, TrainerModuleUncheckedUpdateManyInput>
    /**
     * Filter which TrainerModules to update
     */
    where?: TrainerModuleWhereInput
  }

  /**
   * TrainerModule upsert
   */
  export type TrainerModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainerModule to update in case it exists.
     */
    where: TrainerModuleWhereUniqueInput
    /**
     * In case the TrainerModule found by the `where` argument doesn't exist, create a new TrainerModule with this data.
     */
    create: XOR<TrainerModuleCreateInput, TrainerModuleUncheckedCreateInput>
    /**
     * In case the TrainerModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainerModuleUpdateInput, TrainerModuleUncheckedUpdateInput>
  }

  /**
   * TrainerModule delete
   */
  export type TrainerModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
    /**
     * Filter which TrainerModule to delete.
     */
    where: TrainerModuleWhereUniqueInput
  }

  /**
   * TrainerModule deleteMany
   */
  export type TrainerModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainerModules to delete
     */
    where?: TrainerModuleWhereInput
  }

  /**
   * TrainerModule without action
   */
  export type TrainerModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerModule
     */
    select?: TrainerModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerModuleInclude<ExtArgs> | null
  }


  /**
   * Model ClassSubject
   */

  export type AggregateClassSubject = {
    _count: ClassSubjectCountAggregateOutputType | null
    _min: ClassSubjectMinAggregateOutputType | null
    _max: ClassSubjectMaxAggregateOutputType | null
  }

  export type ClassSubjectMinAggregateOutputType = {
    id: string | null
    classId: string | null
    subjectId: string | null
  }

  export type ClassSubjectMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    subjectId: string | null
  }

  export type ClassSubjectCountAggregateOutputType = {
    id: number
    classId: number
    subjectId: number
    _all: number
  }


  export type ClassSubjectMinAggregateInputType = {
    id?: true
    classId?: true
    subjectId?: true
  }

  export type ClassSubjectMaxAggregateInputType = {
    id?: true
    classId?: true
    subjectId?: true
  }

  export type ClassSubjectCountAggregateInputType = {
    id?: true
    classId?: true
    subjectId?: true
    _all?: true
  }

  export type ClassSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSubject to aggregate.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSubjects
    **/
    _count?: true | ClassSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassSubjectMaxAggregateInputType
  }

  export type GetClassSubjectAggregateType<T extends ClassSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSubject[P]>
      : GetScalarType<T[P], AggregateClassSubject[P]>
  }




  export type ClassSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSubjectWhereInput
    orderBy?: ClassSubjectOrderByWithAggregationInput | ClassSubjectOrderByWithAggregationInput[]
    by: ClassSubjectScalarFieldEnum[] | ClassSubjectScalarFieldEnum
    having?: ClassSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassSubjectCountAggregateInputType | true
    _min?: ClassSubjectMinAggregateInputType
    _max?: ClassSubjectMaxAggregateInputType
  }

  export type ClassSubjectGroupByOutputType = {
    id: string
    classId: string
    subjectId: string
    _count: ClassSubjectCountAggregateOutputType | null
    _min: ClassSubjectMinAggregateOutputType | null
    _max: ClassSubjectMaxAggregateOutputType | null
  }

  type GetClassSubjectGroupByPayload<T extends ClassSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], ClassSubjectGroupByOutputType[P]>
        }
      >
    >


  export type ClassSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    subjectId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSubject"]>

  export type ClassSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    subjectId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSubject"]>

  export type ClassSubjectSelectScalar = {
    id?: boolean
    classId?: boolean
    subjectId?: boolean
  }

  export type ClassSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type ClassSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $ClassSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSubject"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      subjectId: string
    }, ExtArgs["result"]["classSubject"]>
    composites: {}
  }

  type ClassSubjectGetPayload<S extends boolean | null | undefined | ClassSubjectDefaultArgs> = $Result.GetResult<Prisma.$ClassSubjectPayload, S>

  type ClassSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassSubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassSubjectCountAggregateInputType | true
    }

  export interface ClassSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSubject'], meta: { name: 'ClassSubject' } }
    /**
     * Find zero or one ClassSubject that matches the filter.
     * @param {ClassSubjectFindUniqueArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassSubjectFindUniqueArgs>(args: SelectSubset<T, ClassSubjectFindUniqueArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassSubject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassSubjectFindUniqueOrThrowArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectFindFirstArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassSubjectFindFirstArgs>(args?: SelectSubset<T, ClassSubjectFindFirstArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectFindFirstOrThrowArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSubjects
     * const classSubjects = await prisma.classSubject.findMany()
     * 
     * // Get first 10 ClassSubjects
     * const classSubjects = await prisma.classSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classSubjectWithIdOnly = await prisma.classSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassSubjectFindManyArgs>(args?: SelectSubset<T, ClassSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassSubject.
     * @param {ClassSubjectCreateArgs} args - Arguments to create a ClassSubject.
     * @example
     * // Create one ClassSubject
     * const ClassSubject = await prisma.classSubject.create({
     *   data: {
     *     // ... data to create a ClassSubject
     *   }
     * })
     * 
     */
    create<T extends ClassSubjectCreateArgs>(args: SelectSubset<T, ClassSubjectCreateArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassSubjects.
     * @param {ClassSubjectCreateManyArgs} args - Arguments to create many ClassSubjects.
     * @example
     * // Create many ClassSubjects
     * const classSubject = await prisma.classSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassSubjectCreateManyArgs>(args?: SelectSubset<T, ClassSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassSubjects and returns the data saved in the database.
     * @param {ClassSubjectCreateManyAndReturnArgs} args - Arguments to create many ClassSubjects.
     * @example
     * // Create many ClassSubjects
     * const classSubject = await prisma.classSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassSubjects and only return the `id`
     * const classSubjectWithIdOnly = await prisma.classSubject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClassSubject.
     * @param {ClassSubjectDeleteArgs} args - Arguments to delete one ClassSubject.
     * @example
     * // Delete one ClassSubject
     * const ClassSubject = await prisma.classSubject.delete({
     *   where: {
     *     // ... filter to delete one ClassSubject
     *   }
     * })
     * 
     */
    delete<T extends ClassSubjectDeleteArgs>(args: SelectSubset<T, ClassSubjectDeleteArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassSubject.
     * @param {ClassSubjectUpdateArgs} args - Arguments to update one ClassSubject.
     * @example
     * // Update one ClassSubject
     * const classSubject = await prisma.classSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassSubjectUpdateArgs>(args: SelectSubset<T, ClassSubjectUpdateArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassSubjects.
     * @param {ClassSubjectDeleteManyArgs} args - Arguments to filter ClassSubjects to delete.
     * @example
     * // Delete a few ClassSubjects
     * const { count } = await prisma.classSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassSubjectDeleteManyArgs>(args?: SelectSubset<T, ClassSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSubjects
     * const classSubject = await prisma.classSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassSubjectUpdateManyArgs>(args: SelectSubset<T, ClassSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassSubject.
     * @param {ClassSubjectUpsertArgs} args - Arguments to update or create a ClassSubject.
     * @example
     * // Update or create a ClassSubject
     * const classSubject = await prisma.classSubject.upsert({
     *   create: {
     *     // ... data to create a ClassSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSubject we want to update
     *   }
     * })
     */
    upsert<T extends ClassSubjectUpsertArgs>(args: SelectSubset<T, ClassSubjectUpsertArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectCountArgs} args - Arguments to filter ClassSubjects to count.
     * @example
     * // Count the number of ClassSubjects
     * const count = await prisma.classSubject.count({
     *   where: {
     *     // ... the filter for the ClassSubjects we want to count
     *   }
     * })
    **/
    count<T extends ClassSubjectCountArgs>(
      args?: Subset<T, ClassSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassSubjectAggregateArgs>(args: Subset<T, ClassSubjectAggregateArgs>): Prisma.PrismaPromise<GetClassSubjectAggregateType<T>>

    /**
     * Group by ClassSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassSubjectGroupByArgs['orderBy'] }
        : { orderBy?: ClassSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSubject model
   */
  readonly fields: ClassSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSubject model
   */ 
  interface ClassSubjectFieldRefs {
    readonly id: FieldRef<"ClassSubject", 'String'>
    readonly classId: FieldRef<"ClassSubject", 'String'>
    readonly subjectId: FieldRef<"ClassSubject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassSubject findUnique
   */
  export type ClassSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject findUniqueOrThrow
   */
  export type ClassSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject findFirst
   */
  export type ClassSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSubjects.
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSubjects.
     */
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * ClassSubject findFirstOrThrow
   */
  export type ClassSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSubjects.
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSubjects.
     */
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * ClassSubject findMany
   */
  export type ClassSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubjects to fetch.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSubjects.
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * ClassSubject create
   */
  export type ClassSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSubject.
     */
    data: XOR<ClassSubjectCreateInput, ClassSubjectUncheckedCreateInput>
  }

  /**
   * ClassSubject createMany
   */
  export type ClassSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSubjects.
     */
    data: ClassSubjectCreateManyInput | ClassSubjectCreateManyInput[]
  }

  /**
   * ClassSubject createManyAndReturn
   */
  export type ClassSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClassSubjects.
     */
    data: ClassSubjectCreateManyInput | ClassSubjectCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassSubject update
   */
  export type ClassSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSubject.
     */
    data: XOR<ClassSubjectUpdateInput, ClassSubjectUncheckedUpdateInput>
    /**
     * Choose, which ClassSubject to update.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject updateMany
   */
  export type ClassSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSubjects.
     */
    data: XOR<ClassSubjectUpdateManyMutationInput, ClassSubjectUncheckedUpdateManyInput>
    /**
     * Filter which ClassSubjects to update
     */
    where?: ClassSubjectWhereInput
  }

  /**
   * ClassSubject upsert
   */
  export type ClassSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSubject to update in case it exists.
     */
    where: ClassSubjectWhereUniqueInput
    /**
     * In case the ClassSubject found by the `where` argument doesn't exist, create a new ClassSubject with this data.
     */
    create: XOR<ClassSubjectCreateInput, ClassSubjectUncheckedCreateInput>
    /**
     * In case the ClassSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassSubjectUpdateInput, ClassSubjectUncheckedUpdateInput>
  }

  /**
   * ClassSubject delete
   */
  export type ClassSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter which ClassSubject to delete.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject deleteMany
   */
  export type ClassSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSubjects to delete
     */
    where?: ClassSubjectWhereInput
  }

  /**
   * ClassSubject without action
   */
  export type ClassSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
  }


  /**
   * Model TimeSlot
   */

  export type AggregateTimeSlot = {
    _count: TimeSlotCountAggregateOutputType | null
    _avg: TimeSlotAvgAggregateOutputType | null
    _sum: TimeSlotSumAggregateOutputType | null
    _min: TimeSlotMinAggregateOutputType | null
    _max: TimeSlotMaxAggregateOutputType | null
  }

  export type TimeSlotAvgAggregateOutputType = {
    period: number | null
  }

  export type TimeSlotSumAggregateOutputType = {
    period: number | null
  }

  export type TimeSlotMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    day: string | null
    period: number | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    session: string | null
    isBreak: boolean | null
    breakType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeSlotMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    day: string | null
    period: number | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    session: string | null
    isBreak: boolean | null
    breakType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeSlotCountAggregateOutputType = {
    id: number
    schoolId: number
    day: number
    period: number
    name: number
    startTime: number
    endTime: number
    session: number
    isBreak: number
    breakType: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimeSlotAvgAggregateInputType = {
    period?: true
  }

  export type TimeSlotSumAggregateInputType = {
    period?: true
  }

  export type TimeSlotMinAggregateInputType = {
    id?: true
    schoolId?: true
    day?: true
    period?: true
    name?: true
    startTime?: true
    endTime?: true
    session?: true
    isBreak?: true
    breakType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeSlotMaxAggregateInputType = {
    id?: true
    schoolId?: true
    day?: true
    period?: true
    name?: true
    startTime?: true
    endTime?: true
    session?: true
    isBreak?: true
    breakType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeSlotCountAggregateInputType = {
    id?: true
    schoolId?: true
    day?: true
    period?: true
    name?: true
    startTime?: true
    endTime?: true
    session?: true
    isBreak?: true
    breakType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimeSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlot to aggregate.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSlots
    **/
    _count?: true | TimeSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeSlotMaxAggregateInputType
  }

  export type GetTimeSlotAggregateType<T extends TimeSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSlot[P]>
      : GetScalarType<T[P], AggregateTimeSlot[P]>
  }




  export type TimeSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotWhereInput
    orderBy?: TimeSlotOrderByWithAggregationInput | TimeSlotOrderByWithAggregationInput[]
    by: TimeSlotScalarFieldEnum[] | TimeSlotScalarFieldEnum
    having?: TimeSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeSlotCountAggregateInputType | true
    _avg?: TimeSlotAvgAggregateInputType
    _sum?: TimeSlotSumAggregateInputType
    _min?: TimeSlotMinAggregateInputType
    _max?: TimeSlotMaxAggregateInputType
  }

  export type TimeSlotGroupByOutputType = {
    id: string
    schoolId: string
    day: string
    period: number
    name: string
    startTime: Date
    endTime: Date
    session: string
    isBreak: boolean
    breakType: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TimeSlotCountAggregateOutputType | null
    _avg: TimeSlotAvgAggregateOutputType | null
    _sum: TimeSlotSumAggregateOutputType | null
    _min: TimeSlotMinAggregateOutputType | null
    _max: TimeSlotMaxAggregateOutputType | null
  }

  type GetTimeSlotGroupByPayload<T extends TimeSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeSlotGroupByOutputType[P]>
            : GetScalarType<T[P], TimeSlotGroupByOutputType[P]>
        }
      >
    >


  export type TimeSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    day?: boolean
    period?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    session?: boolean
    isBreak?: boolean
    breakType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    timetables?: boolean | TimeSlot$timetablesArgs<ExtArgs>
    _count?: boolean | TimeSlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    day?: boolean
    period?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    session?: boolean
    isBreak?: boolean
    breakType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectScalar = {
    id?: boolean
    schoolId?: boolean
    day?: boolean
    period?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    session?: boolean
    isBreak?: boolean
    breakType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimeSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    timetables?: boolean | TimeSlot$timetablesArgs<ExtArgs>
    _count?: boolean | TimeSlotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TimeSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $TimeSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeSlot"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      timetables: Prisma.$TimetablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      day: string
      period: number
      name: string
      startTime: Date
      endTime: Date
      session: string
      isBreak: boolean
      breakType: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timeSlot"]>
    composites: {}
  }

  type TimeSlotGetPayload<S extends boolean | null | undefined | TimeSlotDefaultArgs> = $Result.GetResult<Prisma.$TimeSlotPayload, S>

  type TimeSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimeSlotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimeSlotCountAggregateInputType | true
    }

  export interface TimeSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeSlot'], meta: { name: 'TimeSlot' } }
    /**
     * Find zero or one TimeSlot that matches the filter.
     * @param {TimeSlotFindUniqueArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeSlotFindUniqueArgs>(args: SelectSubset<T, TimeSlotFindUniqueArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimeSlot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimeSlotFindUniqueOrThrowArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimeSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindFirstArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeSlotFindFirstArgs>(args?: SelectSubset<T, TimeSlotFindFirstArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimeSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindFirstOrThrowArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimeSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSlots
     * const timeSlots = await prisma.timeSlot.findMany()
     * 
     * // Get first 10 TimeSlots
     * const timeSlots = await prisma.timeSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeSlotFindManyArgs>(args?: SelectSubset<T, TimeSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimeSlot.
     * @param {TimeSlotCreateArgs} args - Arguments to create a TimeSlot.
     * @example
     * // Create one TimeSlot
     * const TimeSlot = await prisma.timeSlot.create({
     *   data: {
     *     // ... data to create a TimeSlot
     *   }
     * })
     * 
     */
    create<T extends TimeSlotCreateArgs>(args: SelectSubset<T, TimeSlotCreateArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimeSlots.
     * @param {TimeSlotCreateManyArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlot = await prisma.timeSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeSlotCreateManyArgs>(args?: SelectSubset<T, TimeSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeSlots and returns the data saved in the database.
     * @param {TimeSlotCreateManyAndReturnArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlot = await prisma.timeSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeSlots and only return the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TimeSlot.
     * @param {TimeSlotDeleteArgs} args - Arguments to delete one TimeSlot.
     * @example
     * // Delete one TimeSlot
     * const TimeSlot = await prisma.timeSlot.delete({
     *   where: {
     *     // ... filter to delete one TimeSlot
     *   }
     * })
     * 
     */
    delete<T extends TimeSlotDeleteArgs>(args: SelectSubset<T, TimeSlotDeleteArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimeSlot.
     * @param {TimeSlotUpdateArgs} args - Arguments to update one TimeSlot.
     * @example
     * // Update one TimeSlot
     * const timeSlot = await prisma.timeSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeSlotUpdateArgs>(args: SelectSubset<T, TimeSlotUpdateArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimeSlots.
     * @param {TimeSlotDeleteManyArgs} args - Arguments to filter TimeSlots to delete.
     * @example
     * // Delete a few TimeSlots
     * const { count } = await prisma.timeSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeSlotDeleteManyArgs>(args?: SelectSubset<T, TimeSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSlots
     * const timeSlot = await prisma.timeSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeSlotUpdateManyArgs>(args: SelectSubset<T, TimeSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeSlot.
     * @param {TimeSlotUpsertArgs} args - Arguments to update or create a TimeSlot.
     * @example
     * // Update or create a TimeSlot
     * const timeSlot = await prisma.timeSlot.upsert({
     *   create: {
     *     // ... data to create a TimeSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSlot we want to update
     *   }
     * })
     */
    upsert<T extends TimeSlotUpsertArgs>(args: SelectSubset<T, TimeSlotUpsertArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotCountArgs} args - Arguments to filter TimeSlots to count.
     * @example
     * // Count the number of TimeSlots
     * const count = await prisma.timeSlot.count({
     *   where: {
     *     // ... the filter for the TimeSlots we want to count
     *   }
     * })
    **/
    count<T extends TimeSlotCountArgs>(
      args?: Subset<T, TimeSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSlotAggregateArgs>(args: Subset<T, TimeSlotAggregateArgs>): Prisma.PrismaPromise<GetTimeSlotAggregateType<T>>

    /**
     * Group by TimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeSlotGroupByArgs['orderBy'] }
        : { orderBy?: TimeSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeSlot model
   */
  readonly fields: TimeSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    timetables<T extends TimeSlot$timetablesArgs<ExtArgs> = {}>(args?: Subset<T, TimeSlot$timetablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeSlot model
   */ 
  interface TimeSlotFieldRefs {
    readonly id: FieldRef<"TimeSlot", 'String'>
    readonly schoolId: FieldRef<"TimeSlot", 'String'>
    readonly day: FieldRef<"TimeSlot", 'String'>
    readonly period: FieldRef<"TimeSlot", 'Int'>
    readonly name: FieldRef<"TimeSlot", 'String'>
    readonly startTime: FieldRef<"TimeSlot", 'DateTime'>
    readonly endTime: FieldRef<"TimeSlot", 'DateTime'>
    readonly session: FieldRef<"TimeSlot", 'String'>
    readonly isBreak: FieldRef<"TimeSlot", 'Boolean'>
    readonly breakType: FieldRef<"TimeSlot", 'String'>
    readonly isActive: FieldRef<"TimeSlot", 'Boolean'>
    readonly createdAt: FieldRef<"TimeSlot", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimeSlot findUnique
   */
  export type TimeSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot findUniqueOrThrow
   */
  export type TimeSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot findFirst
   */
  export type TimeSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot findFirstOrThrow
   */
  export type TimeSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot findMany
   */
  export type TimeSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlots to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot create
   */
  export type TimeSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeSlot.
     */
    data: XOR<TimeSlotCreateInput, TimeSlotUncheckedCreateInput>
  }

  /**
   * TimeSlot createMany
   */
  export type TimeSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotCreateManyInput | TimeSlotCreateManyInput[]
  }

  /**
   * TimeSlot createManyAndReturn
   */
  export type TimeSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotCreateManyInput | TimeSlotCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSlot update
   */
  export type TimeSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeSlot.
     */
    data: XOR<TimeSlotUpdateInput, TimeSlotUncheckedUpdateInput>
    /**
     * Choose, which TimeSlot to update.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot updateMany
   */
  export type TimeSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeSlots.
     */
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which TimeSlots to update
     */
    where?: TimeSlotWhereInput
  }

  /**
   * TimeSlot upsert
   */
  export type TimeSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeSlot to update in case it exists.
     */
    where: TimeSlotWhereUniqueInput
    /**
     * In case the TimeSlot found by the `where` argument doesn't exist, create a new TimeSlot with this data.
     */
    create: XOR<TimeSlotCreateInput, TimeSlotUncheckedCreateInput>
    /**
     * In case the TimeSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeSlotUpdateInput, TimeSlotUncheckedUpdateInput>
  }

  /**
   * TimeSlot delete
   */
  export type TimeSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter which TimeSlot to delete.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot deleteMany
   */
  export type TimeSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlots to delete
     */
    where?: TimeSlotWhereInput
  }

  /**
   * TimeSlot.timetables
   */
  export type TimeSlot$timetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    cursor?: TimetableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * TimeSlot without action
   */
  export type TimeSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
  }


  /**
   * Model Timetable
   */

  export type AggregateTimetable = {
    _count: TimetableCountAggregateOutputType | null
    _min: TimetableMinAggregateOutputType | null
    _max: TimetableMaxAggregateOutputType | null
  }

  export type TimetableMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    classId: string | null
    teacherId: string | null
    subjectId: string | null
    moduleId: string | null
    timeSlotId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimetableMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    classId: string | null
    teacherId: string | null
    subjectId: string | null
    moduleId: string | null
    timeSlotId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimetableCountAggregateOutputType = {
    id: number
    schoolId: number
    classId: number
    teacherId: number
    subjectId: number
    moduleId: number
    timeSlotId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimetableMinAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    teacherId?: true
    subjectId?: true
    moduleId?: true
    timeSlotId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimetableMaxAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    teacherId?: true
    subjectId?: true
    moduleId?: true
    timeSlotId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimetableCountAggregateInputType = {
    id?: true
    schoolId?: true
    classId?: true
    teacherId?: true
    subjectId?: true
    moduleId?: true
    timeSlotId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimetableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timetable to aggregate.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Timetables
    **/
    _count?: true | TimetableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimetableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimetableMaxAggregateInputType
  }

  export type GetTimetableAggregateType<T extends TimetableAggregateArgs> = {
        [P in keyof T & keyof AggregateTimetable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimetable[P]>
      : GetScalarType<T[P], AggregateTimetable[P]>
  }




  export type TimetableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithAggregationInput | TimetableOrderByWithAggregationInput[]
    by: TimetableScalarFieldEnum[] | TimetableScalarFieldEnum
    having?: TimetableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimetableCountAggregateInputType | true
    _min?: TimetableMinAggregateInputType
    _max?: TimetableMaxAggregateInputType
  }

  export type TimetableGroupByOutputType = {
    id: string
    schoolId: string
    classId: string
    teacherId: string
    subjectId: string | null
    moduleId: string | null
    timeSlotId: string
    createdAt: Date
    updatedAt: Date
    _count: TimetableCountAggregateOutputType | null
    _min: TimetableMinAggregateOutputType | null
    _max: TimetableMaxAggregateOutputType | null
  }

  type GetTimetableGroupByPayload<T extends TimetableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimetableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimetableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimetableGroupByOutputType[P]>
            : GetScalarType<T[P], TimetableGroupByOutputType[P]>
        }
      >
    >


  export type TimetableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    classId?: boolean
    teacherId?: boolean
    subjectId?: boolean
    moduleId?: boolean
    timeSlotId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | Timetable$subjectArgs<ExtArgs>
    module?: boolean | Timetable$moduleArgs<ExtArgs>
    timeSlot?: boolean | TimeSlotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timetable"]>

  export type TimetableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    classId?: boolean
    teacherId?: boolean
    subjectId?: boolean
    moduleId?: boolean
    timeSlotId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | Timetable$subjectArgs<ExtArgs>
    module?: boolean | Timetable$moduleArgs<ExtArgs>
    timeSlot?: boolean | TimeSlotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timetable"]>

  export type TimetableSelectScalar = {
    id?: boolean
    schoolId?: boolean
    classId?: boolean
    teacherId?: boolean
    subjectId?: boolean
    moduleId?: boolean
    timeSlotId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimetableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | Timetable$subjectArgs<ExtArgs>
    module?: boolean | Timetable$moduleArgs<ExtArgs>
    timeSlot?: boolean | TimeSlotDefaultArgs<ExtArgs>
  }
  export type TimetableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    subject?: boolean | Timetable$subjectArgs<ExtArgs>
    module?: boolean | Timetable$moduleArgs<ExtArgs>
    timeSlot?: boolean | TimeSlotDefaultArgs<ExtArgs>
  }

  export type $TimetablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Timetable"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      teacher: Prisma.$UserPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs> | null
      module: Prisma.$ModulePayload<ExtArgs> | null
      timeSlot: Prisma.$TimeSlotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      classId: string
      teacherId: string
      subjectId: string | null
      moduleId: string | null
      timeSlotId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timetable"]>
    composites: {}
  }

  type TimetableGetPayload<S extends boolean | null | undefined | TimetableDefaultArgs> = $Result.GetResult<Prisma.$TimetablePayload, S>

  type TimetableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimetableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimetableCountAggregateInputType | true
    }

  export interface TimetableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Timetable'], meta: { name: 'Timetable' } }
    /**
     * Find zero or one Timetable that matches the filter.
     * @param {TimetableFindUniqueArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimetableFindUniqueArgs>(args: SelectSubset<T, TimetableFindUniqueArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Timetable that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimetableFindUniqueOrThrowArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimetableFindUniqueOrThrowArgs>(args: SelectSubset<T, TimetableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Timetable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableFindFirstArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimetableFindFirstArgs>(args?: SelectSubset<T, TimetableFindFirstArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Timetable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableFindFirstOrThrowArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimetableFindFirstOrThrowArgs>(args?: SelectSubset<T, TimetableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Timetables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Timetables
     * const timetables = await prisma.timetable.findMany()
     * 
     * // Get first 10 Timetables
     * const timetables = await prisma.timetable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timetableWithIdOnly = await prisma.timetable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimetableFindManyArgs>(args?: SelectSubset<T, TimetableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Timetable.
     * @param {TimetableCreateArgs} args - Arguments to create a Timetable.
     * @example
     * // Create one Timetable
     * const Timetable = await prisma.timetable.create({
     *   data: {
     *     // ... data to create a Timetable
     *   }
     * })
     * 
     */
    create<T extends TimetableCreateArgs>(args: SelectSubset<T, TimetableCreateArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Timetables.
     * @param {TimetableCreateManyArgs} args - Arguments to create many Timetables.
     * @example
     * // Create many Timetables
     * const timetable = await prisma.timetable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimetableCreateManyArgs>(args?: SelectSubset<T, TimetableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Timetables and returns the data saved in the database.
     * @param {TimetableCreateManyAndReturnArgs} args - Arguments to create many Timetables.
     * @example
     * // Create many Timetables
     * const timetable = await prisma.timetable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Timetables and only return the `id`
     * const timetableWithIdOnly = await prisma.timetable.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimetableCreateManyAndReturnArgs>(args?: SelectSubset<T, TimetableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Timetable.
     * @param {TimetableDeleteArgs} args - Arguments to delete one Timetable.
     * @example
     * // Delete one Timetable
     * const Timetable = await prisma.timetable.delete({
     *   where: {
     *     // ... filter to delete one Timetable
     *   }
     * })
     * 
     */
    delete<T extends TimetableDeleteArgs>(args: SelectSubset<T, TimetableDeleteArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Timetable.
     * @param {TimetableUpdateArgs} args - Arguments to update one Timetable.
     * @example
     * // Update one Timetable
     * const timetable = await prisma.timetable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimetableUpdateArgs>(args: SelectSubset<T, TimetableUpdateArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Timetables.
     * @param {TimetableDeleteManyArgs} args - Arguments to filter Timetables to delete.
     * @example
     * // Delete a few Timetables
     * const { count } = await prisma.timetable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimetableDeleteManyArgs>(args?: SelectSubset<T, TimetableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timetables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Timetables
     * const timetable = await prisma.timetable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimetableUpdateManyArgs>(args: SelectSubset<T, TimetableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Timetable.
     * @param {TimetableUpsertArgs} args - Arguments to update or create a Timetable.
     * @example
     * // Update or create a Timetable
     * const timetable = await prisma.timetable.upsert({
     *   create: {
     *     // ... data to create a Timetable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Timetable we want to update
     *   }
     * })
     */
    upsert<T extends TimetableUpsertArgs>(args: SelectSubset<T, TimetableUpsertArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Timetables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableCountArgs} args - Arguments to filter Timetables to count.
     * @example
     * // Count the number of Timetables
     * const count = await prisma.timetable.count({
     *   where: {
     *     // ... the filter for the Timetables we want to count
     *   }
     * })
    **/
    count<T extends TimetableCountArgs>(
      args?: Subset<T, TimetableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimetableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Timetable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimetableAggregateArgs>(args: Subset<T, TimetableAggregateArgs>): Prisma.PrismaPromise<GetTimetableAggregateType<T>>

    /**
     * Group by Timetable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimetableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimetableGroupByArgs['orderBy'] }
        : { orderBy?: TimetableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimetableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimetableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Timetable model
   */
  readonly fields: TimetableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Timetable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimetableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teacher<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends Timetable$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Timetable$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    module<T extends Timetable$moduleArgs<ExtArgs> = {}>(args?: Subset<T, Timetable$moduleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    timeSlot<T extends TimeSlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimeSlotDefaultArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Timetable model
   */ 
  interface TimetableFieldRefs {
    readonly id: FieldRef<"Timetable", 'String'>
    readonly schoolId: FieldRef<"Timetable", 'String'>
    readonly classId: FieldRef<"Timetable", 'String'>
    readonly teacherId: FieldRef<"Timetable", 'String'>
    readonly subjectId: FieldRef<"Timetable", 'String'>
    readonly moduleId: FieldRef<"Timetable", 'String'>
    readonly timeSlotId: FieldRef<"Timetable", 'String'>
    readonly createdAt: FieldRef<"Timetable", 'DateTime'>
    readonly updatedAt: FieldRef<"Timetable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Timetable findUnique
   */
  export type TimetableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable findUniqueOrThrow
   */
  export type TimetableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable findFirst
   */
  export type TimetableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timetables.
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timetables.
     */
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Timetable findFirstOrThrow
   */
  export type TimetableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timetables.
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timetables.
     */
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Timetable findMany
   */
  export type TimetableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetables to fetch.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Timetables.
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Timetable create
   */
  export type TimetableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * The data needed to create a Timetable.
     */
    data: XOR<TimetableCreateInput, TimetableUncheckedCreateInput>
  }

  /**
   * Timetable createMany
   */
  export type TimetableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Timetables.
     */
    data: TimetableCreateManyInput | TimetableCreateManyInput[]
  }

  /**
   * Timetable createManyAndReturn
   */
  export type TimetableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Timetables.
     */
    data: TimetableCreateManyInput | TimetableCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Timetable update
   */
  export type TimetableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * The data needed to update a Timetable.
     */
    data: XOR<TimetableUpdateInput, TimetableUncheckedUpdateInput>
    /**
     * Choose, which Timetable to update.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable updateMany
   */
  export type TimetableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Timetables.
     */
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyInput>
    /**
     * Filter which Timetables to update
     */
    where?: TimetableWhereInput
  }

  /**
   * Timetable upsert
   */
  export type TimetableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * The filter to search for the Timetable to update in case it exists.
     */
    where: TimetableWhereUniqueInput
    /**
     * In case the Timetable found by the `where` argument doesn't exist, create a new Timetable with this data.
     */
    create: XOR<TimetableCreateInput, TimetableUncheckedCreateInput>
    /**
     * In case the Timetable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimetableUpdateInput, TimetableUncheckedUpdateInput>
  }

  /**
   * Timetable delete
   */
  export type TimetableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter which Timetable to delete.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable deleteMany
   */
  export type TimetableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timetables to delete
     */
    where?: TimetableWhereInput
  }

  /**
   * Timetable.subject
   */
  export type Timetable$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Timetable.module
   */
  export type Timetable$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * Timetable without action
   */
  export type TimetableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
  }


  /**
   * Model TeacherClassSubject
   */

  export type AggregateTeacherClassSubject = {
    _count: TeacherClassSubjectCountAggregateOutputType | null
    _min: TeacherClassSubjectMinAggregateOutputType | null
    _max: TeacherClassSubjectMaxAggregateOutputType | null
  }

  export type TeacherClassSubjectMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    classId: string | null
    subjectId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherClassSubjectMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    classId: string | null
    subjectId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherClassSubjectCountAggregateOutputType = {
    id: number
    teacherId: number
    classId: number
    subjectId: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherClassSubjectMinAggregateInputType = {
    id?: true
    teacherId?: true
    classId?: true
    subjectId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherClassSubjectMaxAggregateInputType = {
    id?: true
    teacherId?: true
    classId?: true
    subjectId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherClassSubjectCountAggregateInputType = {
    id?: true
    teacherId?: true
    classId?: true
    subjectId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherClassSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherClassSubject to aggregate.
     */
    where?: TeacherClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClassSubjects to fetch.
     */
    orderBy?: TeacherClassSubjectOrderByWithRelationInput | TeacherClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherClassSubjects
    **/
    _count?: true | TeacherClassSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherClassSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherClassSubjectMaxAggregateInputType
  }

  export type GetTeacherClassSubjectAggregateType<T extends TeacherClassSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherClassSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherClassSubject[P]>
      : GetScalarType<T[P], AggregateTeacherClassSubject[P]>
  }




  export type TeacherClassSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherClassSubjectWhereInput
    orderBy?: TeacherClassSubjectOrderByWithAggregationInput | TeacherClassSubjectOrderByWithAggregationInput[]
    by: TeacherClassSubjectScalarFieldEnum[] | TeacherClassSubjectScalarFieldEnum
    having?: TeacherClassSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherClassSubjectCountAggregateInputType | true
    _min?: TeacherClassSubjectMinAggregateInputType
    _max?: TeacherClassSubjectMaxAggregateInputType
  }

  export type TeacherClassSubjectGroupByOutputType = {
    id: string
    teacherId: string
    classId: string
    subjectId: string
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: TeacherClassSubjectCountAggregateOutputType | null
    _min: TeacherClassSubjectMinAggregateOutputType | null
    _max: TeacherClassSubjectMaxAggregateOutputType | null
  }

  type GetTeacherClassSubjectGroupByPayload<T extends TeacherClassSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherClassSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherClassSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherClassSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherClassSubjectGroupByOutputType[P]>
        }
      >
    >


  export type TeacherClassSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    classId?: boolean
    subjectId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherClassSubject"]>

  export type TeacherClassSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    classId?: boolean
    subjectId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherClassSubject"]>

  export type TeacherClassSubjectSelectScalar = {
    id?: boolean
    teacherId?: boolean
    classId?: boolean
    subjectId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeacherClassSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type TeacherClassSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $TeacherClassSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherClassSubject"
    objects: {
      teacher: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      classId: string
      subjectId: string
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teacherClassSubject"]>
    composites: {}
  }

  type TeacherClassSubjectGetPayload<S extends boolean | null | undefined | TeacherClassSubjectDefaultArgs> = $Result.GetResult<Prisma.$TeacherClassSubjectPayload, S>

  type TeacherClassSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherClassSubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherClassSubjectCountAggregateInputType | true
    }

  export interface TeacherClassSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherClassSubject'], meta: { name: 'TeacherClassSubject' } }
    /**
     * Find zero or one TeacherClassSubject that matches the filter.
     * @param {TeacherClassSubjectFindUniqueArgs} args - Arguments to find a TeacherClassSubject
     * @example
     * // Get one TeacherClassSubject
     * const teacherClassSubject = await prisma.teacherClassSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherClassSubjectFindUniqueArgs>(args: SelectSubset<T, TeacherClassSubjectFindUniqueArgs<ExtArgs>>): Prisma__TeacherClassSubjectClient<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeacherClassSubject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherClassSubjectFindUniqueOrThrowArgs} args - Arguments to find a TeacherClassSubject
     * @example
     * // Get one TeacherClassSubject
     * const teacherClassSubject = await prisma.teacherClassSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherClassSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherClassSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClassSubjectClient<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeacherClassSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassSubjectFindFirstArgs} args - Arguments to find a TeacherClassSubject
     * @example
     * // Get one TeacherClassSubject
     * const teacherClassSubject = await prisma.teacherClassSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherClassSubjectFindFirstArgs>(args?: SelectSubset<T, TeacherClassSubjectFindFirstArgs<ExtArgs>>): Prisma__TeacherClassSubjectClient<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeacherClassSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassSubjectFindFirstOrThrowArgs} args - Arguments to find a TeacherClassSubject
     * @example
     * // Get one TeacherClassSubject
     * const teacherClassSubject = await prisma.teacherClassSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherClassSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherClassSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClassSubjectClient<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeacherClassSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherClassSubjects
     * const teacherClassSubjects = await prisma.teacherClassSubject.findMany()
     * 
     * // Get first 10 TeacherClassSubjects
     * const teacherClassSubjects = await prisma.teacherClassSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherClassSubjectWithIdOnly = await prisma.teacherClassSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherClassSubjectFindManyArgs>(args?: SelectSubset<T, TeacherClassSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeacherClassSubject.
     * @param {TeacherClassSubjectCreateArgs} args - Arguments to create a TeacherClassSubject.
     * @example
     * // Create one TeacherClassSubject
     * const TeacherClassSubject = await prisma.teacherClassSubject.create({
     *   data: {
     *     // ... data to create a TeacherClassSubject
     *   }
     * })
     * 
     */
    create<T extends TeacherClassSubjectCreateArgs>(args: SelectSubset<T, TeacherClassSubjectCreateArgs<ExtArgs>>): Prisma__TeacherClassSubjectClient<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeacherClassSubjects.
     * @param {TeacherClassSubjectCreateManyArgs} args - Arguments to create many TeacherClassSubjects.
     * @example
     * // Create many TeacherClassSubjects
     * const teacherClassSubject = await prisma.teacherClassSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherClassSubjectCreateManyArgs>(args?: SelectSubset<T, TeacherClassSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherClassSubjects and returns the data saved in the database.
     * @param {TeacherClassSubjectCreateManyAndReturnArgs} args - Arguments to create many TeacherClassSubjects.
     * @example
     * // Create many TeacherClassSubjects
     * const teacherClassSubject = await prisma.teacherClassSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherClassSubjects and only return the `id`
     * const teacherClassSubjectWithIdOnly = await prisma.teacherClassSubject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherClassSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherClassSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeacherClassSubject.
     * @param {TeacherClassSubjectDeleteArgs} args - Arguments to delete one TeacherClassSubject.
     * @example
     * // Delete one TeacherClassSubject
     * const TeacherClassSubject = await prisma.teacherClassSubject.delete({
     *   where: {
     *     // ... filter to delete one TeacherClassSubject
     *   }
     * })
     * 
     */
    delete<T extends TeacherClassSubjectDeleteArgs>(args: SelectSubset<T, TeacherClassSubjectDeleteArgs<ExtArgs>>): Prisma__TeacherClassSubjectClient<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeacherClassSubject.
     * @param {TeacherClassSubjectUpdateArgs} args - Arguments to update one TeacherClassSubject.
     * @example
     * // Update one TeacherClassSubject
     * const teacherClassSubject = await prisma.teacherClassSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherClassSubjectUpdateArgs>(args: SelectSubset<T, TeacherClassSubjectUpdateArgs<ExtArgs>>): Prisma__TeacherClassSubjectClient<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeacherClassSubjects.
     * @param {TeacherClassSubjectDeleteManyArgs} args - Arguments to filter TeacherClassSubjects to delete.
     * @example
     * // Delete a few TeacherClassSubjects
     * const { count } = await prisma.teacherClassSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherClassSubjectDeleteManyArgs>(args?: SelectSubset<T, TeacherClassSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherClassSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherClassSubjects
     * const teacherClassSubject = await prisma.teacherClassSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherClassSubjectUpdateManyArgs>(args: SelectSubset<T, TeacherClassSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherClassSubject.
     * @param {TeacherClassSubjectUpsertArgs} args - Arguments to update or create a TeacherClassSubject.
     * @example
     * // Update or create a TeacherClassSubject
     * const teacherClassSubject = await prisma.teacherClassSubject.upsert({
     *   create: {
     *     // ... data to create a TeacherClassSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherClassSubject we want to update
     *   }
     * })
     */
    upsert<T extends TeacherClassSubjectUpsertArgs>(args: SelectSubset<T, TeacherClassSubjectUpsertArgs<ExtArgs>>): Prisma__TeacherClassSubjectClient<$Result.GetResult<Prisma.$TeacherClassSubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeacherClassSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassSubjectCountArgs} args - Arguments to filter TeacherClassSubjects to count.
     * @example
     * // Count the number of TeacherClassSubjects
     * const count = await prisma.teacherClassSubject.count({
     *   where: {
     *     // ... the filter for the TeacherClassSubjects we want to count
     *   }
     * })
    **/
    count<T extends TeacherClassSubjectCountArgs>(
      args?: Subset<T, TeacherClassSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherClassSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherClassSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherClassSubjectAggregateArgs>(args: Subset<T, TeacherClassSubjectAggregateArgs>): Prisma.PrismaPromise<GetTeacherClassSubjectAggregateType<T>>

    /**
     * Group by TeacherClassSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherClassSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherClassSubjectGroupByArgs['orderBy'] }
        : { orderBy?: TeacherClassSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherClassSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherClassSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherClassSubject model
   */
  readonly fields: TeacherClassSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherClassSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClassSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherClassSubject model
   */ 
  interface TeacherClassSubjectFieldRefs {
    readonly id: FieldRef<"TeacherClassSubject", 'String'>
    readonly teacherId: FieldRef<"TeacherClassSubject", 'String'>
    readonly classId: FieldRef<"TeacherClassSubject", 'String'>
    readonly subjectId: FieldRef<"TeacherClassSubject", 'String'>
    readonly schoolId: FieldRef<"TeacherClassSubject", 'String'>
    readonly createdAt: FieldRef<"TeacherClassSubject", 'DateTime'>
    readonly updatedAt: FieldRef<"TeacherClassSubject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeacherClassSubject findUnique
   */
  export type TeacherClassSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClassSubject to fetch.
     */
    where: TeacherClassSubjectWhereUniqueInput
  }

  /**
   * TeacherClassSubject findUniqueOrThrow
   */
  export type TeacherClassSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClassSubject to fetch.
     */
    where: TeacherClassSubjectWhereUniqueInput
  }

  /**
   * TeacherClassSubject findFirst
   */
  export type TeacherClassSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClassSubject to fetch.
     */
    where?: TeacherClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClassSubjects to fetch.
     */
    orderBy?: TeacherClassSubjectOrderByWithRelationInput | TeacherClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherClassSubjects.
     */
    cursor?: TeacherClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherClassSubjects.
     */
    distinct?: TeacherClassSubjectScalarFieldEnum | TeacherClassSubjectScalarFieldEnum[]
  }

  /**
   * TeacherClassSubject findFirstOrThrow
   */
  export type TeacherClassSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClassSubject to fetch.
     */
    where?: TeacherClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClassSubjects to fetch.
     */
    orderBy?: TeacherClassSubjectOrderByWithRelationInput | TeacherClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherClassSubjects.
     */
    cursor?: TeacherClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherClassSubjects.
     */
    distinct?: TeacherClassSubjectScalarFieldEnum | TeacherClassSubjectScalarFieldEnum[]
  }

  /**
   * TeacherClassSubject findMany
   */
  export type TeacherClassSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClassSubjects to fetch.
     */
    where?: TeacherClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClassSubjects to fetch.
     */
    orderBy?: TeacherClassSubjectOrderByWithRelationInput | TeacherClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherClassSubjects.
     */
    cursor?: TeacherClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClassSubjects.
     */
    skip?: number
    distinct?: TeacherClassSubjectScalarFieldEnum | TeacherClassSubjectScalarFieldEnum[]
  }

  /**
   * TeacherClassSubject create
   */
  export type TeacherClassSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherClassSubject.
     */
    data: XOR<TeacherClassSubjectCreateInput, TeacherClassSubjectUncheckedCreateInput>
  }

  /**
   * TeacherClassSubject createMany
   */
  export type TeacherClassSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherClassSubjects.
     */
    data: TeacherClassSubjectCreateManyInput | TeacherClassSubjectCreateManyInput[]
  }

  /**
   * TeacherClassSubject createManyAndReturn
   */
  export type TeacherClassSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeacherClassSubjects.
     */
    data: TeacherClassSubjectCreateManyInput | TeacherClassSubjectCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherClassSubject update
   */
  export type TeacherClassSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherClassSubject.
     */
    data: XOR<TeacherClassSubjectUpdateInput, TeacherClassSubjectUncheckedUpdateInput>
    /**
     * Choose, which TeacherClassSubject to update.
     */
    where: TeacherClassSubjectWhereUniqueInput
  }

  /**
   * TeacherClassSubject updateMany
   */
  export type TeacherClassSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherClassSubjects.
     */
    data: XOR<TeacherClassSubjectUpdateManyMutationInput, TeacherClassSubjectUncheckedUpdateManyInput>
    /**
     * Filter which TeacherClassSubjects to update
     */
    where?: TeacherClassSubjectWhereInput
  }

  /**
   * TeacherClassSubject upsert
   */
  export type TeacherClassSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherClassSubject to update in case it exists.
     */
    where: TeacherClassSubjectWhereUniqueInput
    /**
     * In case the TeacherClassSubject found by the `where` argument doesn't exist, create a new TeacherClassSubject with this data.
     */
    create: XOR<TeacherClassSubjectCreateInput, TeacherClassSubjectUncheckedCreateInput>
    /**
     * In case the TeacherClassSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherClassSubjectUpdateInput, TeacherClassSubjectUncheckedUpdateInput>
  }

  /**
   * TeacherClassSubject delete
   */
  export type TeacherClassSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
    /**
     * Filter which TeacherClassSubject to delete.
     */
    where: TeacherClassSubjectWhereUniqueInput
  }

  /**
   * TeacherClassSubject deleteMany
   */
  export type TeacherClassSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherClassSubjects to delete
     */
    where?: TeacherClassSubjectWhereInput
  }

  /**
   * TeacherClassSubject without action
   */
  export type TeacherClassSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClassSubject
     */
    select?: TeacherClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassSubjectInclude<ExtArgs> | null
  }


  /**
   * Model TrainerClassModule
   */

  export type AggregateTrainerClassModule = {
    _count: TrainerClassModuleCountAggregateOutputType | null
    _min: TrainerClassModuleMinAggregateOutputType | null
    _max: TrainerClassModuleMaxAggregateOutputType | null
  }

  export type TrainerClassModuleMinAggregateOutputType = {
    id: string | null
    trainerId: string | null
    classId: string | null
    moduleId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainerClassModuleMaxAggregateOutputType = {
    id: string | null
    trainerId: string | null
    classId: string | null
    moduleId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainerClassModuleCountAggregateOutputType = {
    id: number
    trainerId: number
    classId: number
    moduleId: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainerClassModuleMinAggregateInputType = {
    id?: true
    trainerId?: true
    classId?: true
    moduleId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainerClassModuleMaxAggregateInputType = {
    id?: true
    trainerId?: true
    classId?: true
    moduleId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainerClassModuleCountAggregateInputType = {
    id?: true
    trainerId?: true
    classId?: true
    moduleId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainerClassModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainerClassModule to aggregate.
     */
    where?: TrainerClassModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainerClassModules to fetch.
     */
    orderBy?: TrainerClassModuleOrderByWithRelationInput | TrainerClassModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainerClassModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainerClassModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainerClassModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainerClassModules
    **/
    _count?: true | TrainerClassModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainerClassModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainerClassModuleMaxAggregateInputType
  }

  export type GetTrainerClassModuleAggregateType<T extends TrainerClassModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainerClassModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainerClassModule[P]>
      : GetScalarType<T[P], AggregateTrainerClassModule[P]>
  }




  export type TrainerClassModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainerClassModuleWhereInput
    orderBy?: TrainerClassModuleOrderByWithAggregationInput | TrainerClassModuleOrderByWithAggregationInput[]
    by: TrainerClassModuleScalarFieldEnum[] | TrainerClassModuleScalarFieldEnum
    having?: TrainerClassModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainerClassModuleCountAggregateInputType | true
    _min?: TrainerClassModuleMinAggregateInputType
    _max?: TrainerClassModuleMaxAggregateInputType
  }

  export type TrainerClassModuleGroupByOutputType = {
    id: string
    trainerId: string
    classId: string
    moduleId: string
    schoolId: string
    createdAt: Date
    updatedAt: Date
    _count: TrainerClassModuleCountAggregateOutputType | null
    _min: TrainerClassModuleMinAggregateOutputType | null
    _max: TrainerClassModuleMaxAggregateOutputType | null
  }

  type GetTrainerClassModuleGroupByPayload<T extends TrainerClassModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainerClassModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainerClassModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainerClassModuleGroupByOutputType[P]>
            : GetScalarType<T[P], TrainerClassModuleGroupByOutputType[P]>
        }
      >
    >


  export type TrainerClassModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainerId?: boolean
    classId?: boolean
    moduleId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainerClassModule"]>

  export type TrainerClassModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainerId?: boolean
    classId?: boolean
    moduleId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainerClassModule"]>

  export type TrainerClassModuleSelectScalar = {
    id?: boolean
    trainerId?: boolean
    classId?: boolean
    moduleId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainerClassModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type TrainerClassModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $TrainerClassModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainerClassModule"
    objects: {
      trainer: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      module: Prisma.$ModulePayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainerId: string
      classId: string
      moduleId: string
      schoolId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainerClassModule"]>
    composites: {}
  }

  type TrainerClassModuleGetPayload<S extends boolean | null | undefined | TrainerClassModuleDefaultArgs> = $Result.GetResult<Prisma.$TrainerClassModulePayload, S>

  type TrainerClassModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainerClassModuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainerClassModuleCountAggregateInputType | true
    }

  export interface TrainerClassModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainerClassModule'], meta: { name: 'TrainerClassModule' } }
    /**
     * Find zero or one TrainerClassModule that matches the filter.
     * @param {TrainerClassModuleFindUniqueArgs} args - Arguments to find a TrainerClassModule
     * @example
     * // Get one TrainerClassModule
     * const trainerClassModule = await prisma.trainerClassModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainerClassModuleFindUniqueArgs>(args: SelectSubset<T, TrainerClassModuleFindUniqueArgs<ExtArgs>>): Prisma__TrainerClassModuleClient<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainerClassModule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainerClassModuleFindUniqueOrThrowArgs} args - Arguments to find a TrainerClassModule
     * @example
     * // Get one TrainerClassModule
     * const trainerClassModule = await prisma.trainerClassModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainerClassModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainerClassModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainerClassModuleClient<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainerClassModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerClassModuleFindFirstArgs} args - Arguments to find a TrainerClassModule
     * @example
     * // Get one TrainerClassModule
     * const trainerClassModule = await prisma.trainerClassModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainerClassModuleFindFirstArgs>(args?: SelectSubset<T, TrainerClassModuleFindFirstArgs<ExtArgs>>): Prisma__TrainerClassModuleClient<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainerClassModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerClassModuleFindFirstOrThrowArgs} args - Arguments to find a TrainerClassModule
     * @example
     * // Get one TrainerClassModule
     * const trainerClassModule = await prisma.trainerClassModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainerClassModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainerClassModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainerClassModuleClient<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainerClassModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerClassModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainerClassModules
     * const trainerClassModules = await prisma.trainerClassModule.findMany()
     * 
     * // Get first 10 TrainerClassModules
     * const trainerClassModules = await prisma.trainerClassModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainerClassModuleWithIdOnly = await prisma.trainerClassModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainerClassModuleFindManyArgs>(args?: SelectSubset<T, TrainerClassModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainerClassModule.
     * @param {TrainerClassModuleCreateArgs} args - Arguments to create a TrainerClassModule.
     * @example
     * // Create one TrainerClassModule
     * const TrainerClassModule = await prisma.trainerClassModule.create({
     *   data: {
     *     // ... data to create a TrainerClassModule
     *   }
     * })
     * 
     */
    create<T extends TrainerClassModuleCreateArgs>(args: SelectSubset<T, TrainerClassModuleCreateArgs<ExtArgs>>): Prisma__TrainerClassModuleClient<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainerClassModules.
     * @param {TrainerClassModuleCreateManyArgs} args - Arguments to create many TrainerClassModules.
     * @example
     * // Create many TrainerClassModules
     * const trainerClassModule = await prisma.trainerClassModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainerClassModuleCreateManyArgs>(args?: SelectSubset<T, TrainerClassModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainerClassModules and returns the data saved in the database.
     * @param {TrainerClassModuleCreateManyAndReturnArgs} args - Arguments to create many TrainerClassModules.
     * @example
     * // Create many TrainerClassModules
     * const trainerClassModule = await prisma.trainerClassModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainerClassModules and only return the `id`
     * const trainerClassModuleWithIdOnly = await prisma.trainerClassModule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainerClassModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainerClassModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainerClassModule.
     * @param {TrainerClassModuleDeleteArgs} args - Arguments to delete one TrainerClassModule.
     * @example
     * // Delete one TrainerClassModule
     * const TrainerClassModule = await prisma.trainerClassModule.delete({
     *   where: {
     *     // ... filter to delete one TrainerClassModule
     *   }
     * })
     * 
     */
    delete<T extends TrainerClassModuleDeleteArgs>(args: SelectSubset<T, TrainerClassModuleDeleteArgs<ExtArgs>>): Prisma__TrainerClassModuleClient<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainerClassModule.
     * @param {TrainerClassModuleUpdateArgs} args - Arguments to update one TrainerClassModule.
     * @example
     * // Update one TrainerClassModule
     * const trainerClassModule = await prisma.trainerClassModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainerClassModuleUpdateArgs>(args: SelectSubset<T, TrainerClassModuleUpdateArgs<ExtArgs>>): Prisma__TrainerClassModuleClient<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainerClassModules.
     * @param {TrainerClassModuleDeleteManyArgs} args - Arguments to filter TrainerClassModules to delete.
     * @example
     * // Delete a few TrainerClassModules
     * const { count } = await prisma.trainerClassModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainerClassModuleDeleteManyArgs>(args?: SelectSubset<T, TrainerClassModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainerClassModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerClassModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainerClassModules
     * const trainerClassModule = await prisma.trainerClassModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainerClassModuleUpdateManyArgs>(args: SelectSubset<T, TrainerClassModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainerClassModule.
     * @param {TrainerClassModuleUpsertArgs} args - Arguments to update or create a TrainerClassModule.
     * @example
     * // Update or create a TrainerClassModule
     * const trainerClassModule = await prisma.trainerClassModule.upsert({
     *   create: {
     *     // ... data to create a TrainerClassModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainerClassModule we want to update
     *   }
     * })
     */
    upsert<T extends TrainerClassModuleUpsertArgs>(args: SelectSubset<T, TrainerClassModuleUpsertArgs<ExtArgs>>): Prisma__TrainerClassModuleClient<$Result.GetResult<Prisma.$TrainerClassModulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainerClassModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerClassModuleCountArgs} args - Arguments to filter TrainerClassModules to count.
     * @example
     * // Count the number of TrainerClassModules
     * const count = await prisma.trainerClassModule.count({
     *   where: {
     *     // ... the filter for the TrainerClassModules we want to count
     *   }
     * })
    **/
    count<T extends TrainerClassModuleCountArgs>(
      args?: Subset<T, TrainerClassModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainerClassModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainerClassModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerClassModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainerClassModuleAggregateArgs>(args: Subset<T, TrainerClassModuleAggregateArgs>): Prisma.PrismaPromise<GetTrainerClassModuleAggregateType<T>>

    /**
     * Group by TrainerClassModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainerClassModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainerClassModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainerClassModuleGroupByArgs['orderBy'] }
        : { orderBy?: TrainerClassModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainerClassModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainerClassModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainerClassModule model
   */
  readonly fields: TrainerClassModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainerClassModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainerClassModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainerClassModule model
   */ 
  interface TrainerClassModuleFieldRefs {
    readonly id: FieldRef<"TrainerClassModule", 'String'>
    readonly trainerId: FieldRef<"TrainerClassModule", 'String'>
    readonly classId: FieldRef<"TrainerClassModule", 'String'>
    readonly moduleId: FieldRef<"TrainerClassModule", 'String'>
    readonly schoolId: FieldRef<"TrainerClassModule", 'String'>
    readonly createdAt: FieldRef<"TrainerClassModule", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainerClassModule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainerClassModule findUnique
   */
  export type TrainerClassModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainerClassModule to fetch.
     */
    where: TrainerClassModuleWhereUniqueInput
  }

  /**
   * TrainerClassModule findUniqueOrThrow
   */
  export type TrainerClassModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainerClassModule to fetch.
     */
    where: TrainerClassModuleWhereUniqueInput
  }

  /**
   * TrainerClassModule findFirst
   */
  export type TrainerClassModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainerClassModule to fetch.
     */
    where?: TrainerClassModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainerClassModules to fetch.
     */
    orderBy?: TrainerClassModuleOrderByWithRelationInput | TrainerClassModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainerClassModules.
     */
    cursor?: TrainerClassModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainerClassModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainerClassModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainerClassModules.
     */
    distinct?: TrainerClassModuleScalarFieldEnum | TrainerClassModuleScalarFieldEnum[]
  }

  /**
   * TrainerClassModule findFirstOrThrow
   */
  export type TrainerClassModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainerClassModule to fetch.
     */
    where?: TrainerClassModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainerClassModules to fetch.
     */
    orderBy?: TrainerClassModuleOrderByWithRelationInput | TrainerClassModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainerClassModules.
     */
    cursor?: TrainerClassModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainerClassModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainerClassModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainerClassModules.
     */
    distinct?: TrainerClassModuleScalarFieldEnum | TrainerClassModuleScalarFieldEnum[]
  }

  /**
   * TrainerClassModule findMany
   */
  export type TrainerClassModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainerClassModules to fetch.
     */
    where?: TrainerClassModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainerClassModules to fetch.
     */
    orderBy?: TrainerClassModuleOrderByWithRelationInput | TrainerClassModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainerClassModules.
     */
    cursor?: TrainerClassModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainerClassModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainerClassModules.
     */
    skip?: number
    distinct?: TrainerClassModuleScalarFieldEnum | TrainerClassModuleScalarFieldEnum[]
  }

  /**
   * TrainerClassModule create
   */
  export type TrainerClassModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainerClassModule.
     */
    data: XOR<TrainerClassModuleCreateInput, TrainerClassModuleUncheckedCreateInput>
  }

  /**
   * TrainerClassModule createMany
   */
  export type TrainerClassModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainerClassModules.
     */
    data: TrainerClassModuleCreateManyInput | TrainerClassModuleCreateManyInput[]
  }

  /**
   * TrainerClassModule createManyAndReturn
   */
  export type TrainerClassModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainerClassModules.
     */
    data: TrainerClassModuleCreateManyInput | TrainerClassModuleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainerClassModule update
   */
  export type TrainerClassModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainerClassModule.
     */
    data: XOR<TrainerClassModuleUpdateInput, TrainerClassModuleUncheckedUpdateInput>
    /**
     * Choose, which TrainerClassModule to update.
     */
    where: TrainerClassModuleWhereUniqueInput
  }

  /**
   * TrainerClassModule updateMany
   */
  export type TrainerClassModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainerClassModules.
     */
    data: XOR<TrainerClassModuleUpdateManyMutationInput, TrainerClassModuleUncheckedUpdateManyInput>
    /**
     * Filter which TrainerClassModules to update
     */
    where?: TrainerClassModuleWhereInput
  }

  /**
   * TrainerClassModule upsert
   */
  export type TrainerClassModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainerClassModule to update in case it exists.
     */
    where: TrainerClassModuleWhereUniqueInput
    /**
     * In case the TrainerClassModule found by the `where` argument doesn't exist, create a new TrainerClassModule with this data.
     */
    create: XOR<TrainerClassModuleCreateInput, TrainerClassModuleUncheckedCreateInput>
    /**
     * In case the TrainerClassModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainerClassModuleUpdateInput, TrainerClassModuleUncheckedUpdateInput>
  }

  /**
   * TrainerClassModule delete
   */
  export type TrainerClassModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
    /**
     * Filter which TrainerClassModule to delete.
     */
    where: TrainerClassModuleWhereUniqueInput
  }

  /**
   * TrainerClassModule deleteMany
   */
  export type TrainerClassModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainerClassModules to delete
     */
    where?: TrainerClassModuleWhereInput
  }

  /**
   * TrainerClassModule without action
   */
  export type TrainerClassModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainerClassModule
     */
    select?: TrainerClassModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainerClassModuleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    schoolId: 'schoolId',
    isActive: 'isActive',
    maxWeeklyHours: 'maxWeeklyHours',
    teachingStreams: 'teachingStreams',
    unavailableDays: 'unavailableDays',
    unavailablePeriods: 'unavailablePeriods',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    address: 'address',
    province: 'province',
    district: 'district',
    sector: 'sector',
    email: 'email',
    phone: 'phone',
    status: 'status',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    stream: 'stream',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    level: 'level',
    periodsPerWeek: 'periodsPerWeek',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    level: 'level',
    trade: 'trade',
    totalHours: 'totalHours',
    category: 'category',
    blockSize: 'blockSize',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const TeacherSubjectScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    subjectId: 'subjectId'
  };

  export type TeacherSubjectScalarFieldEnum = (typeof TeacherSubjectScalarFieldEnum)[keyof typeof TeacherSubjectScalarFieldEnum]


  export const TrainerModuleScalarFieldEnum: {
    id: 'id',
    trainerId: 'trainerId',
    moduleId: 'moduleId'
  };

  export type TrainerModuleScalarFieldEnum = (typeof TrainerModuleScalarFieldEnum)[keyof typeof TrainerModuleScalarFieldEnum]


  export const ClassSubjectScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    subjectId: 'subjectId'
  };

  export type ClassSubjectScalarFieldEnum = (typeof ClassSubjectScalarFieldEnum)[keyof typeof ClassSubjectScalarFieldEnum]


  export const TimeSlotScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    day: 'day',
    period: 'period',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    session: 'session',
    isBreak: 'isBreak',
    breakType: 'breakType',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimeSlotScalarFieldEnum = (typeof TimeSlotScalarFieldEnum)[keyof typeof TimeSlotScalarFieldEnum]


  export const TimetableScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    classId: 'classId',
    teacherId: 'teacherId',
    subjectId: 'subjectId',
    moduleId: 'moduleId',
    timeSlotId: 'timeSlotId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimetableScalarFieldEnum = (typeof TimetableScalarFieldEnum)[keyof typeof TimetableScalarFieldEnum]


  export const TeacherClassSubjectScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    classId: 'classId',
    subjectId: 'subjectId',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherClassSubjectScalarFieldEnum = (typeof TeacherClassSubjectScalarFieldEnum)[keyof typeof TeacherClassSubjectScalarFieldEnum]


  export const TrainerClassModuleScalarFieldEnum: {
    id: 'id',
    trainerId: 'trainerId',
    classId: 'classId',
    moduleId: 'moduleId',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainerClassModuleScalarFieldEnum = (typeof TrainerClassModuleScalarFieldEnum)[keyof typeof TrainerClassModuleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    schoolId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    maxWeeklyHours?: IntNullableFilter<"User"> | number | null
    teachingStreams?: StringNullableFilter<"User"> | string | null
    unavailableDays?: StringNullableFilter<"User"> | string | null
    unavailablePeriods?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    school?: XOR<SchoolNullableRelationFilter, SchoolWhereInput> | null
    teacherSubjects?: TeacherSubjectListRelationFilter
    trainerModules?: TrainerModuleListRelationFilter
    teacherClassSubjects?: TeacherClassSubjectListRelationFilter
    trainerClassModules?: TrainerClassModuleListRelationFilter
    timetablesAsTeacher?: TimetableListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    maxWeeklyHours?: SortOrderInput | SortOrder
    teachingStreams?: SortOrderInput | SortOrder
    unavailableDays?: SortOrderInput | SortOrder
    unavailablePeriods?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    teacherSubjects?: TeacherSubjectOrderByRelationAggregateInput
    trainerModules?: TrainerModuleOrderByRelationAggregateInput
    teacherClassSubjects?: TeacherClassSubjectOrderByRelationAggregateInput
    trainerClassModules?: TrainerClassModuleOrderByRelationAggregateInput
    timetablesAsTeacher?: TimetableOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    schoolId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    maxWeeklyHours?: IntNullableFilter<"User"> | number | null
    teachingStreams?: StringNullableFilter<"User"> | string | null
    unavailableDays?: StringNullableFilter<"User"> | string | null
    unavailablePeriods?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    school?: XOR<SchoolNullableRelationFilter, SchoolWhereInput> | null
    teacherSubjects?: TeacherSubjectListRelationFilter
    trainerModules?: TrainerModuleListRelationFilter
    teacherClassSubjects?: TeacherClassSubjectListRelationFilter
    trainerClassModules?: TrainerClassModuleListRelationFilter
    timetablesAsTeacher?: TimetableListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    maxWeeklyHours?: SortOrderInput | SortOrder
    teachingStreams?: SortOrderInput | SortOrder
    unavailableDays?: SortOrderInput | SortOrder
    unavailablePeriods?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    schoolId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    maxWeeklyHours?: IntNullableWithAggregatesFilter<"User"> | number | null
    teachingStreams?: StringNullableWithAggregatesFilter<"User"> | string | null
    unavailableDays?: StringNullableWithAggregatesFilter<"User"> | string | null
    unavailablePeriods?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    type?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    province?: StringNullableFilter<"School"> | string | null
    district?: StringNullableFilter<"School"> | string | null
    sector?: StringNullableFilter<"School"> | string | null
    email?: StringFilter<"School"> | string
    phone?: StringNullableFilter<"School"> | string | null
    status?: StringFilter<"School"> | string
    approvedAt?: DateTimeNullableFilter<"School"> | Date | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
    classes?: ClassListRelationFilter
    subjects?: SubjectListRelationFilter
    modules?: ModuleListRelationFilter
    timeSlots?: TimeSlotListRelationFilter
    timetables?: TimetableListRelationFilter
    teacherClassSubjects?: TeacherClassSubjectListRelationFilter
    trainerClassModules?: TrainerClassModuleListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    modules?: ModuleOrderByRelationAggregateInput
    timeSlots?: TimeSlotOrderByRelationAggregateInput
    timetables?: TimetableOrderByRelationAggregateInput
    teacherClassSubjects?: TeacherClassSubjectOrderByRelationAggregateInput
    trainerClassModules?: TrainerClassModuleOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    name?: StringFilter<"School"> | string
    type?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    province?: StringNullableFilter<"School"> | string | null
    district?: StringNullableFilter<"School"> | string | null
    sector?: StringNullableFilter<"School"> | string | null
    phone?: StringNullableFilter<"School"> | string | null
    status?: StringFilter<"School"> | string
    approvedAt?: DateTimeNullableFilter<"School"> | Date | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    users?: UserListRelationFilter
    classes?: ClassListRelationFilter
    subjects?: SubjectListRelationFilter
    modules?: ModuleListRelationFilter
    timeSlots?: TimeSlotListRelationFilter
    timetables?: TimetableListRelationFilter
    teacherClassSubjects?: TeacherClassSubjectListRelationFilter
    trainerClassModules?: TrainerClassModuleListRelationFilter
  }, "id" | "email">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    type?: StringWithAggregatesFilter<"School"> | string
    address?: StringNullableWithAggregatesFilter<"School"> | string | null
    province?: StringNullableWithAggregatesFilter<"School"> | string | null
    district?: StringNullableWithAggregatesFilter<"School"> | string | null
    sector?: StringNullableWithAggregatesFilter<"School"> | string | null
    email?: StringWithAggregatesFilter<"School"> | string
    phone?: StringNullableWithAggregatesFilter<"School"> | string | null
    status?: StringWithAggregatesFilter<"School"> | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"School"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    level?: StringNullableFilter<"Class"> | string | null
    stream?: StringNullableFilter<"Class"> | string | null
    schoolId?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    subjects?: ClassSubjectListRelationFilter
    timetables?: TimetableListRelationFilter
    teacherClassSubjects?: TeacherClassSubjectListRelationFilter
    trainerClassModules?: TrainerClassModuleListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrderInput | SortOrder
    stream?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    subjects?: ClassSubjectOrderByRelationAggregateInput
    timetables?: TimetableOrderByRelationAggregateInput
    teacherClassSubjects?: TeacherClassSubjectOrderByRelationAggregateInput
    trainerClassModules?: TrainerClassModuleOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_level_stream?: ClassSchoolIdLevelStreamCompoundUniqueInput
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    level?: StringNullableFilter<"Class"> | string | null
    stream?: StringNullableFilter<"Class"> | string | null
    schoolId?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    subjects?: ClassSubjectListRelationFilter
    timetables?: TimetableListRelationFilter
    teacherClassSubjects?: TeacherClassSubjectListRelationFilter
    trainerClassModules?: TrainerClassModuleListRelationFilter
  }, "id" | "schoolId_level_stream">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrderInput | SortOrder
    stream?: SortOrderInput | SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    level?: StringNullableWithAggregatesFilter<"Class"> | string | null
    stream?: StringNullableWithAggregatesFilter<"Class"> | string | null
    schoolId?: StringWithAggregatesFilter<"Class"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    level?: StringNullableFilter<"Subject"> | string | null
    periodsPerWeek?: IntFilter<"Subject"> | number
    schoolId?: StringFilter<"Subject"> | string
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    teachers?: TeacherSubjectListRelationFilter
    classSubjects?: ClassSubjectListRelationFilter
    timetables?: TimetableListRelationFilter
    teacherClassSubjects?: TeacherClassSubjectListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    periodsPerWeek?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    teachers?: TeacherSubjectOrderByRelationAggregateInput
    classSubjects?: ClassSubjectOrderByRelationAggregateInput
    timetables?: TimetableOrderByRelationAggregateInput
    teacherClassSubjects?: TeacherClassSubjectOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name_level?: SubjectSchoolIdNameLevelCompoundUniqueInput
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    level?: StringNullableFilter<"Subject"> | string | null
    periodsPerWeek?: IntFilter<"Subject"> | number
    schoolId?: StringFilter<"Subject"> | string
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    teachers?: TeacherSubjectListRelationFilter
    classSubjects?: ClassSubjectListRelationFilter
    timetables?: TimetableListRelationFilter
    teacherClassSubjects?: TeacherClassSubjectListRelationFilter
  }, "id" | "schoolId_name_level">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    periodsPerWeek?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _avg?: SubjectAvgOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
    _sum?: SubjectSumOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    code?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    level?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    periodsPerWeek?: IntWithAggregatesFilter<"Subject"> | number
    schoolId?: StringWithAggregatesFilter<"Subject"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    code?: StringNullableFilter<"Module"> | string | null
    level?: StringNullableFilter<"Module"> | string | null
    trade?: StringNullableFilter<"Module"> | string | null
    totalHours?: IntFilter<"Module"> | number
    category?: StringFilter<"Module"> | string
    blockSize?: IntFilter<"Module"> | number
    schoolId?: StringFilter<"Module"> | string
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    trainers?: TrainerModuleListRelationFilter
    timetables?: TimetableListRelationFilter
    trainerClassModules?: TrainerClassModuleListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    trade?: SortOrderInput | SortOrder
    totalHours?: SortOrder
    category?: SortOrder
    blockSize?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    trainers?: TrainerModuleOrderByRelationAggregateInput
    timetables?: TimetableOrderByRelationAggregateInput
    trainerClassModules?: TrainerClassModuleOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name_level?: ModuleSchoolIdNameLevelCompoundUniqueInput
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    name?: StringFilter<"Module"> | string
    code?: StringNullableFilter<"Module"> | string | null
    level?: StringNullableFilter<"Module"> | string | null
    trade?: StringNullableFilter<"Module"> | string | null
    totalHours?: IntFilter<"Module"> | number
    category?: StringFilter<"Module"> | string
    blockSize?: IntFilter<"Module"> | number
    schoolId?: StringFilter<"Module"> | string
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    trainers?: TrainerModuleListRelationFilter
    timetables?: TimetableListRelationFilter
    trainerClassModules?: TrainerClassModuleListRelationFilter
  }, "id" | "schoolId_name_level">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    trade?: SortOrderInput | SortOrder
    totalHours?: SortOrder
    category?: SortOrder
    blockSize?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Module"> | string
    name?: StringWithAggregatesFilter<"Module"> | string
    code?: StringNullableWithAggregatesFilter<"Module"> | string | null
    level?: StringNullableWithAggregatesFilter<"Module"> | string | null
    trade?: StringNullableWithAggregatesFilter<"Module"> | string | null
    totalHours?: IntWithAggregatesFilter<"Module"> | number
    category?: StringWithAggregatesFilter<"Module"> | string
    blockSize?: IntWithAggregatesFilter<"Module"> | number
    schoolId?: StringWithAggregatesFilter<"Module"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
  }

  export type TeacherSubjectWhereInput = {
    AND?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    OR?: TeacherSubjectWhereInput[]
    NOT?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    id?: StringFilter<"TeacherSubject"> | string
    teacherId?: StringFilter<"TeacherSubject"> | string
    subjectId?: StringFilter<"TeacherSubject"> | string
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }

  export type TeacherSubjectOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    teacher?: UserOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type TeacherSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teacherId_subjectId?: TeacherSubjectTeacherIdSubjectIdCompoundUniqueInput
    AND?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    OR?: TeacherSubjectWhereInput[]
    NOT?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    teacherId?: StringFilter<"TeacherSubject"> | string
    subjectId?: StringFilter<"TeacherSubject"> | string
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }, "id" | "teacherId_subjectId">

  export type TeacherSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    _count?: TeacherSubjectCountOrderByAggregateInput
    _max?: TeacherSubjectMaxOrderByAggregateInput
    _min?: TeacherSubjectMinOrderByAggregateInput
  }

  export type TeacherSubjectScalarWhereWithAggregatesInput = {
    AND?: TeacherSubjectScalarWhereWithAggregatesInput | TeacherSubjectScalarWhereWithAggregatesInput[]
    OR?: TeacherSubjectScalarWhereWithAggregatesInput[]
    NOT?: TeacherSubjectScalarWhereWithAggregatesInput | TeacherSubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeacherSubject"> | string
    teacherId?: StringWithAggregatesFilter<"TeacherSubject"> | string
    subjectId?: StringWithAggregatesFilter<"TeacherSubject"> | string
  }

  export type TrainerModuleWhereInput = {
    AND?: TrainerModuleWhereInput | TrainerModuleWhereInput[]
    OR?: TrainerModuleWhereInput[]
    NOT?: TrainerModuleWhereInput | TrainerModuleWhereInput[]
    id?: StringFilter<"TrainerModule"> | string
    trainerId?: StringFilter<"TrainerModule"> | string
    moduleId?: StringFilter<"TrainerModule"> | string
    trainer?: XOR<UserRelationFilter, UserWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }

  export type TrainerModuleOrderByWithRelationInput = {
    id?: SortOrder
    trainerId?: SortOrder
    moduleId?: SortOrder
    trainer?: UserOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
  }

  export type TrainerModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trainerId_moduleId?: TrainerModuleTrainerIdModuleIdCompoundUniqueInput
    AND?: TrainerModuleWhereInput | TrainerModuleWhereInput[]
    OR?: TrainerModuleWhereInput[]
    NOT?: TrainerModuleWhereInput | TrainerModuleWhereInput[]
    trainerId?: StringFilter<"TrainerModule"> | string
    moduleId?: StringFilter<"TrainerModule"> | string
    trainer?: XOR<UserRelationFilter, UserWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }, "id" | "trainerId_moduleId">

  export type TrainerModuleOrderByWithAggregationInput = {
    id?: SortOrder
    trainerId?: SortOrder
    moduleId?: SortOrder
    _count?: TrainerModuleCountOrderByAggregateInput
    _max?: TrainerModuleMaxOrderByAggregateInput
    _min?: TrainerModuleMinOrderByAggregateInput
  }

  export type TrainerModuleScalarWhereWithAggregatesInput = {
    AND?: TrainerModuleScalarWhereWithAggregatesInput | TrainerModuleScalarWhereWithAggregatesInput[]
    OR?: TrainerModuleScalarWhereWithAggregatesInput[]
    NOT?: TrainerModuleScalarWhereWithAggregatesInput | TrainerModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainerModule"> | string
    trainerId?: StringWithAggregatesFilter<"TrainerModule"> | string
    moduleId?: StringWithAggregatesFilter<"TrainerModule"> | string
  }

  export type ClassSubjectWhereInput = {
    AND?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    OR?: ClassSubjectWhereInput[]
    NOT?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    id?: StringFilter<"ClassSubject"> | string
    classId?: StringFilter<"ClassSubject"> | string
    subjectId?: StringFilter<"ClassSubject"> | string
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }

  export type ClassSubjectOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type ClassSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    classId_subjectId?: ClassSubjectClassIdSubjectIdCompoundUniqueInput
    AND?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    OR?: ClassSubjectWhereInput[]
    NOT?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    classId?: StringFilter<"ClassSubject"> | string
    subjectId?: StringFilter<"ClassSubject"> | string
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }, "id" | "classId_subjectId">

  export type ClassSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    _count?: ClassSubjectCountOrderByAggregateInput
    _max?: ClassSubjectMaxOrderByAggregateInput
    _min?: ClassSubjectMinOrderByAggregateInput
  }

  export type ClassSubjectScalarWhereWithAggregatesInput = {
    AND?: ClassSubjectScalarWhereWithAggregatesInput | ClassSubjectScalarWhereWithAggregatesInput[]
    OR?: ClassSubjectScalarWhereWithAggregatesInput[]
    NOT?: ClassSubjectScalarWhereWithAggregatesInput | ClassSubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassSubject"> | string
    classId?: StringWithAggregatesFilter<"ClassSubject"> | string
    subjectId?: StringWithAggregatesFilter<"ClassSubject"> | string
  }

  export type TimeSlotWhereInput = {
    AND?: TimeSlotWhereInput | TimeSlotWhereInput[]
    OR?: TimeSlotWhereInput[]
    NOT?: TimeSlotWhereInput | TimeSlotWhereInput[]
    id?: StringFilter<"TimeSlot"> | string
    schoolId?: StringFilter<"TimeSlot"> | string
    day?: StringFilter<"TimeSlot"> | string
    period?: IntFilter<"TimeSlot"> | number
    name?: StringFilter<"TimeSlot"> | string
    startTime?: DateTimeFilter<"TimeSlot"> | Date | string
    endTime?: DateTimeFilter<"TimeSlot"> | Date | string
    session?: StringFilter<"TimeSlot"> | string
    isBreak?: BoolFilter<"TimeSlot"> | boolean
    breakType?: StringNullableFilter<"TimeSlot"> | string | null
    isActive?: BoolFilter<"TimeSlot"> | boolean
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSlot"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    timetables?: TimetableListRelationFilter
  }

  export type TimeSlotOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    day?: SortOrder
    period?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    session?: SortOrder
    isBreak?: SortOrder
    breakType?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    timetables?: TimetableOrderByRelationAggregateInput
  }

  export type TimeSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_day_period?: TimeSlotSchoolIdDayPeriodCompoundUniqueInput
    AND?: TimeSlotWhereInput | TimeSlotWhereInput[]
    OR?: TimeSlotWhereInput[]
    NOT?: TimeSlotWhereInput | TimeSlotWhereInput[]
    schoolId?: StringFilter<"TimeSlot"> | string
    day?: StringFilter<"TimeSlot"> | string
    period?: IntFilter<"TimeSlot"> | number
    name?: StringFilter<"TimeSlot"> | string
    startTime?: DateTimeFilter<"TimeSlot"> | Date | string
    endTime?: DateTimeFilter<"TimeSlot"> | Date | string
    session?: StringFilter<"TimeSlot"> | string
    isBreak?: BoolFilter<"TimeSlot"> | boolean
    breakType?: StringNullableFilter<"TimeSlot"> | string | null
    isActive?: BoolFilter<"TimeSlot"> | boolean
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSlot"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    timetables?: TimetableListRelationFilter
  }, "id" | "schoolId_day_period">

  export type TimeSlotOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    day?: SortOrder
    period?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    session?: SortOrder
    isBreak?: SortOrder
    breakType?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimeSlotCountOrderByAggregateInput
    _avg?: TimeSlotAvgOrderByAggregateInput
    _max?: TimeSlotMaxOrderByAggregateInput
    _min?: TimeSlotMinOrderByAggregateInput
    _sum?: TimeSlotSumOrderByAggregateInput
  }

  export type TimeSlotScalarWhereWithAggregatesInput = {
    AND?: TimeSlotScalarWhereWithAggregatesInput | TimeSlotScalarWhereWithAggregatesInput[]
    OR?: TimeSlotScalarWhereWithAggregatesInput[]
    NOT?: TimeSlotScalarWhereWithAggregatesInput | TimeSlotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeSlot"> | string
    schoolId?: StringWithAggregatesFilter<"TimeSlot"> | string
    day?: StringWithAggregatesFilter<"TimeSlot"> | string
    period?: IntWithAggregatesFilter<"TimeSlot"> | number
    name?: StringWithAggregatesFilter<"TimeSlot"> | string
    startTime?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    session?: StringWithAggregatesFilter<"TimeSlot"> | string
    isBreak?: BoolWithAggregatesFilter<"TimeSlot"> | boolean
    breakType?: StringNullableWithAggregatesFilter<"TimeSlot"> | string | null
    isActive?: BoolWithAggregatesFilter<"TimeSlot"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
  }

  export type TimetableWhereInput = {
    AND?: TimetableWhereInput | TimetableWhereInput[]
    OR?: TimetableWhereInput[]
    NOT?: TimetableWhereInput | TimetableWhereInput[]
    id?: StringFilter<"Timetable"> | string
    schoolId?: StringFilter<"Timetable"> | string
    classId?: StringFilter<"Timetable"> | string
    teacherId?: StringFilter<"Timetable"> | string
    subjectId?: StringNullableFilter<"Timetable"> | string | null
    moduleId?: StringNullableFilter<"Timetable"> | string | null
    timeSlotId?: StringFilter<"Timetable"> | string
    createdAt?: DateTimeFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeFilter<"Timetable"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    subject?: XOR<SubjectNullableRelationFilter, SubjectWhereInput> | null
    module?: XOR<ModuleNullableRelationFilter, ModuleWhereInput> | null
    timeSlot?: XOR<TimeSlotRelationFilter, TimeSlotWhereInput>
  }

  export type TimetableOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    timeSlotId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    teacher?: UserOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    timeSlot?: TimeSlotOrderByWithRelationInput
  }

  export type TimetableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_classId_timeSlotId?: TimetableSchoolIdClassIdTimeSlotIdCompoundUniqueInput
    AND?: TimetableWhereInput | TimetableWhereInput[]
    OR?: TimetableWhereInput[]
    NOT?: TimetableWhereInput | TimetableWhereInput[]
    schoolId?: StringFilter<"Timetable"> | string
    classId?: StringFilter<"Timetable"> | string
    teacherId?: StringFilter<"Timetable"> | string
    subjectId?: StringNullableFilter<"Timetable"> | string | null
    moduleId?: StringNullableFilter<"Timetable"> | string | null
    timeSlotId?: StringFilter<"Timetable"> | string
    createdAt?: DateTimeFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeFilter<"Timetable"> | Date | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    subject?: XOR<SubjectNullableRelationFilter, SubjectWhereInput> | null
    module?: XOR<ModuleNullableRelationFilter, ModuleWhereInput> | null
    timeSlot?: XOR<TimeSlotRelationFilter, TimeSlotWhereInput>
  }, "id" | "schoolId_classId_timeSlotId">

  export type TimetableOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    timeSlotId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimetableCountOrderByAggregateInput
    _max?: TimetableMaxOrderByAggregateInput
    _min?: TimetableMinOrderByAggregateInput
  }

  export type TimetableScalarWhereWithAggregatesInput = {
    AND?: TimetableScalarWhereWithAggregatesInput | TimetableScalarWhereWithAggregatesInput[]
    OR?: TimetableScalarWhereWithAggregatesInput[]
    NOT?: TimetableScalarWhereWithAggregatesInput | TimetableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Timetable"> | string
    schoolId?: StringWithAggregatesFilter<"Timetable"> | string
    classId?: StringWithAggregatesFilter<"Timetable"> | string
    teacherId?: StringWithAggregatesFilter<"Timetable"> | string
    subjectId?: StringNullableWithAggregatesFilter<"Timetable"> | string | null
    moduleId?: StringNullableWithAggregatesFilter<"Timetable"> | string | null
    timeSlotId?: StringWithAggregatesFilter<"Timetable"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Timetable"> | Date | string
  }

  export type TeacherClassSubjectWhereInput = {
    AND?: TeacherClassSubjectWhereInput | TeacherClassSubjectWhereInput[]
    OR?: TeacherClassSubjectWhereInput[]
    NOT?: TeacherClassSubjectWhereInput | TeacherClassSubjectWhereInput[]
    id?: StringFilter<"TeacherClassSubject"> | string
    teacherId?: StringFilter<"TeacherClassSubject"> | string
    classId?: StringFilter<"TeacherClassSubject"> | string
    subjectId?: StringFilter<"TeacherClassSubject"> | string
    schoolId?: StringFilter<"TeacherClassSubject"> | string
    createdAt?: DateTimeFilter<"TeacherClassSubject"> | Date | string
    updatedAt?: DateTimeFilter<"TeacherClassSubject"> | Date | string
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type TeacherClassSubjectOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacher?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
  }

  export type TeacherClassSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teacherId_classId_subjectId?: TeacherClassSubjectTeacherIdClassIdSubjectIdCompoundUniqueInput
    AND?: TeacherClassSubjectWhereInput | TeacherClassSubjectWhereInput[]
    OR?: TeacherClassSubjectWhereInput[]
    NOT?: TeacherClassSubjectWhereInput | TeacherClassSubjectWhereInput[]
    teacherId?: StringFilter<"TeacherClassSubject"> | string
    classId?: StringFilter<"TeacherClassSubject"> | string
    subjectId?: StringFilter<"TeacherClassSubject"> | string
    schoolId?: StringFilter<"TeacherClassSubject"> | string
    createdAt?: DateTimeFilter<"TeacherClassSubject"> | Date | string
    updatedAt?: DateTimeFilter<"TeacherClassSubject"> | Date | string
    teacher?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id" | "teacherId_classId_subjectId">

  export type TeacherClassSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherClassSubjectCountOrderByAggregateInput
    _max?: TeacherClassSubjectMaxOrderByAggregateInput
    _min?: TeacherClassSubjectMinOrderByAggregateInput
  }

  export type TeacherClassSubjectScalarWhereWithAggregatesInput = {
    AND?: TeacherClassSubjectScalarWhereWithAggregatesInput | TeacherClassSubjectScalarWhereWithAggregatesInput[]
    OR?: TeacherClassSubjectScalarWhereWithAggregatesInput[]
    NOT?: TeacherClassSubjectScalarWhereWithAggregatesInput | TeacherClassSubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeacherClassSubject"> | string
    teacherId?: StringWithAggregatesFilter<"TeacherClassSubject"> | string
    classId?: StringWithAggregatesFilter<"TeacherClassSubject"> | string
    subjectId?: StringWithAggregatesFilter<"TeacherClassSubject"> | string
    schoolId?: StringWithAggregatesFilter<"TeacherClassSubject"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TeacherClassSubject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeacherClassSubject"> | Date | string
  }

  export type TrainerClassModuleWhereInput = {
    AND?: TrainerClassModuleWhereInput | TrainerClassModuleWhereInput[]
    OR?: TrainerClassModuleWhereInput[]
    NOT?: TrainerClassModuleWhereInput | TrainerClassModuleWhereInput[]
    id?: StringFilter<"TrainerClassModule"> | string
    trainerId?: StringFilter<"TrainerClassModule"> | string
    classId?: StringFilter<"TrainerClassModule"> | string
    moduleId?: StringFilter<"TrainerClassModule"> | string
    schoolId?: StringFilter<"TrainerClassModule"> | string
    createdAt?: DateTimeFilter<"TrainerClassModule"> | Date | string
    updatedAt?: DateTimeFilter<"TrainerClassModule"> | Date | string
    trainer?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }

  export type TrainerClassModuleOrderByWithRelationInput = {
    id?: SortOrder
    trainerId?: SortOrder
    classId?: SortOrder
    moduleId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainer?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
  }

  export type TrainerClassModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trainerId_classId_moduleId?: TrainerClassModuleTrainerIdClassIdModuleIdCompoundUniqueInput
    AND?: TrainerClassModuleWhereInput | TrainerClassModuleWhereInput[]
    OR?: TrainerClassModuleWhereInput[]
    NOT?: TrainerClassModuleWhereInput | TrainerClassModuleWhereInput[]
    trainerId?: StringFilter<"TrainerClassModule"> | string
    classId?: StringFilter<"TrainerClassModule"> | string
    moduleId?: StringFilter<"TrainerClassModule"> | string
    schoolId?: StringFilter<"TrainerClassModule"> | string
    createdAt?: DateTimeFilter<"TrainerClassModule"> | Date | string
    updatedAt?: DateTimeFilter<"TrainerClassModule"> | Date | string
    trainer?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
  }, "id" | "trainerId_classId_moduleId">

  export type TrainerClassModuleOrderByWithAggregationInput = {
    id?: SortOrder
    trainerId?: SortOrder
    classId?: SortOrder
    moduleId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainerClassModuleCountOrderByAggregateInput
    _max?: TrainerClassModuleMaxOrderByAggregateInput
    _min?: TrainerClassModuleMinOrderByAggregateInput
  }

  export type TrainerClassModuleScalarWhereWithAggregatesInput = {
    AND?: TrainerClassModuleScalarWhereWithAggregatesInput | TrainerClassModuleScalarWhereWithAggregatesInput[]
    OR?: TrainerClassModuleScalarWhereWithAggregatesInput[]
    NOT?: TrainerClassModuleScalarWhereWithAggregatesInput | TrainerClassModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainerClassModule"> | string
    trainerId?: StringWithAggregatesFilter<"TrainerClassModule"> | string
    classId?: StringWithAggregatesFilter<"TrainerClassModule"> | string
    moduleId?: StringWithAggregatesFilter<"TrainerClassModule"> | string
    schoolId?: StringWithAggregatesFilter<"TrainerClassModule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainerClassModule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainerClassModule"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    trainerModules?: TrainerModuleCreateNestedManyWithoutTrainerInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutTeacherInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutTrainerInput
    timetablesAsTeacher?: TimetableCreateNestedManyWithoutTeacherInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    schoolId?: string | null
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    trainerModules?: TrainerModuleUncheckedCreateNestedManyWithoutTrainerInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutTeacherInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutTrainerInput
    timetablesAsTeacher?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    trainerModules?: TrainerModuleUpdateManyWithoutTrainerNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutTeacherNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutTrainerNestedInput
    timetablesAsTeacher?: TimetableUpdateManyWithoutTeacherNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    trainerModules?: TrainerModuleUncheckedUpdateManyWithoutTrainerNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutTrainerNestedInput
    timetablesAsTeacher?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    schoolId?: string | null
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    modules?: ModuleCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSchoolInput
    timetables?: TimetableCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    modules?: ModuleUncheckedCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSchoolInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutClassInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutClassInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutClassNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSubjectsInput
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSubjects?: ClassSubjectCreateNestedManyWithoutSubjectInput
    timetables?: TimetableCreateNestedManyWithoutSubjectInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSubjects?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSubjectInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSubjects?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    timetables?: TimetableUpdateManyWithoutSubjectNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSubjects?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSubjectNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutModulesInput
    trainers?: TrainerModuleCreateNestedManyWithoutModuleInput
    timetables?: TimetableCreateNestedManyWithoutModuleInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainers?: TrainerModuleUncheckedCreateNestedManyWithoutModuleInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutModuleInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutModulesNestedInput
    trainers?: TrainerModuleUpdateManyWithoutModuleNestedInput
    timetables?: TimetableUpdateManyWithoutModuleNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainers?: TrainerModuleUncheckedUpdateManyWithoutModuleNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutModuleNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherSubjectCreateInput = {
    id?: string
    teacher: UserCreateNestedOneWithoutTeacherSubjectsInput
    subject: SubjectCreateNestedOneWithoutTeachersInput
  }

  export type TeacherSubjectUncheckedCreateInput = {
    id?: string
    teacherId: string
    subjectId: string
  }

  export type TeacherSubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacher?: UserUpdateOneRequiredWithoutTeacherSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherSubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectCreateManyInput = {
    id?: string
    teacherId: string
    subjectId: string
  }

  export type TeacherSubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type TrainerModuleCreateInput = {
    id?: string
    trainer: UserCreateNestedOneWithoutTrainerModulesInput
    module: ModuleCreateNestedOneWithoutTrainersInput
  }

  export type TrainerModuleUncheckedCreateInput = {
    id?: string
    trainerId: string
    moduleId: string
  }

  export type TrainerModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainer?: UserUpdateOneRequiredWithoutTrainerModulesNestedInput
    module?: ModuleUpdateOneRequiredWithoutTrainersNestedInput
  }

  export type TrainerModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type TrainerModuleCreateManyInput = {
    id?: string
    trainerId: string
    moduleId: string
  }

  export type TrainerModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainerModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSubjectCreateInput = {
    id?: string
    class: ClassCreateNestedOneWithoutSubjectsInput
    subject: SubjectCreateNestedOneWithoutClassSubjectsInput
  }

  export type ClassSubjectUncheckedCreateInput = {
    id?: string
    classId: string
    subjectId: string
  }

  export type ClassSubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutClassSubjectsNestedInput
  }

  export type ClassSubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSubjectCreateManyInput = {
    id?: string
    classId: string
    subjectId: string
  }

  export type ClassSubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeSlotCreateInput = {
    id?: string
    day: string
    period: number
    name: string
    startTime: Date | string
    endTime: Date | string
    session: string
    isBreak?: boolean
    breakType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimeSlotsInput
    timetables?: TimetableCreateNestedManyWithoutTimeSlotInput
  }

  export type TimeSlotUncheckedCreateInput = {
    id?: string
    schoolId: string
    day: string
    period: number
    name: string
    startTime: Date | string
    endTime: Date | string
    session: string
    isBreak?: boolean
    breakType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    timetables?: TimetableUncheckedCreateNestedManyWithoutTimeSlotInput
  }

  export type TimeSlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
    isBreak?: BoolFieldUpdateOperationsInput | boolean
    breakType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimeSlotsNestedInput
    timetables?: TimetableUpdateManyWithoutTimeSlotNestedInput
  }

  export type TimeSlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
    isBreak?: BoolFieldUpdateOperationsInput | boolean
    breakType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetables?: TimetableUncheckedUpdateManyWithoutTimeSlotNestedInput
  }

  export type TimeSlotCreateManyInput = {
    id?: string
    schoolId: string
    day: string
    period: number
    name: string
    startTime: Date | string
    endTime: Date | string
    session: string
    isBreak?: boolean
    breakType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeSlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
    isBreak?: BoolFieldUpdateOperationsInput | boolean
    breakType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
    isBreak?: BoolFieldUpdateOperationsInput | boolean
    breakType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetablesInput
    class: ClassCreateNestedOneWithoutTimetablesInput
    teacher: UserCreateNestedOneWithoutTimetablesAsTeacherInput
    subject?: SubjectCreateNestedOneWithoutTimetablesInput
    module?: ModuleCreateNestedOneWithoutTimetablesInput
    timeSlot: TimeSlotCreateNestedOneWithoutTimetablesInput
  }

  export type TimetableUncheckedCreateInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    subjectId?: string | null
    moduleId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetablesNestedInput
    class?: ClassUpdateOneRequiredWithoutTimetablesNestedInput
    teacher?: UserUpdateOneRequiredWithoutTimetablesAsTeacherNestedInput
    subject?: SubjectUpdateOneWithoutTimetablesNestedInput
    module?: ModuleUpdateOneWithoutTimetablesNestedInput
    timeSlot?: TimeSlotUpdateOneRequiredWithoutTimetablesNestedInput
  }

  export type TimetableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableCreateManyInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    subjectId?: string | null
    moduleId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassSubjectCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutTeacherClassSubjectsInput
    class: ClassCreateNestedOneWithoutTeacherClassSubjectsInput
    subject: SubjectCreateNestedOneWithoutTeacherClassSubjectsInput
    school: SchoolCreateNestedOneWithoutTeacherClassSubjectsInput
  }

  export type TeacherClassSubjectUncheckedCreateInput = {
    id?: string
    teacherId: string
    classId: string
    subjectId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherClassSubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    class?: ClassUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
  }

  export type TeacherClassSubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassSubjectCreateManyInput = {
    id?: string
    teacherId: string
    classId: string
    subjectId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherClassSubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassSubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerClassModulesInput
    class: ClassCreateNestedOneWithoutTrainerClassModulesInput
    module: ModuleCreateNestedOneWithoutTrainerClassModulesInput
    school: SchoolCreateNestedOneWithoutTrainerClassModulesInput
  }

  export type TrainerClassModuleUncheckedCreateInput = {
    id?: string
    trainerId: string
    classId: string
    moduleId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerClassModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    class?: ClassUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    module?: ModuleUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    school?: SchoolUpdateOneRequiredWithoutTrainerClassModulesNestedInput
  }

  export type TrainerClassModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleCreateManyInput = {
    id?: string
    trainerId: string
    classId: string
    moduleId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerClassModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SchoolNullableRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type TeacherSubjectListRelationFilter = {
    every?: TeacherSubjectWhereInput
    some?: TeacherSubjectWhereInput
    none?: TeacherSubjectWhereInput
  }

  export type TrainerModuleListRelationFilter = {
    every?: TrainerModuleWhereInput
    some?: TrainerModuleWhereInput
    none?: TrainerModuleWhereInput
  }

  export type TeacherClassSubjectListRelationFilter = {
    every?: TeacherClassSubjectWhereInput
    some?: TeacherClassSubjectWhereInput
    none?: TeacherClassSubjectWhereInput
  }

  export type TrainerClassModuleListRelationFilter = {
    every?: TrainerClassModuleWhereInput
    some?: TrainerClassModuleWhereInput
    none?: TrainerClassModuleWhereInput
  }

  export type TimetableListRelationFilter = {
    every?: TimetableWhereInput
    some?: TimetableWhereInput
    none?: TimetableWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TeacherSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainerModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherClassSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainerClassModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimetableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    isActive?: SortOrder
    maxWeeklyHours?: SortOrder
    teachingStreams?: SortOrder
    unavailableDays?: SortOrder
    unavailablePeriods?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    maxWeeklyHours?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    isActive?: SortOrder
    maxWeeklyHours?: SortOrder
    teachingStreams?: SortOrder
    unavailableDays?: SortOrder
    unavailablePeriods?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    schoolId?: SortOrder
    isActive?: SortOrder
    maxWeeklyHours?: SortOrder
    teachingStreams?: SortOrder
    unavailableDays?: SortOrder
    unavailablePeriods?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    maxWeeklyHours?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type TimeSlotListRelationFilter = {
    every?: TimeSlotWhereInput
    some?: TimeSlotWhereInput
    none?: TimeSlotWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    province?: SortOrder
    district?: SortOrder
    sector?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    province?: SortOrder
    district?: SortOrder
    sector?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    province?: SortOrder
    district?: SortOrder
    sector?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SchoolRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type ClassSubjectListRelationFilter = {
    every?: ClassSubjectWhereInput
    some?: ClassSubjectWhereInput
    none?: ClassSubjectWhereInput
  }

  export type ClassSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassSchoolIdLevelStreamCompoundUniqueInput = {
    schoolId: string
    level: string
    stream: string
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    stream?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    stream?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    stream?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SubjectSchoolIdNameLevelCompoundUniqueInput = {
    schoolId: string
    name: string
    level: string
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    periodsPerWeek?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectAvgOrderByAggregateInput = {
    periodsPerWeek?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    periodsPerWeek?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    periodsPerWeek?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectSumOrderByAggregateInput = {
    periodsPerWeek?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ModuleSchoolIdNameLevelCompoundUniqueInput = {
    schoolId: string
    name: string
    level: string
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    trade?: SortOrder
    totalHours?: SortOrder
    category?: SortOrder
    blockSize?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    totalHours?: SortOrder
    blockSize?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    trade?: SortOrder
    totalHours?: SortOrder
    category?: SortOrder
    blockSize?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    level?: SortOrder
    trade?: SortOrder
    totalHours?: SortOrder
    category?: SortOrder
    blockSize?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    totalHours?: SortOrder
    blockSize?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SubjectRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type TeacherSubjectTeacherIdSubjectIdCompoundUniqueInput = {
    teacherId: string
    subjectId: string
  }

  export type TeacherSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
  }

  export type TeacherSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
  }

  export type TeacherSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
  }

  export type ModuleRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type TrainerModuleTrainerIdModuleIdCompoundUniqueInput = {
    trainerId: string
    moduleId: string
  }

  export type TrainerModuleCountOrderByAggregateInput = {
    id?: SortOrder
    trainerId?: SortOrder
    moduleId?: SortOrder
  }

  export type TrainerModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    trainerId?: SortOrder
    moduleId?: SortOrder
  }

  export type TrainerModuleMinOrderByAggregateInput = {
    id?: SortOrder
    trainerId?: SortOrder
    moduleId?: SortOrder
  }

  export type ClassRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type ClassSubjectClassIdSubjectIdCompoundUniqueInput = {
    classId: string
    subjectId: string
  }

  export type ClassSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
  }

  export type ClassSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
  }

  export type ClassSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
  }

  export type TimeSlotSchoolIdDayPeriodCompoundUniqueInput = {
    schoolId: string
    day: string
    period: number
  }

  export type TimeSlotCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    day?: SortOrder
    period?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    session?: SortOrder
    isBreak?: SortOrder
    breakType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeSlotAvgOrderByAggregateInput = {
    period?: SortOrder
  }

  export type TimeSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    day?: SortOrder
    period?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    session?: SortOrder
    isBreak?: SortOrder
    breakType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeSlotMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    day?: SortOrder
    period?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    session?: SortOrder
    isBreak?: SortOrder
    breakType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeSlotSumOrderByAggregateInput = {
    period?: SortOrder
  }

  export type SubjectNullableRelationFilter = {
    is?: SubjectWhereInput | null
    isNot?: SubjectWhereInput | null
  }

  export type ModuleNullableRelationFilter = {
    is?: ModuleWhereInput | null
    isNot?: ModuleWhereInput | null
  }

  export type TimeSlotRelationFilter = {
    is?: TimeSlotWhereInput
    isNot?: TimeSlotWhereInput
  }

  export type TimetableSchoolIdClassIdTimeSlotIdCompoundUniqueInput = {
    schoolId: string
    classId: string
    timeSlotId: string
  }

  export type TimetableCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    moduleId?: SortOrder
    timeSlotId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimetableMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    moduleId?: SortOrder
    timeSlotId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimetableMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    moduleId?: SortOrder
    timeSlotId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherClassSubjectTeacherIdClassIdSubjectIdCompoundUniqueInput = {
    teacherId: string
    classId: string
    subjectId: string
  }

  export type TeacherClassSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherClassSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherClassSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    classId?: SortOrder
    subjectId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainerClassModuleTrainerIdClassIdModuleIdCompoundUniqueInput = {
    trainerId: string
    classId: string
    moduleId: string
  }

  export type TrainerClassModuleCountOrderByAggregateInput = {
    id?: SortOrder
    trainerId?: SortOrder
    classId?: SortOrder
    moduleId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainerClassModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    trainerId?: SortOrder
    classId?: SortOrder
    moduleId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainerClassModuleMinOrderByAggregateInput = {
    id?: SortOrder
    trainerId?: SortOrder
    classId?: SortOrder
    moduleId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolCreateNestedOneWithoutUsersInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    connect?: SchoolWhereUniqueInput
  }

  export type TeacherSubjectCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type TrainerModuleCreateNestedManyWithoutTrainerInput = {
    create?: XOR<TrainerModuleCreateWithoutTrainerInput, TrainerModuleUncheckedCreateWithoutTrainerInput> | TrainerModuleCreateWithoutTrainerInput[] | TrainerModuleUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainerModuleCreateOrConnectWithoutTrainerInput | TrainerModuleCreateOrConnectWithoutTrainerInput[]
    createMany?: TrainerModuleCreateManyTrainerInputEnvelope
    connect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
  }

  export type TeacherClassSubjectCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutTeacherInput, TeacherClassSubjectUncheckedCreateWithoutTeacherInput> | TeacherClassSubjectCreateWithoutTeacherInput[] | TeacherClassSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutTeacherInput | TeacherClassSubjectCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherClassSubjectCreateManyTeacherInputEnvelope
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
  }

  export type TrainerClassModuleCreateNestedManyWithoutTrainerInput = {
    create?: XOR<TrainerClassModuleCreateWithoutTrainerInput, TrainerClassModuleUncheckedCreateWithoutTrainerInput> | TrainerClassModuleCreateWithoutTrainerInput[] | TrainerClassModuleUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutTrainerInput | TrainerClassModuleCreateOrConnectWithoutTrainerInput[]
    createMany?: TrainerClassModuleCreateManyTrainerInputEnvelope
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
  }

  export type TimetableCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput> | TimetableCreateWithoutTeacherInput[] | TimetableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTeacherInput | TimetableCreateOrConnectWithoutTeacherInput[]
    createMany?: TimetableCreateManyTeacherInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type TrainerModuleUncheckedCreateNestedManyWithoutTrainerInput = {
    create?: XOR<TrainerModuleCreateWithoutTrainerInput, TrainerModuleUncheckedCreateWithoutTrainerInput> | TrainerModuleCreateWithoutTrainerInput[] | TrainerModuleUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainerModuleCreateOrConnectWithoutTrainerInput | TrainerModuleCreateOrConnectWithoutTrainerInput[]
    createMany?: TrainerModuleCreateManyTrainerInputEnvelope
    connect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
  }

  export type TeacherClassSubjectUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutTeacherInput, TeacherClassSubjectUncheckedCreateWithoutTeacherInput> | TeacherClassSubjectCreateWithoutTeacherInput[] | TeacherClassSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutTeacherInput | TeacherClassSubjectCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherClassSubjectCreateManyTeacherInputEnvelope
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
  }

  export type TrainerClassModuleUncheckedCreateNestedManyWithoutTrainerInput = {
    create?: XOR<TrainerClassModuleCreateWithoutTrainerInput, TrainerClassModuleUncheckedCreateWithoutTrainerInput> | TrainerClassModuleCreateWithoutTrainerInput[] | TrainerClassModuleUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutTrainerInput | TrainerClassModuleCreateOrConnectWithoutTrainerInput[]
    createMany?: TrainerClassModuleCreateManyTrainerInputEnvelope
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
  }

  export type TimetableUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput> | TimetableCreateWithoutTeacherInput[] | TimetableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTeacherInput | TimetableCreateOrConnectWithoutTeacherInput[]
    createMany?: TimetableCreateManyTeacherInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SchoolUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    upsert?: SchoolUpsertWithoutUsersInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutUsersInput, SchoolUpdateWithoutUsersInput>, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type TeacherSubjectUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutTeacherInput | TeacherSubjectUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type TrainerModuleUpdateManyWithoutTrainerNestedInput = {
    create?: XOR<TrainerModuleCreateWithoutTrainerInput, TrainerModuleUncheckedCreateWithoutTrainerInput> | TrainerModuleCreateWithoutTrainerInput[] | TrainerModuleUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainerModuleCreateOrConnectWithoutTrainerInput | TrainerModuleCreateOrConnectWithoutTrainerInput[]
    upsert?: TrainerModuleUpsertWithWhereUniqueWithoutTrainerInput | TrainerModuleUpsertWithWhereUniqueWithoutTrainerInput[]
    createMany?: TrainerModuleCreateManyTrainerInputEnvelope
    set?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    disconnect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    delete?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    connect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    update?: TrainerModuleUpdateWithWhereUniqueWithoutTrainerInput | TrainerModuleUpdateWithWhereUniqueWithoutTrainerInput[]
    updateMany?: TrainerModuleUpdateManyWithWhereWithoutTrainerInput | TrainerModuleUpdateManyWithWhereWithoutTrainerInput[]
    deleteMany?: TrainerModuleScalarWhereInput | TrainerModuleScalarWhereInput[]
  }

  export type TeacherClassSubjectUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutTeacherInput, TeacherClassSubjectUncheckedCreateWithoutTeacherInput> | TeacherClassSubjectCreateWithoutTeacherInput[] | TeacherClassSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutTeacherInput | TeacherClassSubjectCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherClassSubjectUpsertWithWhereUniqueWithoutTeacherInput | TeacherClassSubjectUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherClassSubjectCreateManyTeacherInputEnvelope
    set?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    disconnect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    delete?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    update?: TeacherClassSubjectUpdateWithWhereUniqueWithoutTeacherInput | TeacherClassSubjectUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherClassSubjectUpdateManyWithWhereWithoutTeacherInput | TeacherClassSubjectUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherClassSubjectScalarWhereInput | TeacherClassSubjectScalarWhereInput[]
  }

  export type TrainerClassModuleUpdateManyWithoutTrainerNestedInput = {
    create?: XOR<TrainerClassModuleCreateWithoutTrainerInput, TrainerClassModuleUncheckedCreateWithoutTrainerInput> | TrainerClassModuleCreateWithoutTrainerInput[] | TrainerClassModuleUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutTrainerInput | TrainerClassModuleCreateOrConnectWithoutTrainerInput[]
    upsert?: TrainerClassModuleUpsertWithWhereUniqueWithoutTrainerInput | TrainerClassModuleUpsertWithWhereUniqueWithoutTrainerInput[]
    createMany?: TrainerClassModuleCreateManyTrainerInputEnvelope
    set?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    disconnect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    delete?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    update?: TrainerClassModuleUpdateWithWhereUniqueWithoutTrainerInput | TrainerClassModuleUpdateWithWhereUniqueWithoutTrainerInput[]
    updateMany?: TrainerClassModuleUpdateManyWithWhereWithoutTrainerInput | TrainerClassModuleUpdateManyWithWhereWithoutTrainerInput[]
    deleteMany?: TrainerClassModuleScalarWhereInput | TrainerClassModuleScalarWhereInput[]
  }

  export type TimetableUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput> | TimetableCreateWithoutTeacherInput[] | TimetableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTeacherInput | TimetableCreateOrConnectWithoutTeacherInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutTeacherInput | TimetableUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TimetableCreateManyTeacherInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutTeacherInput | TimetableUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutTeacherInput | TimetableUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutTeacherInput | TeacherSubjectUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type TrainerModuleUncheckedUpdateManyWithoutTrainerNestedInput = {
    create?: XOR<TrainerModuleCreateWithoutTrainerInput, TrainerModuleUncheckedCreateWithoutTrainerInput> | TrainerModuleCreateWithoutTrainerInput[] | TrainerModuleUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainerModuleCreateOrConnectWithoutTrainerInput | TrainerModuleCreateOrConnectWithoutTrainerInput[]
    upsert?: TrainerModuleUpsertWithWhereUniqueWithoutTrainerInput | TrainerModuleUpsertWithWhereUniqueWithoutTrainerInput[]
    createMany?: TrainerModuleCreateManyTrainerInputEnvelope
    set?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    disconnect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    delete?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    connect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    update?: TrainerModuleUpdateWithWhereUniqueWithoutTrainerInput | TrainerModuleUpdateWithWhereUniqueWithoutTrainerInput[]
    updateMany?: TrainerModuleUpdateManyWithWhereWithoutTrainerInput | TrainerModuleUpdateManyWithWhereWithoutTrainerInput[]
    deleteMany?: TrainerModuleScalarWhereInput | TrainerModuleScalarWhereInput[]
  }

  export type TeacherClassSubjectUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutTeacherInput, TeacherClassSubjectUncheckedCreateWithoutTeacherInput> | TeacherClassSubjectCreateWithoutTeacherInput[] | TeacherClassSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutTeacherInput | TeacherClassSubjectCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherClassSubjectUpsertWithWhereUniqueWithoutTeacherInput | TeacherClassSubjectUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherClassSubjectCreateManyTeacherInputEnvelope
    set?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    disconnect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    delete?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    update?: TeacherClassSubjectUpdateWithWhereUniqueWithoutTeacherInput | TeacherClassSubjectUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherClassSubjectUpdateManyWithWhereWithoutTeacherInput | TeacherClassSubjectUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherClassSubjectScalarWhereInput | TeacherClassSubjectScalarWhereInput[]
  }

  export type TrainerClassModuleUncheckedUpdateManyWithoutTrainerNestedInput = {
    create?: XOR<TrainerClassModuleCreateWithoutTrainerInput, TrainerClassModuleUncheckedCreateWithoutTrainerInput> | TrainerClassModuleCreateWithoutTrainerInput[] | TrainerClassModuleUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutTrainerInput | TrainerClassModuleCreateOrConnectWithoutTrainerInput[]
    upsert?: TrainerClassModuleUpsertWithWhereUniqueWithoutTrainerInput | TrainerClassModuleUpsertWithWhereUniqueWithoutTrainerInput[]
    createMany?: TrainerClassModuleCreateManyTrainerInputEnvelope
    set?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    disconnect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    delete?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    update?: TrainerClassModuleUpdateWithWhereUniqueWithoutTrainerInput | TrainerClassModuleUpdateWithWhereUniqueWithoutTrainerInput[]
    updateMany?: TrainerClassModuleUpdateManyWithWhereWithoutTrainerInput | TrainerClassModuleUpdateManyWithWhereWithoutTrainerInput[]
    deleteMany?: TrainerClassModuleScalarWhereInput | TrainerClassModuleScalarWhereInput[]
  }

  export type TimetableUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput> | TimetableCreateWithoutTeacherInput[] | TimetableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTeacherInput | TimetableCreateOrConnectWithoutTeacherInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutTeacherInput | TimetableUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TimetableCreateManyTeacherInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutTeacherInput | TimetableUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutTeacherInput | TimetableUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ModuleCreateWithoutSchoolInput, ModuleUncheckedCreateWithoutSchoolInput> | ModuleCreateWithoutSchoolInput[] | ModuleUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutSchoolInput | ModuleCreateOrConnectWithoutSchoolInput[]
    createMany?: ModuleCreateManySchoolInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type TimeSlotCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TimeSlotCreateWithoutSchoolInput, TimeSlotUncheckedCreateWithoutSchoolInput> | TimeSlotCreateWithoutSchoolInput[] | TimeSlotUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutSchoolInput | TimeSlotCreateOrConnectWithoutSchoolInput[]
    createMany?: TimeSlotCreateManySchoolInputEnvelope
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
  }

  export type TimetableCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TimetableCreateWithoutSchoolInput, TimetableUncheckedCreateWithoutSchoolInput> | TimetableCreateWithoutSchoolInput[] | TimetableUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutSchoolInput | TimetableCreateOrConnectWithoutSchoolInput[]
    createMany?: TimetableCreateManySchoolInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type TeacherClassSubjectCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutSchoolInput, TeacherClassSubjectUncheckedCreateWithoutSchoolInput> | TeacherClassSubjectCreateWithoutSchoolInput[] | TeacherClassSubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutSchoolInput | TeacherClassSubjectCreateOrConnectWithoutSchoolInput[]
    createMany?: TeacherClassSubjectCreateManySchoolInputEnvelope
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
  }

  export type TrainerClassModuleCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TrainerClassModuleCreateWithoutSchoolInput, TrainerClassModuleUncheckedCreateWithoutSchoolInput> | TrainerClassModuleCreateWithoutSchoolInput[] | TrainerClassModuleUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutSchoolInput | TrainerClassModuleCreateOrConnectWithoutSchoolInput[]
    createMany?: TrainerClassModuleCreateManySchoolInputEnvelope
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ModuleCreateWithoutSchoolInput, ModuleUncheckedCreateWithoutSchoolInput> | ModuleCreateWithoutSchoolInput[] | ModuleUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutSchoolInput | ModuleCreateOrConnectWithoutSchoolInput[]
    createMany?: ModuleCreateManySchoolInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type TimeSlotUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TimeSlotCreateWithoutSchoolInput, TimeSlotUncheckedCreateWithoutSchoolInput> | TimeSlotCreateWithoutSchoolInput[] | TimeSlotUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutSchoolInput | TimeSlotCreateOrConnectWithoutSchoolInput[]
    createMany?: TimeSlotCreateManySchoolInputEnvelope
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
  }

  export type TimetableUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TimetableCreateWithoutSchoolInput, TimetableUncheckedCreateWithoutSchoolInput> | TimetableCreateWithoutSchoolInput[] | TimetableUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutSchoolInput | TimetableCreateOrConnectWithoutSchoolInput[]
    createMany?: TimetableCreateManySchoolInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type TeacherClassSubjectUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutSchoolInput, TeacherClassSubjectUncheckedCreateWithoutSchoolInput> | TeacherClassSubjectCreateWithoutSchoolInput[] | TeacherClassSubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutSchoolInput | TeacherClassSubjectCreateOrConnectWithoutSchoolInput[]
    createMany?: TeacherClassSubjectCreateManySchoolInputEnvelope
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
  }

  export type TrainerClassModuleUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TrainerClassModuleCreateWithoutSchoolInput, TrainerClassModuleUncheckedCreateWithoutSchoolInput> | TrainerClassModuleCreateWithoutSchoolInput[] | TrainerClassModuleUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutSchoolInput | TrainerClassModuleCreateOrConnectWithoutSchoolInput[]
    createMany?: TrainerClassModuleCreateManySchoolInputEnvelope
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutSchoolInput | SubjectUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutSchoolInput | SubjectUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutSchoolInput | SubjectUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ModuleCreateWithoutSchoolInput, ModuleUncheckedCreateWithoutSchoolInput> | ModuleCreateWithoutSchoolInput[] | ModuleUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutSchoolInput | ModuleCreateOrConnectWithoutSchoolInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutSchoolInput | ModuleUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ModuleCreateManySchoolInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutSchoolInput | ModuleUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutSchoolInput | ModuleUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type TimeSlotUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TimeSlotCreateWithoutSchoolInput, TimeSlotUncheckedCreateWithoutSchoolInput> | TimeSlotCreateWithoutSchoolInput[] | TimeSlotUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutSchoolInput | TimeSlotCreateOrConnectWithoutSchoolInput[]
    upsert?: TimeSlotUpsertWithWhereUniqueWithoutSchoolInput | TimeSlotUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TimeSlotCreateManySchoolInputEnvelope
    set?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    disconnect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    delete?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    update?: TimeSlotUpdateWithWhereUniqueWithoutSchoolInput | TimeSlotUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TimeSlotUpdateManyWithWhereWithoutSchoolInput | TimeSlotUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
  }

  export type TimetableUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TimetableCreateWithoutSchoolInput, TimetableUncheckedCreateWithoutSchoolInput> | TimetableCreateWithoutSchoolInput[] | TimetableUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutSchoolInput | TimetableCreateOrConnectWithoutSchoolInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutSchoolInput | TimetableUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TimetableCreateManySchoolInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutSchoolInput | TimetableUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutSchoolInput | TimetableUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type TeacherClassSubjectUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutSchoolInput, TeacherClassSubjectUncheckedCreateWithoutSchoolInput> | TeacherClassSubjectCreateWithoutSchoolInput[] | TeacherClassSubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutSchoolInput | TeacherClassSubjectCreateOrConnectWithoutSchoolInput[]
    upsert?: TeacherClassSubjectUpsertWithWhereUniqueWithoutSchoolInput | TeacherClassSubjectUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TeacherClassSubjectCreateManySchoolInputEnvelope
    set?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    disconnect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    delete?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    update?: TeacherClassSubjectUpdateWithWhereUniqueWithoutSchoolInput | TeacherClassSubjectUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TeacherClassSubjectUpdateManyWithWhereWithoutSchoolInput | TeacherClassSubjectUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TeacherClassSubjectScalarWhereInput | TeacherClassSubjectScalarWhereInput[]
  }

  export type TrainerClassModuleUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TrainerClassModuleCreateWithoutSchoolInput, TrainerClassModuleUncheckedCreateWithoutSchoolInput> | TrainerClassModuleCreateWithoutSchoolInput[] | TrainerClassModuleUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutSchoolInput | TrainerClassModuleCreateOrConnectWithoutSchoolInput[]
    upsert?: TrainerClassModuleUpsertWithWhereUniqueWithoutSchoolInput | TrainerClassModuleUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TrainerClassModuleCreateManySchoolInputEnvelope
    set?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    disconnect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    delete?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    update?: TrainerClassModuleUpdateWithWhereUniqueWithoutSchoolInput | TrainerClassModuleUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TrainerClassModuleUpdateManyWithWhereWithoutSchoolInput | TrainerClassModuleUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TrainerClassModuleScalarWhereInput | TrainerClassModuleScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput> | SubjectCreateWithoutSchoolInput[] | SubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutSchoolInput | SubjectCreateOrConnectWithoutSchoolInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutSchoolInput | SubjectUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: SubjectCreateManySchoolInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutSchoolInput | SubjectUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutSchoolInput | SubjectUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ModuleCreateWithoutSchoolInput, ModuleUncheckedCreateWithoutSchoolInput> | ModuleCreateWithoutSchoolInput[] | ModuleUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutSchoolInput | ModuleCreateOrConnectWithoutSchoolInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutSchoolInput | ModuleUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ModuleCreateManySchoolInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutSchoolInput | ModuleUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutSchoolInput | ModuleUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type TimeSlotUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TimeSlotCreateWithoutSchoolInput, TimeSlotUncheckedCreateWithoutSchoolInput> | TimeSlotCreateWithoutSchoolInput[] | TimeSlotUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutSchoolInput | TimeSlotCreateOrConnectWithoutSchoolInput[]
    upsert?: TimeSlotUpsertWithWhereUniqueWithoutSchoolInput | TimeSlotUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TimeSlotCreateManySchoolInputEnvelope
    set?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    disconnect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    delete?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    update?: TimeSlotUpdateWithWhereUniqueWithoutSchoolInput | TimeSlotUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TimeSlotUpdateManyWithWhereWithoutSchoolInput | TimeSlotUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
  }

  export type TimetableUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TimetableCreateWithoutSchoolInput, TimetableUncheckedCreateWithoutSchoolInput> | TimetableCreateWithoutSchoolInput[] | TimetableUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutSchoolInput | TimetableCreateOrConnectWithoutSchoolInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutSchoolInput | TimetableUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TimetableCreateManySchoolInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutSchoolInput | TimetableUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutSchoolInput | TimetableUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type TeacherClassSubjectUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutSchoolInput, TeacherClassSubjectUncheckedCreateWithoutSchoolInput> | TeacherClassSubjectCreateWithoutSchoolInput[] | TeacherClassSubjectUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutSchoolInput | TeacherClassSubjectCreateOrConnectWithoutSchoolInput[]
    upsert?: TeacherClassSubjectUpsertWithWhereUniqueWithoutSchoolInput | TeacherClassSubjectUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TeacherClassSubjectCreateManySchoolInputEnvelope
    set?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    disconnect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    delete?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    update?: TeacherClassSubjectUpdateWithWhereUniqueWithoutSchoolInput | TeacherClassSubjectUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TeacherClassSubjectUpdateManyWithWhereWithoutSchoolInput | TeacherClassSubjectUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TeacherClassSubjectScalarWhereInput | TeacherClassSubjectScalarWhereInput[]
  }

  export type TrainerClassModuleUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TrainerClassModuleCreateWithoutSchoolInput, TrainerClassModuleUncheckedCreateWithoutSchoolInput> | TrainerClassModuleCreateWithoutSchoolInput[] | TrainerClassModuleUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutSchoolInput | TrainerClassModuleCreateOrConnectWithoutSchoolInput[]
    upsert?: TrainerClassModuleUpsertWithWhereUniqueWithoutSchoolInput | TrainerClassModuleUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TrainerClassModuleCreateManySchoolInputEnvelope
    set?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    disconnect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    delete?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    update?: TrainerClassModuleUpdateWithWhereUniqueWithoutSchoolInput | TrainerClassModuleUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TrainerClassModuleUpdateManyWithWhereWithoutSchoolInput | TrainerClassModuleUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TrainerClassModuleScalarWhereInput | TrainerClassModuleScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutClassesInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    connect?: SchoolWhereUniqueInput
  }

  export type ClassSubjectCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type TimetableCreateNestedManyWithoutClassInput = {
    create?: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput> | TimetableCreateWithoutClassInput[] | TimetableUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutClassInput | TimetableCreateOrConnectWithoutClassInput[]
    createMany?: TimetableCreateManyClassInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type TeacherClassSubjectCreateNestedManyWithoutClassInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutClassInput, TeacherClassSubjectUncheckedCreateWithoutClassInput> | TeacherClassSubjectCreateWithoutClassInput[] | TeacherClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutClassInput | TeacherClassSubjectCreateOrConnectWithoutClassInput[]
    createMany?: TeacherClassSubjectCreateManyClassInputEnvelope
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
  }

  export type TrainerClassModuleCreateNestedManyWithoutClassInput = {
    create?: XOR<TrainerClassModuleCreateWithoutClassInput, TrainerClassModuleUncheckedCreateWithoutClassInput> | TrainerClassModuleCreateWithoutClassInput[] | TrainerClassModuleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutClassInput | TrainerClassModuleCreateOrConnectWithoutClassInput[]
    createMany?: TrainerClassModuleCreateManyClassInputEnvelope
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
  }

  export type ClassSubjectUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type TimetableUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput> | TimetableCreateWithoutClassInput[] | TimetableUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutClassInput | TimetableCreateOrConnectWithoutClassInput[]
    createMany?: TimetableCreateManyClassInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type TeacherClassSubjectUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutClassInput, TeacherClassSubjectUncheckedCreateWithoutClassInput> | TeacherClassSubjectCreateWithoutClassInput[] | TeacherClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutClassInput | TeacherClassSubjectCreateOrConnectWithoutClassInput[]
    createMany?: TeacherClassSubjectCreateManyClassInputEnvelope
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
  }

  export type TrainerClassModuleUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<TrainerClassModuleCreateWithoutClassInput, TrainerClassModuleUncheckedCreateWithoutClassInput> | TrainerClassModuleCreateWithoutClassInput[] | TrainerClassModuleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutClassInput | TrainerClassModuleCreateOrConnectWithoutClassInput[]
    createMany?: TrainerClassModuleCreateManyClassInputEnvelope
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    upsert?: SchoolUpsertWithoutClassesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutClassesInput, SchoolUpdateWithoutClassesInput>, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type ClassSubjectUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutClassInput | ClassSubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutClassInput | ClassSubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutClassInput | ClassSubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type TimetableUpdateManyWithoutClassNestedInput = {
    create?: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput> | TimetableCreateWithoutClassInput[] | TimetableUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutClassInput | TimetableCreateOrConnectWithoutClassInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutClassInput | TimetableUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TimetableCreateManyClassInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutClassInput | TimetableUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutClassInput | TimetableUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type TeacherClassSubjectUpdateManyWithoutClassNestedInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutClassInput, TeacherClassSubjectUncheckedCreateWithoutClassInput> | TeacherClassSubjectCreateWithoutClassInput[] | TeacherClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutClassInput | TeacherClassSubjectCreateOrConnectWithoutClassInput[]
    upsert?: TeacherClassSubjectUpsertWithWhereUniqueWithoutClassInput | TeacherClassSubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TeacherClassSubjectCreateManyClassInputEnvelope
    set?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    disconnect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    delete?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    update?: TeacherClassSubjectUpdateWithWhereUniqueWithoutClassInput | TeacherClassSubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TeacherClassSubjectUpdateManyWithWhereWithoutClassInput | TeacherClassSubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TeacherClassSubjectScalarWhereInput | TeacherClassSubjectScalarWhereInput[]
  }

  export type TrainerClassModuleUpdateManyWithoutClassNestedInput = {
    create?: XOR<TrainerClassModuleCreateWithoutClassInput, TrainerClassModuleUncheckedCreateWithoutClassInput> | TrainerClassModuleCreateWithoutClassInput[] | TrainerClassModuleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutClassInput | TrainerClassModuleCreateOrConnectWithoutClassInput[]
    upsert?: TrainerClassModuleUpsertWithWhereUniqueWithoutClassInput | TrainerClassModuleUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TrainerClassModuleCreateManyClassInputEnvelope
    set?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    disconnect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    delete?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    update?: TrainerClassModuleUpdateWithWhereUniqueWithoutClassInput | TrainerClassModuleUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TrainerClassModuleUpdateManyWithWhereWithoutClassInput | TrainerClassModuleUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TrainerClassModuleScalarWhereInput | TrainerClassModuleScalarWhereInput[]
  }

  export type ClassSubjectUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutClassInput | ClassSubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutClassInput | ClassSubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutClassInput | ClassSubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type TimetableUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput> | TimetableCreateWithoutClassInput[] | TimetableUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutClassInput | TimetableCreateOrConnectWithoutClassInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutClassInput | TimetableUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TimetableCreateManyClassInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutClassInput | TimetableUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutClassInput | TimetableUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type TeacherClassSubjectUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutClassInput, TeacherClassSubjectUncheckedCreateWithoutClassInput> | TeacherClassSubjectCreateWithoutClassInput[] | TeacherClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutClassInput | TeacherClassSubjectCreateOrConnectWithoutClassInput[]
    upsert?: TeacherClassSubjectUpsertWithWhereUniqueWithoutClassInput | TeacherClassSubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TeacherClassSubjectCreateManyClassInputEnvelope
    set?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    disconnect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    delete?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    update?: TeacherClassSubjectUpdateWithWhereUniqueWithoutClassInput | TeacherClassSubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TeacherClassSubjectUpdateManyWithWhereWithoutClassInput | TeacherClassSubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TeacherClassSubjectScalarWhereInput | TeacherClassSubjectScalarWhereInput[]
  }

  export type TrainerClassModuleUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<TrainerClassModuleCreateWithoutClassInput, TrainerClassModuleUncheckedCreateWithoutClassInput> | TrainerClassModuleCreateWithoutClassInput[] | TrainerClassModuleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutClassInput | TrainerClassModuleCreateOrConnectWithoutClassInput[]
    upsert?: TrainerClassModuleUpsertWithWhereUniqueWithoutClassInput | TrainerClassModuleUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TrainerClassModuleCreateManyClassInputEnvelope
    set?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    disconnect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    delete?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    update?: TrainerClassModuleUpdateWithWhereUniqueWithoutClassInput | TrainerClassModuleUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TrainerClassModuleUpdateManyWithWhereWithoutClassInput | TrainerClassModuleUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TrainerClassModuleScalarWhereInput | TrainerClassModuleScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSubjectsInput
    connect?: SchoolWhereUniqueInput
  }

  export type TeacherSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type ClassSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type TimetableCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TimetableCreateWithoutSubjectInput, TimetableUncheckedCreateWithoutSubjectInput> | TimetableCreateWithoutSubjectInput[] | TimetableUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutSubjectInput | TimetableCreateOrConnectWithoutSubjectInput[]
    createMany?: TimetableCreateManySubjectInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type TeacherClassSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutSubjectInput, TeacherClassSubjectUncheckedCreateWithoutSubjectInput> | TeacherClassSubjectCreateWithoutSubjectInput[] | TeacherClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutSubjectInput | TeacherClassSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherClassSubjectCreateManySubjectInputEnvelope
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
  }

  export type TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type TimetableUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TimetableCreateWithoutSubjectInput, TimetableUncheckedCreateWithoutSubjectInput> | TimetableCreateWithoutSubjectInput[] | TimetableUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutSubjectInput | TimetableCreateOrConnectWithoutSubjectInput[]
    createMany?: TimetableCreateManySubjectInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type TeacherClassSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutSubjectInput, TeacherClassSubjectUncheckedCreateWithoutSubjectInput> | TeacherClassSubjectCreateWithoutSubjectInput[] | TeacherClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutSubjectInput | TeacherClassSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherClassSubjectCreateManySubjectInputEnvelope
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SchoolUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSubjectsInput
    upsert?: SchoolUpsertWithoutSubjectsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSubjectsInput, SchoolUpdateWithoutSubjectsInput>, SchoolUncheckedUpdateWithoutSubjectsInput>
  }

  export type TeacherSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutSubjectInput | TeacherSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type ClassSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput | ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput | ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutSubjectInput | ClassSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type TimetableUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TimetableCreateWithoutSubjectInput, TimetableUncheckedCreateWithoutSubjectInput> | TimetableCreateWithoutSubjectInput[] | TimetableUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutSubjectInput | TimetableCreateOrConnectWithoutSubjectInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutSubjectInput | TimetableUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TimetableCreateManySubjectInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutSubjectInput | TimetableUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutSubjectInput | TimetableUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type TeacherClassSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutSubjectInput, TeacherClassSubjectUncheckedCreateWithoutSubjectInput> | TeacherClassSubjectCreateWithoutSubjectInput[] | TeacherClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutSubjectInput | TeacherClassSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherClassSubjectUpsertWithWhereUniqueWithoutSubjectInput | TeacherClassSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherClassSubjectCreateManySubjectInputEnvelope
    set?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    disconnect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    delete?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    update?: TeacherClassSubjectUpdateWithWhereUniqueWithoutSubjectInput | TeacherClassSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherClassSubjectUpdateManyWithWhereWithoutSubjectInput | TeacherClassSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherClassSubjectScalarWhereInput | TeacherClassSubjectScalarWhereInput[]
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutSubjectInput | TeacherSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput | ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput | ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutSubjectInput | ClassSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type TimetableUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TimetableCreateWithoutSubjectInput, TimetableUncheckedCreateWithoutSubjectInput> | TimetableCreateWithoutSubjectInput[] | TimetableUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutSubjectInput | TimetableCreateOrConnectWithoutSubjectInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutSubjectInput | TimetableUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TimetableCreateManySubjectInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutSubjectInput | TimetableUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutSubjectInput | TimetableUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type TeacherClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherClassSubjectCreateWithoutSubjectInput, TeacherClassSubjectUncheckedCreateWithoutSubjectInput> | TeacherClassSubjectCreateWithoutSubjectInput[] | TeacherClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherClassSubjectCreateOrConnectWithoutSubjectInput | TeacherClassSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherClassSubjectUpsertWithWhereUniqueWithoutSubjectInput | TeacherClassSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherClassSubjectCreateManySubjectInputEnvelope
    set?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    disconnect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    delete?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    connect?: TeacherClassSubjectWhereUniqueInput | TeacherClassSubjectWhereUniqueInput[]
    update?: TeacherClassSubjectUpdateWithWhereUniqueWithoutSubjectInput | TeacherClassSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherClassSubjectUpdateManyWithWhereWithoutSubjectInput | TeacherClassSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherClassSubjectScalarWhereInput | TeacherClassSubjectScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutModulesInput = {
    create?: XOR<SchoolCreateWithoutModulesInput, SchoolUncheckedCreateWithoutModulesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutModulesInput
    connect?: SchoolWhereUniqueInput
  }

  export type TrainerModuleCreateNestedManyWithoutModuleInput = {
    create?: XOR<TrainerModuleCreateWithoutModuleInput, TrainerModuleUncheckedCreateWithoutModuleInput> | TrainerModuleCreateWithoutModuleInput[] | TrainerModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TrainerModuleCreateOrConnectWithoutModuleInput | TrainerModuleCreateOrConnectWithoutModuleInput[]
    createMany?: TrainerModuleCreateManyModuleInputEnvelope
    connect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
  }

  export type TimetableCreateNestedManyWithoutModuleInput = {
    create?: XOR<TimetableCreateWithoutModuleInput, TimetableUncheckedCreateWithoutModuleInput> | TimetableCreateWithoutModuleInput[] | TimetableUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutModuleInput | TimetableCreateOrConnectWithoutModuleInput[]
    createMany?: TimetableCreateManyModuleInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type TrainerClassModuleCreateNestedManyWithoutModuleInput = {
    create?: XOR<TrainerClassModuleCreateWithoutModuleInput, TrainerClassModuleUncheckedCreateWithoutModuleInput> | TrainerClassModuleCreateWithoutModuleInput[] | TrainerClassModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutModuleInput | TrainerClassModuleCreateOrConnectWithoutModuleInput[]
    createMany?: TrainerClassModuleCreateManyModuleInputEnvelope
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
  }

  export type TrainerModuleUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<TrainerModuleCreateWithoutModuleInput, TrainerModuleUncheckedCreateWithoutModuleInput> | TrainerModuleCreateWithoutModuleInput[] | TrainerModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TrainerModuleCreateOrConnectWithoutModuleInput | TrainerModuleCreateOrConnectWithoutModuleInput[]
    createMany?: TrainerModuleCreateManyModuleInputEnvelope
    connect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
  }

  export type TimetableUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<TimetableCreateWithoutModuleInput, TimetableUncheckedCreateWithoutModuleInput> | TimetableCreateWithoutModuleInput[] | TimetableUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutModuleInput | TimetableCreateOrConnectWithoutModuleInput[]
    createMany?: TimetableCreateManyModuleInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type TrainerClassModuleUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<TrainerClassModuleCreateWithoutModuleInput, TrainerClassModuleUncheckedCreateWithoutModuleInput> | TrainerClassModuleCreateWithoutModuleInput[] | TrainerClassModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutModuleInput | TrainerClassModuleCreateOrConnectWithoutModuleInput[]
    createMany?: TrainerClassModuleCreateManyModuleInputEnvelope
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<SchoolCreateWithoutModulesInput, SchoolUncheckedCreateWithoutModulesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutModulesInput
    upsert?: SchoolUpsertWithoutModulesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutModulesInput, SchoolUpdateWithoutModulesInput>, SchoolUncheckedUpdateWithoutModulesInput>
  }

  export type TrainerModuleUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TrainerModuleCreateWithoutModuleInput, TrainerModuleUncheckedCreateWithoutModuleInput> | TrainerModuleCreateWithoutModuleInput[] | TrainerModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TrainerModuleCreateOrConnectWithoutModuleInput | TrainerModuleCreateOrConnectWithoutModuleInput[]
    upsert?: TrainerModuleUpsertWithWhereUniqueWithoutModuleInput | TrainerModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TrainerModuleCreateManyModuleInputEnvelope
    set?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    disconnect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    delete?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    connect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    update?: TrainerModuleUpdateWithWhereUniqueWithoutModuleInput | TrainerModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TrainerModuleUpdateManyWithWhereWithoutModuleInput | TrainerModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TrainerModuleScalarWhereInput | TrainerModuleScalarWhereInput[]
  }

  export type TimetableUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TimetableCreateWithoutModuleInput, TimetableUncheckedCreateWithoutModuleInput> | TimetableCreateWithoutModuleInput[] | TimetableUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutModuleInput | TimetableCreateOrConnectWithoutModuleInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutModuleInput | TimetableUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TimetableCreateManyModuleInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutModuleInput | TimetableUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutModuleInput | TimetableUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type TrainerClassModuleUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TrainerClassModuleCreateWithoutModuleInput, TrainerClassModuleUncheckedCreateWithoutModuleInput> | TrainerClassModuleCreateWithoutModuleInput[] | TrainerClassModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutModuleInput | TrainerClassModuleCreateOrConnectWithoutModuleInput[]
    upsert?: TrainerClassModuleUpsertWithWhereUniqueWithoutModuleInput | TrainerClassModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TrainerClassModuleCreateManyModuleInputEnvelope
    set?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    disconnect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    delete?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    update?: TrainerClassModuleUpdateWithWhereUniqueWithoutModuleInput | TrainerClassModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TrainerClassModuleUpdateManyWithWhereWithoutModuleInput | TrainerClassModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TrainerClassModuleScalarWhereInput | TrainerClassModuleScalarWhereInput[]
  }

  export type TrainerModuleUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TrainerModuleCreateWithoutModuleInput, TrainerModuleUncheckedCreateWithoutModuleInput> | TrainerModuleCreateWithoutModuleInput[] | TrainerModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TrainerModuleCreateOrConnectWithoutModuleInput | TrainerModuleCreateOrConnectWithoutModuleInput[]
    upsert?: TrainerModuleUpsertWithWhereUniqueWithoutModuleInput | TrainerModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TrainerModuleCreateManyModuleInputEnvelope
    set?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    disconnect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    delete?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    connect?: TrainerModuleWhereUniqueInput | TrainerModuleWhereUniqueInput[]
    update?: TrainerModuleUpdateWithWhereUniqueWithoutModuleInput | TrainerModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TrainerModuleUpdateManyWithWhereWithoutModuleInput | TrainerModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TrainerModuleScalarWhereInput | TrainerModuleScalarWhereInput[]
  }

  export type TimetableUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TimetableCreateWithoutModuleInput, TimetableUncheckedCreateWithoutModuleInput> | TimetableCreateWithoutModuleInput[] | TimetableUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutModuleInput | TimetableCreateOrConnectWithoutModuleInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutModuleInput | TimetableUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TimetableCreateManyModuleInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutModuleInput | TimetableUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutModuleInput | TimetableUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type TrainerClassModuleUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<TrainerClassModuleCreateWithoutModuleInput, TrainerClassModuleUncheckedCreateWithoutModuleInput> | TrainerClassModuleCreateWithoutModuleInput[] | TrainerClassModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: TrainerClassModuleCreateOrConnectWithoutModuleInput | TrainerClassModuleCreateOrConnectWithoutModuleInput[]
    upsert?: TrainerClassModuleUpsertWithWhereUniqueWithoutModuleInput | TrainerClassModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: TrainerClassModuleCreateManyModuleInputEnvelope
    set?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    disconnect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    delete?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    connect?: TrainerClassModuleWhereUniqueInput | TrainerClassModuleWhereUniqueInput[]
    update?: TrainerClassModuleUpdateWithWhereUniqueWithoutModuleInput | TrainerClassModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: TrainerClassModuleUpdateManyWithWhereWithoutModuleInput | TrainerClassModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: TrainerClassModuleScalarWhereInput | TrainerClassModuleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTeacherSubjectsInput = {
    create?: XOR<UserCreateWithoutTeacherSubjectsInput, UserUncheckedCreateWithoutTeacherSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherSubjectsInput
    connect?: UserWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutTeachersInput = {
    create?: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeachersInput
    connect?: SubjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTeacherSubjectsNestedInput = {
    create?: XOR<UserCreateWithoutTeacherSubjectsInput, UserUncheckedCreateWithoutTeacherSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherSubjectsInput
    upsert?: UserUpsertWithoutTeacherSubjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherSubjectsInput, UserUpdateWithoutTeacherSubjectsInput>, UserUncheckedUpdateWithoutTeacherSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeachersInput
    upsert?: SubjectUpsertWithoutTeachersInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutTeachersInput, SubjectUpdateWithoutTeachersInput>, SubjectUncheckedUpdateWithoutTeachersInput>
  }

  export type UserCreateNestedOneWithoutTrainerModulesInput = {
    create?: XOR<UserCreateWithoutTrainerModulesInput, UserUncheckedCreateWithoutTrainerModulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainerModulesInput
    connect?: UserWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutTrainersInput = {
    create?: XOR<ModuleCreateWithoutTrainersInput, ModuleUncheckedCreateWithoutTrainersInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTrainersInput
    connect?: ModuleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTrainerModulesNestedInput = {
    create?: XOR<UserCreateWithoutTrainerModulesInput, UserUncheckedCreateWithoutTrainerModulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainerModulesInput
    upsert?: UserUpsertWithoutTrainerModulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrainerModulesInput, UserUpdateWithoutTrainerModulesInput>, UserUncheckedUpdateWithoutTrainerModulesInput>
  }

  export type ModuleUpdateOneRequiredWithoutTrainersNestedInput = {
    create?: XOR<ModuleCreateWithoutTrainersInput, ModuleUncheckedCreateWithoutTrainersInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTrainersInput
    upsert?: ModuleUpsertWithoutTrainersInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutTrainersInput, ModuleUpdateWithoutTrainersInput>, ModuleUncheckedUpdateWithoutTrainersInput>
  }

  export type ClassCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectsInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutClassSubjectsInput = {
    create?: XOR<SubjectCreateWithoutClassSubjectsInput, SubjectUncheckedCreateWithoutClassSubjectsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutClassSubjectsInput
    connect?: SubjectWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectsInput
    upsert?: ClassUpsertWithoutSubjectsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSubjectsInput, ClassUpdateWithoutSubjectsInput>, ClassUncheckedUpdateWithoutSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutClassSubjectsNestedInput = {
    create?: XOR<SubjectCreateWithoutClassSubjectsInput, SubjectUncheckedCreateWithoutClassSubjectsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutClassSubjectsInput
    upsert?: SubjectUpsertWithoutClassSubjectsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutClassSubjectsInput, SubjectUpdateWithoutClassSubjectsInput>, SubjectUncheckedUpdateWithoutClassSubjectsInput>
  }

  export type SchoolCreateNestedOneWithoutTimeSlotsInput = {
    create?: XOR<SchoolCreateWithoutTimeSlotsInput, SchoolUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTimeSlotsInput
    connect?: SchoolWhereUniqueInput
  }

  export type TimetableCreateNestedManyWithoutTimeSlotInput = {
    create?: XOR<TimetableCreateWithoutTimeSlotInput, TimetableUncheckedCreateWithoutTimeSlotInput> | TimetableCreateWithoutTimeSlotInput[] | TimetableUncheckedCreateWithoutTimeSlotInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTimeSlotInput | TimetableCreateOrConnectWithoutTimeSlotInput[]
    createMany?: TimetableCreateManyTimeSlotInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type TimetableUncheckedCreateNestedManyWithoutTimeSlotInput = {
    create?: XOR<TimetableCreateWithoutTimeSlotInput, TimetableUncheckedCreateWithoutTimeSlotInput> | TimetableCreateWithoutTimeSlotInput[] | TimetableUncheckedCreateWithoutTimeSlotInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTimeSlotInput | TimetableCreateOrConnectWithoutTimeSlotInput[]
    createMany?: TimetableCreateManyTimeSlotInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutTimeSlotsNestedInput = {
    create?: XOR<SchoolCreateWithoutTimeSlotsInput, SchoolUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTimeSlotsInput
    upsert?: SchoolUpsertWithoutTimeSlotsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTimeSlotsInput, SchoolUpdateWithoutTimeSlotsInput>, SchoolUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type TimetableUpdateManyWithoutTimeSlotNestedInput = {
    create?: XOR<TimetableCreateWithoutTimeSlotInput, TimetableUncheckedCreateWithoutTimeSlotInput> | TimetableCreateWithoutTimeSlotInput[] | TimetableUncheckedCreateWithoutTimeSlotInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTimeSlotInput | TimetableCreateOrConnectWithoutTimeSlotInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutTimeSlotInput | TimetableUpsertWithWhereUniqueWithoutTimeSlotInput[]
    createMany?: TimetableCreateManyTimeSlotInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutTimeSlotInput | TimetableUpdateWithWhereUniqueWithoutTimeSlotInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutTimeSlotInput | TimetableUpdateManyWithWhereWithoutTimeSlotInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type TimetableUncheckedUpdateManyWithoutTimeSlotNestedInput = {
    create?: XOR<TimetableCreateWithoutTimeSlotInput, TimetableUncheckedCreateWithoutTimeSlotInput> | TimetableCreateWithoutTimeSlotInput[] | TimetableUncheckedCreateWithoutTimeSlotInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTimeSlotInput | TimetableCreateOrConnectWithoutTimeSlotInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutTimeSlotInput | TimetableUpsertWithWhereUniqueWithoutTimeSlotInput[]
    createMany?: TimetableCreateManyTimeSlotInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutTimeSlotInput | TimetableUpdateWithWhereUniqueWithoutTimeSlotInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutTimeSlotInput | TimetableUpdateManyWithWhereWithoutTimeSlotInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutTimetablesInput = {
    create?: XOR<SchoolCreateWithoutTimetablesInput, SchoolUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTimetablesInput
    connect?: SchoolWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutTimetablesInput = {
    create?: XOR<ClassCreateWithoutTimetablesInput, ClassUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTimetablesInput
    connect?: ClassWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTimetablesAsTeacherInput = {
    create?: XOR<UserCreateWithoutTimetablesAsTeacherInput, UserUncheckedCreateWithoutTimetablesAsTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimetablesAsTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutTimetablesInput = {
    create?: XOR<SubjectCreateWithoutTimetablesInput, SubjectUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTimetablesInput
    connect?: SubjectWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutTimetablesInput = {
    create?: XOR<ModuleCreateWithoutTimetablesInput, ModuleUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTimetablesInput
    connect?: ModuleWhereUniqueInput
  }

  export type TimeSlotCreateNestedOneWithoutTimetablesInput = {
    create?: XOR<TimeSlotCreateWithoutTimetablesInput, TimeSlotUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: TimeSlotCreateOrConnectWithoutTimetablesInput
    connect?: TimeSlotWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutTimetablesNestedInput = {
    create?: XOR<SchoolCreateWithoutTimetablesInput, SchoolUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTimetablesInput
    upsert?: SchoolUpsertWithoutTimetablesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTimetablesInput, SchoolUpdateWithoutTimetablesInput>, SchoolUncheckedUpdateWithoutTimetablesInput>
  }

  export type ClassUpdateOneRequiredWithoutTimetablesNestedInput = {
    create?: XOR<ClassCreateWithoutTimetablesInput, ClassUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTimetablesInput
    upsert?: ClassUpsertWithoutTimetablesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutTimetablesInput, ClassUpdateWithoutTimetablesInput>, ClassUncheckedUpdateWithoutTimetablesInput>
  }

  export type UserUpdateOneRequiredWithoutTimetablesAsTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTimetablesAsTeacherInput, UserUncheckedCreateWithoutTimetablesAsTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimetablesAsTeacherInput
    upsert?: UserUpsertWithoutTimetablesAsTeacherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimetablesAsTeacherInput, UserUpdateWithoutTimetablesAsTeacherInput>, UserUncheckedUpdateWithoutTimetablesAsTeacherInput>
  }

  export type SubjectUpdateOneWithoutTimetablesNestedInput = {
    create?: XOR<SubjectCreateWithoutTimetablesInput, SubjectUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTimetablesInput
    upsert?: SubjectUpsertWithoutTimetablesInput
    disconnect?: SubjectWhereInput | boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutTimetablesInput, SubjectUpdateWithoutTimetablesInput>, SubjectUncheckedUpdateWithoutTimetablesInput>
  }

  export type ModuleUpdateOneWithoutTimetablesNestedInput = {
    create?: XOR<ModuleCreateWithoutTimetablesInput, ModuleUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTimetablesInput
    upsert?: ModuleUpsertWithoutTimetablesInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutTimetablesInput, ModuleUpdateWithoutTimetablesInput>, ModuleUncheckedUpdateWithoutTimetablesInput>
  }

  export type TimeSlotUpdateOneRequiredWithoutTimetablesNestedInput = {
    create?: XOR<TimeSlotCreateWithoutTimetablesInput, TimeSlotUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: TimeSlotCreateOrConnectWithoutTimetablesInput
    upsert?: TimeSlotUpsertWithoutTimetablesInput
    connect?: TimeSlotWhereUniqueInput
    update?: XOR<XOR<TimeSlotUpdateToOneWithWhereWithoutTimetablesInput, TimeSlotUpdateWithoutTimetablesInput>, TimeSlotUncheckedUpdateWithoutTimetablesInput>
  }

  export type UserCreateNestedOneWithoutTeacherClassSubjectsInput = {
    create?: XOR<UserCreateWithoutTeacherClassSubjectsInput, UserUncheckedCreateWithoutTeacherClassSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherClassSubjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutTeacherClassSubjectsInput = {
    create?: XOR<ClassCreateWithoutTeacherClassSubjectsInput, ClassUncheckedCreateWithoutTeacherClassSubjectsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherClassSubjectsInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutTeacherClassSubjectsInput = {
    create?: XOR<SubjectCreateWithoutTeacherClassSubjectsInput, SubjectUncheckedCreateWithoutTeacherClassSubjectsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeacherClassSubjectsInput
    connect?: SubjectWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutTeacherClassSubjectsInput = {
    create?: XOR<SchoolCreateWithoutTeacherClassSubjectsInput, SchoolUncheckedCreateWithoutTeacherClassSubjectsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTeacherClassSubjectsInput
    connect?: SchoolWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput = {
    create?: XOR<UserCreateWithoutTeacherClassSubjectsInput, UserUncheckedCreateWithoutTeacherClassSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherClassSubjectsInput
    upsert?: UserUpsertWithoutTeacherClassSubjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherClassSubjectsInput, UserUpdateWithoutTeacherClassSubjectsInput>, UserUncheckedUpdateWithoutTeacherClassSubjectsInput>
  }

  export type ClassUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput = {
    create?: XOR<ClassCreateWithoutTeacherClassSubjectsInput, ClassUncheckedCreateWithoutTeacherClassSubjectsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTeacherClassSubjectsInput
    upsert?: ClassUpsertWithoutTeacherClassSubjectsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutTeacherClassSubjectsInput, ClassUpdateWithoutTeacherClassSubjectsInput>, ClassUncheckedUpdateWithoutTeacherClassSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput = {
    create?: XOR<SubjectCreateWithoutTeacherClassSubjectsInput, SubjectUncheckedCreateWithoutTeacherClassSubjectsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeacherClassSubjectsInput
    upsert?: SubjectUpsertWithoutTeacherClassSubjectsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutTeacherClassSubjectsInput, SubjectUpdateWithoutTeacherClassSubjectsInput>, SubjectUncheckedUpdateWithoutTeacherClassSubjectsInput>
  }

  export type SchoolUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput = {
    create?: XOR<SchoolCreateWithoutTeacherClassSubjectsInput, SchoolUncheckedCreateWithoutTeacherClassSubjectsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTeacherClassSubjectsInput
    upsert?: SchoolUpsertWithoutTeacherClassSubjectsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTeacherClassSubjectsInput, SchoolUpdateWithoutTeacherClassSubjectsInput>, SchoolUncheckedUpdateWithoutTeacherClassSubjectsInput>
  }

  export type UserCreateNestedOneWithoutTrainerClassModulesInput = {
    create?: XOR<UserCreateWithoutTrainerClassModulesInput, UserUncheckedCreateWithoutTrainerClassModulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainerClassModulesInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutTrainerClassModulesInput = {
    create?: XOR<ClassCreateWithoutTrainerClassModulesInput, ClassUncheckedCreateWithoutTrainerClassModulesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTrainerClassModulesInput
    connect?: ClassWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutTrainerClassModulesInput = {
    create?: XOR<ModuleCreateWithoutTrainerClassModulesInput, ModuleUncheckedCreateWithoutTrainerClassModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTrainerClassModulesInput
    connect?: ModuleWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutTrainerClassModulesInput = {
    create?: XOR<SchoolCreateWithoutTrainerClassModulesInput, SchoolUncheckedCreateWithoutTrainerClassModulesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTrainerClassModulesInput
    connect?: SchoolWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTrainerClassModulesNestedInput = {
    create?: XOR<UserCreateWithoutTrainerClassModulesInput, UserUncheckedCreateWithoutTrainerClassModulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainerClassModulesInput
    upsert?: UserUpsertWithoutTrainerClassModulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrainerClassModulesInput, UserUpdateWithoutTrainerClassModulesInput>, UserUncheckedUpdateWithoutTrainerClassModulesInput>
  }

  export type ClassUpdateOneRequiredWithoutTrainerClassModulesNestedInput = {
    create?: XOR<ClassCreateWithoutTrainerClassModulesInput, ClassUncheckedCreateWithoutTrainerClassModulesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTrainerClassModulesInput
    upsert?: ClassUpsertWithoutTrainerClassModulesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutTrainerClassModulesInput, ClassUpdateWithoutTrainerClassModulesInput>, ClassUncheckedUpdateWithoutTrainerClassModulesInput>
  }

  export type ModuleUpdateOneRequiredWithoutTrainerClassModulesNestedInput = {
    create?: XOR<ModuleCreateWithoutTrainerClassModulesInput, ModuleUncheckedCreateWithoutTrainerClassModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutTrainerClassModulesInput
    upsert?: ModuleUpsertWithoutTrainerClassModulesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutTrainerClassModulesInput, ModuleUpdateWithoutTrainerClassModulesInput>, ModuleUncheckedUpdateWithoutTrainerClassModulesInput>
  }

  export type SchoolUpdateOneRequiredWithoutTrainerClassModulesNestedInput = {
    create?: XOR<SchoolCreateWithoutTrainerClassModulesInput, SchoolUncheckedCreateWithoutTrainerClassModulesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTrainerClassModulesInput
    upsert?: SchoolUpsertWithoutTrainerClassModulesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTrainerClassModulesInput, SchoolUpdateWithoutTrainerClassModulesInput>, SchoolUncheckedUpdateWithoutTrainerClassModulesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SchoolCreateWithoutUsersInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    modules?: ModuleCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSchoolInput
    timetables?: TimetableCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    modules?: ModuleUncheckedCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSchoolInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutUsersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
  }

  export type TeacherSubjectCreateWithoutTeacherInput = {
    id?: string
    subject: SubjectCreateNestedOneWithoutTeachersInput
  }

  export type TeacherSubjectUncheckedCreateWithoutTeacherInput = {
    id?: string
    subjectId: string
  }

  export type TeacherSubjectCreateOrConnectWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    create: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherSubjectCreateManyTeacherInputEnvelope = {
    data: TeacherSubjectCreateManyTeacherInput | TeacherSubjectCreateManyTeacherInput[]
  }

  export type TrainerModuleCreateWithoutTrainerInput = {
    id?: string
    module: ModuleCreateNestedOneWithoutTrainersInput
  }

  export type TrainerModuleUncheckedCreateWithoutTrainerInput = {
    id?: string
    moduleId: string
  }

  export type TrainerModuleCreateOrConnectWithoutTrainerInput = {
    where: TrainerModuleWhereUniqueInput
    create: XOR<TrainerModuleCreateWithoutTrainerInput, TrainerModuleUncheckedCreateWithoutTrainerInput>
  }

  export type TrainerModuleCreateManyTrainerInputEnvelope = {
    data: TrainerModuleCreateManyTrainerInput | TrainerModuleCreateManyTrainerInput[]
  }

  export type TeacherClassSubjectCreateWithoutTeacherInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTeacherClassSubjectsInput
    subject: SubjectCreateNestedOneWithoutTeacherClassSubjectsInput
    school: SchoolCreateNestedOneWithoutTeacherClassSubjectsInput
  }

  export type TeacherClassSubjectUncheckedCreateWithoutTeacherInput = {
    id?: string
    classId: string
    subjectId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherClassSubjectCreateOrConnectWithoutTeacherInput = {
    where: TeacherClassSubjectWhereUniqueInput
    create: XOR<TeacherClassSubjectCreateWithoutTeacherInput, TeacherClassSubjectUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherClassSubjectCreateManyTeacherInputEnvelope = {
    data: TeacherClassSubjectCreateManyTeacherInput | TeacherClassSubjectCreateManyTeacherInput[]
  }

  export type TrainerClassModuleCreateWithoutTrainerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTrainerClassModulesInput
    module: ModuleCreateNestedOneWithoutTrainerClassModulesInput
    school: SchoolCreateNestedOneWithoutTrainerClassModulesInput
  }

  export type TrainerClassModuleUncheckedCreateWithoutTrainerInput = {
    id?: string
    classId: string
    moduleId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerClassModuleCreateOrConnectWithoutTrainerInput = {
    where: TrainerClassModuleWhereUniqueInput
    create: XOR<TrainerClassModuleCreateWithoutTrainerInput, TrainerClassModuleUncheckedCreateWithoutTrainerInput>
  }

  export type TrainerClassModuleCreateManyTrainerInputEnvelope = {
    data: TrainerClassModuleCreateManyTrainerInput | TrainerClassModuleCreateManyTrainerInput[]
  }

  export type TimetableCreateWithoutTeacherInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetablesInput
    class: ClassCreateNestedOneWithoutTimetablesInput
    subject?: SubjectCreateNestedOneWithoutTimetablesInput
    module?: ModuleCreateNestedOneWithoutTimetablesInput
    timeSlot: TimeSlotCreateNestedOneWithoutTimetablesInput
  }

  export type TimetableUncheckedCreateWithoutTeacherInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId?: string | null
    moduleId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateOrConnectWithoutTeacherInput = {
    where: TimetableWhereUniqueInput
    create: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput>
  }

  export type TimetableCreateManyTeacherInputEnvelope = {
    data: TimetableCreateManyTeacherInput | TimetableCreateManyTeacherInput[]
  }

  export type SchoolUpsertWithoutUsersInput = {
    update: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutUsersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    update: XOR<TeacherSubjectUpdateWithoutTeacherInput, TeacherSubjectUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    data: XOR<TeacherSubjectUpdateWithoutTeacherInput, TeacherSubjectUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherSubjectUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherSubjectScalarWhereInput
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherSubjectScalarWhereInput = {
    AND?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
    OR?: TeacherSubjectScalarWhereInput[]
    NOT?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
    id?: StringFilter<"TeacherSubject"> | string
    teacherId?: StringFilter<"TeacherSubject"> | string
    subjectId?: StringFilter<"TeacherSubject"> | string
  }

  export type TrainerModuleUpsertWithWhereUniqueWithoutTrainerInput = {
    where: TrainerModuleWhereUniqueInput
    update: XOR<TrainerModuleUpdateWithoutTrainerInput, TrainerModuleUncheckedUpdateWithoutTrainerInput>
    create: XOR<TrainerModuleCreateWithoutTrainerInput, TrainerModuleUncheckedCreateWithoutTrainerInput>
  }

  export type TrainerModuleUpdateWithWhereUniqueWithoutTrainerInput = {
    where: TrainerModuleWhereUniqueInput
    data: XOR<TrainerModuleUpdateWithoutTrainerInput, TrainerModuleUncheckedUpdateWithoutTrainerInput>
  }

  export type TrainerModuleUpdateManyWithWhereWithoutTrainerInput = {
    where: TrainerModuleScalarWhereInput
    data: XOR<TrainerModuleUpdateManyMutationInput, TrainerModuleUncheckedUpdateManyWithoutTrainerInput>
  }

  export type TrainerModuleScalarWhereInput = {
    AND?: TrainerModuleScalarWhereInput | TrainerModuleScalarWhereInput[]
    OR?: TrainerModuleScalarWhereInput[]
    NOT?: TrainerModuleScalarWhereInput | TrainerModuleScalarWhereInput[]
    id?: StringFilter<"TrainerModule"> | string
    trainerId?: StringFilter<"TrainerModule"> | string
    moduleId?: StringFilter<"TrainerModule"> | string
  }

  export type TeacherClassSubjectUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherClassSubjectWhereUniqueInput
    update: XOR<TeacherClassSubjectUpdateWithoutTeacherInput, TeacherClassSubjectUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherClassSubjectCreateWithoutTeacherInput, TeacherClassSubjectUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherClassSubjectUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherClassSubjectWhereUniqueInput
    data: XOR<TeacherClassSubjectUpdateWithoutTeacherInput, TeacherClassSubjectUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherClassSubjectUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherClassSubjectScalarWhereInput
    data: XOR<TeacherClassSubjectUpdateManyMutationInput, TeacherClassSubjectUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherClassSubjectScalarWhereInput = {
    AND?: TeacherClassSubjectScalarWhereInput | TeacherClassSubjectScalarWhereInput[]
    OR?: TeacherClassSubjectScalarWhereInput[]
    NOT?: TeacherClassSubjectScalarWhereInput | TeacherClassSubjectScalarWhereInput[]
    id?: StringFilter<"TeacherClassSubject"> | string
    teacherId?: StringFilter<"TeacherClassSubject"> | string
    classId?: StringFilter<"TeacherClassSubject"> | string
    subjectId?: StringFilter<"TeacherClassSubject"> | string
    schoolId?: StringFilter<"TeacherClassSubject"> | string
    createdAt?: DateTimeFilter<"TeacherClassSubject"> | Date | string
    updatedAt?: DateTimeFilter<"TeacherClassSubject"> | Date | string
  }

  export type TrainerClassModuleUpsertWithWhereUniqueWithoutTrainerInput = {
    where: TrainerClassModuleWhereUniqueInput
    update: XOR<TrainerClassModuleUpdateWithoutTrainerInput, TrainerClassModuleUncheckedUpdateWithoutTrainerInput>
    create: XOR<TrainerClassModuleCreateWithoutTrainerInput, TrainerClassModuleUncheckedCreateWithoutTrainerInput>
  }

  export type TrainerClassModuleUpdateWithWhereUniqueWithoutTrainerInput = {
    where: TrainerClassModuleWhereUniqueInput
    data: XOR<TrainerClassModuleUpdateWithoutTrainerInput, TrainerClassModuleUncheckedUpdateWithoutTrainerInput>
  }

  export type TrainerClassModuleUpdateManyWithWhereWithoutTrainerInput = {
    where: TrainerClassModuleScalarWhereInput
    data: XOR<TrainerClassModuleUpdateManyMutationInput, TrainerClassModuleUncheckedUpdateManyWithoutTrainerInput>
  }

  export type TrainerClassModuleScalarWhereInput = {
    AND?: TrainerClassModuleScalarWhereInput | TrainerClassModuleScalarWhereInput[]
    OR?: TrainerClassModuleScalarWhereInput[]
    NOT?: TrainerClassModuleScalarWhereInput | TrainerClassModuleScalarWhereInput[]
    id?: StringFilter<"TrainerClassModule"> | string
    trainerId?: StringFilter<"TrainerClassModule"> | string
    classId?: StringFilter<"TrainerClassModule"> | string
    moduleId?: StringFilter<"TrainerClassModule"> | string
    schoolId?: StringFilter<"TrainerClassModule"> | string
    createdAt?: DateTimeFilter<"TrainerClassModule"> | Date | string
    updatedAt?: DateTimeFilter<"TrainerClassModule"> | Date | string
  }

  export type TimetableUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TimetableWhereUniqueInput
    update: XOR<TimetableUpdateWithoutTeacherInput, TimetableUncheckedUpdateWithoutTeacherInput>
    create: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput>
  }

  export type TimetableUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TimetableWhereUniqueInput
    data: XOR<TimetableUpdateWithoutTeacherInput, TimetableUncheckedUpdateWithoutTeacherInput>
  }

  export type TimetableUpdateManyWithWhereWithoutTeacherInput = {
    where: TimetableScalarWhereInput
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TimetableScalarWhereInput = {
    AND?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
    OR?: TimetableScalarWhereInput[]
    NOT?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
    id?: StringFilter<"Timetable"> | string
    schoolId?: StringFilter<"Timetable"> | string
    classId?: StringFilter<"Timetable"> | string
    teacherId?: StringFilter<"Timetable"> | string
    subjectId?: StringNullableFilter<"Timetable"> | string | null
    moduleId?: StringNullableFilter<"Timetable"> | string | null
    timeSlotId?: StringFilter<"Timetable"> | string
    createdAt?: DateTimeFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeFilter<"Timetable"> | Date | string
  }

  export type UserCreateWithoutSchoolInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    trainerModules?: TrainerModuleCreateNestedManyWithoutTrainerInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutTeacherInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutTrainerInput
    timetablesAsTeacher?: TimetableCreateNestedManyWithoutTeacherInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    trainerModules?: TrainerModuleUncheckedCreateNestedManyWithoutTrainerInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutTeacherInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutTrainerInput
    timetablesAsTeacher?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserCreateManySchoolInputEnvelope = {
    data: UserCreateManySchoolInput | UserCreateManySchoolInput[]
  }

  export type ClassCreateWithoutSchoolInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutClassInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutClassInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassCreateManySchoolInputEnvelope = {
    data: ClassCreateManySchoolInput | ClassCreateManySchoolInput[]
  }

  export type SubjectCreateWithoutSchoolInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSubjects?: ClassSubjectCreateNestedManyWithoutSubjectInput
    timetables?: TimetableCreateNestedManyWithoutSubjectInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSubjects?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSubjectInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutSchoolInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput>
  }

  export type SubjectCreateManySchoolInputEnvelope = {
    data: SubjectCreateManySchoolInput | SubjectCreateManySchoolInput[]
  }

  export type ModuleCreateWithoutSchoolInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trainers?: TrainerModuleCreateNestedManyWithoutModuleInput
    timetables?: TimetableCreateNestedManyWithoutModuleInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    trainers?: TrainerModuleUncheckedCreateNestedManyWithoutModuleInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutModuleInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutSchoolInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutSchoolInput, ModuleUncheckedCreateWithoutSchoolInput>
  }

  export type ModuleCreateManySchoolInputEnvelope = {
    data: ModuleCreateManySchoolInput | ModuleCreateManySchoolInput[]
  }

  export type TimeSlotCreateWithoutSchoolInput = {
    id?: string
    day: string
    period: number
    name: string
    startTime: Date | string
    endTime: Date | string
    session: string
    isBreak?: boolean
    breakType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    timetables?: TimetableCreateNestedManyWithoutTimeSlotInput
  }

  export type TimeSlotUncheckedCreateWithoutSchoolInput = {
    id?: string
    day: string
    period: number
    name: string
    startTime: Date | string
    endTime: Date | string
    session: string
    isBreak?: boolean
    breakType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    timetables?: TimetableUncheckedCreateNestedManyWithoutTimeSlotInput
  }

  export type TimeSlotCreateOrConnectWithoutSchoolInput = {
    where: TimeSlotWhereUniqueInput
    create: XOR<TimeSlotCreateWithoutSchoolInput, TimeSlotUncheckedCreateWithoutSchoolInput>
  }

  export type TimeSlotCreateManySchoolInputEnvelope = {
    data: TimeSlotCreateManySchoolInput | TimeSlotCreateManySchoolInput[]
  }

  export type TimetableCreateWithoutSchoolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTimetablesInput
    teacher: UserCreateNestedOneWithoutTimetablesAsTeacherInput
    subject?: SubjectCreateNestedOneWithoutTimetablesInput
    module?: ModuleCreateNestedOneWithoutTimetablesInput
    timeSlot: TimeSlotCreateNestedOneWithoutTimetablesInput
  }

  export type TimetableUncheckedCreateWithoutSchoolInput = {
    id?: string
    classId: string
    teacherId: string
    subjectId?: string | null
    moduleId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateOrConnectWithoutSchoolInput = {
    where: TimetableWhereUniqueInput
    create: XOR<TimetableCreateWithoutSchoolInput, TimetableUncheckedCreateWithoutSchoolInput>
  }

  export type TimetableCreateManySchoolInputEnvelope = {
    data: TimetableCreateManySchoolInput | TimetableCreateManySchoolInput[]
  }

  export type TeacherClassSubjectCreateWithoutSchoolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutTeacherClassSubjectsInput
    class: ClassCreateNestedOneWithoutTeacherClassSubjectsInput
    subject: SubjectCreateNestedOneWithoutTeacherClassSubjectsInput
  }

  export type TeacherClassSubjectUncheckedCreateWithoutSchoolInput = {
    id?: string
    teacherId: string
    classId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherClassSubjectCreateOrConnectWithoutSchoolInput = {
    where: TeacherClassSubjectWhereUniqueInput
    create: XOR<TeacherClassSubjectCreateWithoutSchoolInput, TeacherClassSubjectUncheckedCreateWithoutSchoolInput>
  }

  export type TeacherClassSubjectCreateManySchoolInputEnvelope = {
    data: TeacherClassSubjectCreateManySchoolInput | TeacherClassSubjectCreateManySchoolInput[]
  }

  export type TrainerClassModuleCreateWithoutSchoolInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerClassModulesInput
    class: ClassCreateNestedOneWithoutTrainerClassModulesInput
    module: ModuleCreateNestedOneWithoutTrainerClassModulesInput
  }

  export type TrainerClassModuleUncheckedCreateWithoutSchoolInput = {
    id?: string
    trainerId: string
    classId: string
    moduleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerClassModuleCreateOrConnectWithoutSchoolInput = {
    where: TrainerClassModuleWhereUniqueInput
    create: XOR<TrainerClassModuleCreateWithoutSchoolInput, TrainerClassModuleUncheckedCreateWithoutSchoolInput>
  }

  export type TrainerClassModuleCreateManySchoolInputEnvelope = {
    data: TrainerClassModuleCreateManySchoolInput | TrainerClassModuleCreateManySchoolInput[]
  }

  export type UserUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateManyWithWhereWithoutSchoolInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSchoolInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    schoolId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    maxWeeklyHours?: IntNullableFilter<"User"> | number | null
    teachingStreams?: StringNullableFilter<"User"> | string | null
    unavailableDays?: StringNullableFilter<"User"> | string | null
    unavailablePeriods?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ClassUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassUpdateManyWithWhereWithoutSchoolInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    level?: StringNullableFilter<"Class"> | string | null
    stream?: StringNullableFilter<"Class"> | string | null
    schoolId?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type SubjectUpsertWithWhereUniqueWithoutSchoolInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutSchoolInput, SubjectUncheckedUpdateWithoutSchoolInput>
    create: XOR<SubjectCreateWithoutSchoolInput, SubjectUncheckedCreateWithoutSchoolInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutSchoolInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutSchoolInput, SubjectUncheckedUpdateWithoutSchoolInput>
  }

  export type SubjectUpdateManyWithWhereWithoutSchoolInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringNullableFilter<"Subject"> | string | null
    level?: StringNullableFilter<"Subject"> | string | null
    periodsPerWeek?: IntFilter<"Subject"> | number
    schoolId?: StringFilter<"Subject"> | string
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
  }

  export type ModuleUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutSchoolInput, ModuleUncheckedUpdateWithoutSchoolInput>
    create: XOR<ModuleCreateWithoutSchoolInput, ModuleUncheckedCreateWithoutSchoolInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutSchoolInput, ModuleUncheckedUpdateWithoutSchoolInput>
  }

  export type ModuleUpdateManyWithWhereWithoutSchoolInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    id?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    code?: StringNullableFilter<"Module"> | string | null
    level?: StringNullableFilter<"Module"> | string | null
    trade?: StringNullableFilter<"Module"> | string | null
    totalHours?: IntFilter<"Module"> | number
    category?: StringFilter<"Module"> | string
    blockSize?: IntFilter<"Module"> | number
    schoolId?: StringFilter<"Module"> | string
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
  }

  export type TimeSlotUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TimeSlotWhereUniqueInput
    update: XOR<TimeSlotUpdateWithoutSchoolInput, TimeSlotUncheckedUpdateWithoutSchoolInput>
    create: XOR<TimeSlotCreateWithoutSchoolInput, TimeSlotUncheckedCreateWithoutSchoolInput>
  }

  export type TimeSlotUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TimeSlotWhereUniqueInput
    data: XOR<TimeSlotUpdateWithoutSchoolInput, TimeSlotUncheckedUpdateWithoutSchoolInput>
  }

  export type TimeSlotUpdateManyWithWhereWithoutSchoolInput = {
    where: TimeSlotScalarWhereInput
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TimeSlotScalarWhereInput = {
    AND?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
    OR?: TimeSlotScalarWhereInput[]
    NOT?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
    id?: StringFilter<"TimeSlot"> | string
    schoolId?: StringFilter<"TimeSlot"> | string
    day?: StringFilter<"TimeSlot"> | string
    period?: IntFilter<"TimeSlot"> | number
    name?: StringFilter<"TimeSlot"> | string
    startTime?: DateTimeFilter<"TimeSlot"> | Date | string
    endTime?: DateTimeFilter<"TimeSlot"> | Date | string
    session?: StringFilter<"TimeSlot"> | string
    isBreak?: BoolFilter<"TimeSlot"> | boolean
    breakType?: StringNullableFilter<"TimeSlot"> | string | null
    isActive?: BoolFilter<"TimeSlot"> | boolean
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSlot"> | Date | string
  }

  export type TimetableUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TimetableWhereUniqueInput
    update: XOR<TimetableUpdateWithoutSchoolInput, TimetableUncheckedUpdateWithoutSchoolInput>
    create: XOR<TimetableCreateWithoutSchoolInput, TimetableUncheckedCreateWithoutSchoolInput>
  }

  export type TimetableUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TimetableWhereUniqueInput
    data: XOR<TimetableUpdateWithoutSchoolInput, TimetableUncheckedUpdateWithoutSchoolInput>
  }

  export type TimetableUpdateManyWithWhereWithoutSchoolInput = {
    where: TimetableScalarWhereInput
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TeacherClassSubjectUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TeacherClassSubjectWhereUniqueInput
    update: XOR<TeacherClassSubjectUpdateWithoutSchoolInput, TeacherClassSubjectUncheckedUpdateWithoutSchoolInput>
    create: XOR<TeacherClassSubjectCreateWithoutSchoolInput, TeacherClassSubjectUncheckedCreateWithoutSchoolInput>
  }

  export type TeacherClassSubjectUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TeacherClassSubjectWhereUniqueInput
    data: XOR<TeacherClassSubjectUpdateWithoutSchoolInput, TeacherClassSubjectUncheckedUpdateWithoutSchoolInput>
  }

  export type TeacherClassSubjectUpdateManyWithWhereWithoutSchoolInput = {
    where: TeacherClassSubjectScalarWhereInput
    data: XOR<TeacherClassSubjectUpdateManyMutationInput, TeacherClassSubjectUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TrainerClassModuleUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TrainerClassModuleWhereUniqueInput
    update: XOR<TrainerClassModuleUpdateWithoutSchoolInput, TrainerClassModuleUncheckedUpdateWithoutSchoolInput>
    create: XOR<TrainerClassModuleCreateWithoutSchoolInput, TrainerClassModuleUncheckedCreateWithoutSchoolInput>
  }

  export type TrainerClassModuleUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TrainerClassModuleWhereUniqueInput
    data: XOR<TrainerClassModuleUpdateWithoutSchoolInput, TrainerClassModuleUncheckedUpdateWithoutSchoolInput>
  }

  export type TrainerClassModuleUpdateManyWithWhereWithoutSchoolInput = {
    where: TrainerClassModuleScalarWhereInput
    data: XOR<TrainerClassModuleUpdateManyMutationInput, TrainerClassModuleUncheckedUpdateManyWithoutSchoolInput>
  }

  export type SchoolCreateWithoutClassesInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    modules?: ModuleCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSchoolInput
    timetables?: TimetableCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    modules?: ModuleUncheckedCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSchoolInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutClassesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
  }

  export type ClassSubjectCreateWithoutClassInput = {
    id?: string
    subject: SubjectCreateNestedOneWithoutClassSubjectsInput
  }

  export type ClassSubjectUncheckedCreateWithoutClassInput = {
    id?: string
    subjectId: string
  }

  export type ClassSubjectCreateOrConnectWithoutClassInput = {
    where: ClassSubjectWhereUniqueInput
    create: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput>
  }

  export type ClassSubjectCreateManyClassInputEnvelope = {
    data: ClassSubjectCreateManyClassInput | ClassSubjectCreateManyClassInput[]
  }

  export type TimetableCreateWithoutClassInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetablesInput
    teacher: UserCreateNestedOneWithoutTimetablesAsTeacherInput
    subject?: SubjectCreateNestedOneWithoutTimetablesInput
    module?: ModuleCreateNestedOneWithoutTimetablesInput
    timeSlot: TimeSlotCreateNestedOneWithoutTimetablesInput
  }

  export type TimetableUncheckedCreateWithoutClassInput = {
    id?: string
    schoolId: string
    teacherId: string
    subjectId?: string | null
    moduleId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateOrConnectWithoutClassInput = {
    where: TimetableWhereUniqueInput
    create: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput>
  }

  export type TimetableCreateManyClassInputEnvelope = {
    data: TimetableCreateManyClassInput | TimetableCreateManyClassInput[]
  }

  export type TeacherClassSubjectCreateWithoutClassInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutTeacherClassSubjectsInput
    subject: SubjectCreateNestedOneWithoutTeacherClassSubjectsInput
    school: SchoolCreateNestedOneWithoutTeacherClassSubjectsInput
  }

  export type TeacherClassSubjectUncheckedCreateWithoutClassInput = {
    id?: string
    teacherId: string
    subjectId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherClassSubjectCreateOrConnectWithoutClassInput = {
    where: TeacherClassSubjectWhereUniqueInput
    create: XOR<TeacherClassSubjectCreateWithoutClassInput, TeacherClassSubjectUncheckedCreateWithoutClassInput>
  }

  export type TeacherClassSubjectCreateManyClassInputEnvelope = {
    data: TeacherClassSubjectCreateManyClassInput | TeacherClassSubjectCreateManyClassInput[]
  }

  export type TrainerClassModuleCreateWithoutClassInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerClassModulesInput
    module: ModuleCreateNestedOneWithoutTrainerClassModulesInput
    school: SchoolCreateNestedOneWithoutTrainerClassModulesInput
  }

  export type TrainerClassModuleUncheckedCreateWithoutClassInput = {
    id?: string
    trainerId: string
    moduleId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerClassModuleCreateOrConnectWithoutClassInput = {
    where: TrainerClassModuleWhereUniqueInput
    create: XOR<TrainerClassModuleCreateWithoutClassInput, TrainerClassModuleUncheckedCreateWithoutClassInput>
  }

  export type TrainerClassModuleCreateManyClassInputEnvelope = {
    data: TrainerClassModuleCreateManyClassInput | TrainerClassModuleCreateManyClassInput[]
  }

  export type SchoolUpsertWithoutClassesInput = {
    update: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutClassesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type SchoolUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassSubjectUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassSubjectWhereUniqueInput
    update: XOR<ClassSubjectUpdateWithoutClassInput, ClassSubjectUncheckedUpdateWithoutClassInput>
    create: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput>
  }

  export type ClassSubjectUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassSubjectWhereUniqueInput
    data: XOR<ClassSubjectUpdateWithoutClassInput, ClassSubjectUncheckedUpdateWithoutClassInput>
  }

  export type ClassSubjectUpdateManyWithWhereWithoutClassInput = {
    where: ClassSubjectScalarWhereInput
    data: XOR<ClassSubjectUpdateManyMutationInput, ClassSubjectUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassSubjectScalarWhereInput = {
    AND?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
    OR?: ClassSubjectScalarWhereInput[]
    NOT?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
    id?: StringFilter<"ClassSubject"> | string
    classId?: StringFilter<"ClassSubject"> | string
    subjectId?: StringFilter<"ClassSubject"> | string
  }

  export type TimetableUpsertWithWhereUniqueWithoutClassInput = {
    where: TimetableWhereUniqueInput
    update: XOR<TimetableUpdateWithoutClassInput, TimetableUncheckedUpdateWithoutClassInput>
    create: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput>
  }

  export type TimetableUpdateWithWhereUniqueWithoutClassInput = {
    where: TimetableWhereUniqueInput
    data: XOR<TimetableUpdateWithoutClassInput, TimetableUncheckedUpdateWithoutClassInput>
  }

  export type TimetableUpdateManyWithWhereWithoutClassInput = {
    where: TimetableScalarWhereInput
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyWithoutClassInput>
  }

  export type TeacherClassSubjectUpsertWithWhereUniqueWithoutClassInput = {
    where: TeacherClassSubjectWhereUniqueInput
    update: XOR<TeacherClassSubjectUpdateWithoutClassInput, TeacherClassSubjectUncheckedUpdateWithoutClassInput>
    create: XOR<TeacherClassSubjectCreateWithoutClassInput, TeacherClassSubjectUncheckedCreateWithoutClassInput>
  }

  export type TeacherClassSubjectUpdateWithWhereUniqueWithoutClassInput = {
    where: TeacherClassSubjectWhereUniqueInput
    data: XOR<TeacherClassSubjectUpdateWithoutClassInput, TeacherClassSubjectUncheckedUpdateWithoutClassInput>
  }

  export type TeacherClassSubjectUpdateManyWithWhereWithoutClassInput = {
    where: TeacherClassSubjectScalarWhereInput
    data: XOR<TeacherClassSubjectUpdateManyMutationInput, TeacherClassSubjectUncheckedUpdateManyWithoutClassInput>
  }

  export type TrainerClassModuleUpsertWithWhereUniqueWithoutClassInput = {
    where: TrainerClassModuleWhereUniqueInput
    update: XOR<TrainerClassModuleUpdateWithoutClassInput, TrainerClassModuleUncheckedUpdateWithoutClassInput>
    create: XOR<TrainerClassModuleCreateWithoutClassInput, TrainerClassModuleUncheckedCreateWithoutClassInput>
  }

  export type TrainerClassModuleUpdateWithWhereUniqueWithoutClassInput = {
    where: TrainerClassModuleWhereUniqueInput
    data: XOR<TrainerClassModuleUpdateWithoutClassInput, TrainerClassModuleUncheckedUpdateWithoutClassInput>
  }

  export type TrainerClassModuleUpdateManyWithWhereWithoutClassInput = {
    where: TrainerClassModuleScalarWhereInput
    data: XOR<TrainerClassModuleUpdateManyMutationInput, TrainerClassModuleUncheckedUpdateManyWithoutClassInput>
  }

  export type SchoolCreateWithoutSubjectsInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    modules?: ModuleCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSchoolInput
    timetables?: TimetableCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    modules?: ModuleUncheckedCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSchoolInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSubjectsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
  }

  export type TeacherSubjectCreateWithoutSubjectInput = {
    id?: string
    teacher: UserCreateNestedOneWithoutTeacherSubjectsInput
  }

  export type TeacherSubjectUncheckedCreateWithoutSubjectInput = {
    id?: string
    teacherId: string
  }

  export type TeacherSubjectCreateOrConnectWithoutSubjectInput = {
    where: TeacherSubjectWhereUniqueInput
    create: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherSubjectCreateManySubjectInputEnvelope = {
    data: TeacherSubjectCreateManySubjectInput | TeacherSubjectCreateManySubjectInput[]
  }

  export type ClassSubjectCreateWithoutSubjectInput = {
    id?: string
    class: ClassCreateNestedOneWithoutSubjectsInput
  }

  export type ClassSubjectUncheckedCreateWithoutSubjectInput = {
    id?: string
    classId: string
  }

  export type ClassSubjectCreateOrConnectWithoutSubjectInput = {
    where: ClassSubjectWhereUniqueInput
    create: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type ClassSubjectCreateManySubjectInputEnvelope = {
    data: ClassSubjectCreateManySubjectInput | ClassSubjectCreateManySubjectInput[]
  }

  export type TimetableCreateWithoutSubjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetablesInput
    class: ClassCreateNestedOneWithoutTimetablesInput
    teacher: UserCreateNestedOneWithoutTimetablesAsTeacherInput
    module?: ModuleCreateNestedOneWithoutTimetablesInput
    timeSlot: TimeSlotCreateNestedOneWithoutTimetablesInput
  }

  export type TimetableUncheckedCreateWithoutSubjectInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    moduleId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateOrConnectWithoutSubjectInput = {
    where: TimetableWhereUniqueInput
    create: XOR<TimetableCreateWithoutSubjectInput, TimetableUncheckedCreateWithoutSubjectInput>
  }

  export type TimetableCreateManySubjectInputEnvelope = {
    data: TimetableCreateManySubjectInput | TimetableCreateManySubjectInput[]
  }

  export type TeacherClassSubjectCreateWithoutSubjectInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: UserCreateNestedOneWithoutTeacherClassSubjectsInput
    class: ClassCreateNestedOneWithoutTeacherClassSubjectsInput
    school: SchoolCreateNestedOneWithoutTeacherClassSubjectsInput
  }

  export type TeacherClassSubjectUncheckedCreateWithoutSubjectInput = {
    id?: string
    teacherId: string
    classId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherClassSubjectCreateOrConnectWithoutSubjectInput = {
    where: TeacherClassSubjectWhereUniqueInput
    create: XOR<TeacherClassSubjectCreateWithoutSubjectInput, TeacherClassSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherClassSubjectCreateManySubjectInputEnvelope = {
    data: TeacherClassSubjectCreateManySubjectInput | TeacherClassSubjectCreateManySubjectInput[]
  }

  export type SchoolUpsertWithoutSubjectsInput = {
    update: XOR<SchoolUpdateWithoutSubjectsInput, SchoolUncheckedUpdateWithoutSubjectsInput>
    create: XOR<SchoolCreateWithoutSubjectsInput, SchoolUncheckedCreateWithoutSubjectsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSubjectsInput, SchoolUncheckedUpdateWithoutSubjectsInput>
  }

  export type SchoolUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: TeacherSubjectWhereUniqueInput
    update: XOR<TeacherSubjectUpdateWithoutSubjectInput, TeacherSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: TeacherSubjectWhereUniqueInput
    data: XOR<TeacherSubjectUpdateWithoutSubjectInput, TeacherSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type TeacherSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: TeacherSubjectScalarWhereInput
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ClassSubjectWhereUniqueInput
    update: XOR<ClassSubjectUpdateWithoutSubjectInput, ClassSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ClassSubjectWhereUniqueInput
    data: XOR<ClassSubjectUpdateWithoutSubjectInput, ClassSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type ClassSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: ClassSubjectScalarWhereInput
    data: XOR<ClassSubjectUpdateManyMutationInput, ClassSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type TimetableUpsertWithWhereUniqueWithoutSubjectInput = {
    where: TimetableWhereUniqueInput
    update: XOR<TimetableUpdateWithoutSubjectInput, TimetableUncheckedUpdateWithoutSubjectInput>
    create: XOR<TimetableCreateWithoutSubjectInput, TimetableUncheckedCreateWithoutSubjectInput>
  }

  export type TimetableUpdateWithWhereUniqueWithoutSubjectInput = {
    where: TimetableWhereUniqueInput
    data: XOR<TimetableUpdateWithoutSubjectInput, TimetableUncheckedUpdateWithoutSubjectInput>
  }

  export type TimetableUpdateManyWithWhereWithoutSubjectInput = {
    where: TimetableScalarWhereInput
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyWithoutSubjectInput>
  }

  export type TeacherClassSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: TeacherClassSubjectWhereUniqueInput
    update: XOR<TeacherClassSubjectUpdateWithoutSubjectInput, TeacherClassSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<TeacherClassSubjectCreateWithoutSubjectInput, TeacherClassSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherClassSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: TeacherClassSubjectWhereUniqueInput
    data: XOR<TeacherClassSubjectUpdateWithoutSubjectInput, TeacherClassSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type TeacherClassSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: TeacherClassSubjectScalarWhereInput
    data: XOR<TeacherClassSubjectUpdateManyMutationInput, TeacherClassSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type SchoolCreateWithoutModulesInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSchoolInput
    timetables?: TimetableCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutModulesInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSchoolInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutModulesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutModulesInput, SchoolUncheckedCreateWithoutModulesInput>
  }

  export type TrainerModuleCreateWithoutModuleInput = {
    id?: string
    trainer: UserCreateNestedOneWithoutTrainerModulesInput
  }

  export type TrainerModuleUncheckedCreateWithoutModuleInput = {
    id?: string
    trainerId: string
  }

  export type TrainerModuleCreateOrConnectWithoutModuleInput = {
    where: TrainerModuleWhereUniqueInput
    create: XOR<TrainerModuleCreateWithoutModuleInput, TrainerModuleUncheckedCreateWithoutModuleInput>
  }

  export type TrainerModuleCreateManyModuleInputEnvelope = {
    data: TrainerModuleCreateManyModuleInput | TrainerModuleCreateManyModuleInput[]
  }

  export type TimetableCreateWithoutModuleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetablesInput
    class: ClassCreateNestedOneWithoutTimetablesInput
    teacher: UserCreateNestedOneWithoutTimetablesAsTeacherInput
    subject?: SubjectCreateNestedOneWithoutTimetablesInput
    timeSlot: TimeSlotCreateNestedOneWithoutTimetablesInput
  }

  export type TimetableUncheckedCreateWithoutModuleInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    subjectId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateOrConnectWithoutModuleInput = {
    where: TimetableWhereUniqueInput
    create: XOR<TimetableCreateWithoutModuleInput, TimetableUncheckedCreateWithoutModuleInput>
  }

  export type TimetableCreateManyModuleInputEnvelope = {
    data: TimetableCreateManyModuleInput | TimetableCreateManyModuleInput[]
  }

  export type TrainerClassModuleCreateWithoutModuleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerClassModulesInput
    class: ClassCreateNestedOneWithoutTrainerClassModulesInput
    school: SchoolCreateNestedOneWithoutTrainerClassModulesInput
  }

  export type TrainerClassModuleUncheckedCreateWithoutModuleInput = {
    id?: string
    trainerId: string
    classId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerClassModuleCreateOrConnectWithoutModuleInput = {
    where: TrainerClassModuleWhereUniqueInput
    create: XOR<TrainerClassModuleCreateWithoutModuleInput, TrainerClassModuleUncheckedCreateWithoutModuleInput>
  }

  export type TrainerClassModuleCreateManyModuleInputEnvelope = {
    data: TrainerClassModuleCreateManyModuleInput | TrainerClassModuleCreateManyModuleInput[]
  }

  export type SchoolUpsertWithoutModulesInput = {
    update: XOR<SchoolUpdateWithoutModulesInput, SchoolUncheckedUpdateWithoutModulesInput>
    create: XOR<SchoolCreateWithoutModulesInput, SchoolUncheckedCreateWithoutModulesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutModulesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutModulesInput, SchoolUncheckedUpdateWithoutModulesInput>
  }

  export type SchoolUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type TrainerModuleUpsertWithWhereUniqueWithoutModuleInput = {
    where: TrainerModuleWhereUniqueInput
    update: XOR<TrainerModuleUpdateWithoutModuleInput, TrainerModuleUncheckedUpdateWithoutModuleInput>
    create: XOR<TrainerModuleCreateWithoutModuleInput, TrainerModuleUncheckedCreateWithoutModuleInput>
  }

  export type TrainerModuleUpdateWithWhereUniqueWithoutModuleInput = {
    where: TrainerModuleWhereUniqueInput
    data: XOR<TrainerModuleUpdateWithoutModuleInput, TrainerModuleUncheckedUpdateWithoutModuleInput>
  }

  export type TrainerModuleUpdateManyWithWhereWithoutModuleInput = {
    where: TrainerModuleScalarWhereInput
    data: XOR<TrainerModuleUpdateManyMutationInput, TrainerModuleUncheckedUpdateManyWithoutModuleInput>
  }

  export type TimetableUpsertWithWhereUniqueWithoutModuleInput = {
    where: TimetableWhereUniqueInput
    update: XOR<TimetableUpdateWithoutModuleInput, TimetableUncheckedUpdateWithoutModuleInput>
    create: XOR<TimetableCreateWithoutModuleInput, TimetableUncheckedCreateWithoutModuleInput>
  }

  export type TimetableUpdateWithWhereUniqueWithoutModuleInput = {
    where: TimetableWhereUniqueInput
    data: XOR<TimetableUpdateWithoutModuleInput, TimetableUncheckedUpdateWithoutModuleInput>
  }

  export type TimetableUpdateManyWithWhereWithoutModuleInput = {
    where: TimetableScalarWhereInput
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyWithoutModuleInput>
  }

  export type TrainerClassModuleUpsertWithWhereUniqueWithoutModuleInput = {
    where: TrainerClassModuleWhereUniqueInput
    update: XOR<TrainerClassModuleUpdateWithoutModuleInput, TrainerClassModuleUncheckedUpdateWithoutModuleInput>
    create: XOR<TrainerClassModuleCreateWithoutModuleInput, TrainerClassModuleUncheckedCreateWithoutModuleInput>
  }

  export type TrainerClassModuleUpdateWithWhereUniqueWithoutModuleInput = {
    where: TrainerClassModuleWhereUniqueInput
    data: XOR<TrainerClassModuleUpdateWithoutModuleInput, TrainerClassModuleUncheckedUpdateWithoutModuleInput>
  }

  export type TrainerClassModuleUpdateManyWithWhereWithoutModuleInput = {
    where: TrainerClassModuleScalarWhereInput
    data: XOR<TrainerClassModuleUpdateManyMutationInput, TrainerClassModuleUncheckedUpdateManyWithoutModuleInput>
  }

  export type UserCreateWithoutTeacherSubjectsInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    trainerModules?: TrainerModuleCreateNestedManyWithoutTrainerInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutTeacherInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutTrainerInput
    timetablesAsTeacher?: TimetableCreateNestedManyWithoutTeacherInput
  }

  export type UserUncheckedCreateWithoutTeacherSubjectsInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    schoolId?: string | null
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainerModules?: TrainerModuleUncheckedCreateNestedManyWithoutTrainerInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutTeacherInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutTrainerInput
    timetablesAsTeacher?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type UserCreateOrConnectWithoutTeacherSubjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherSubjectsInput, UserUncheckedCreateWithoutTeacherSubjectsInput>
  }

  export type SubjectCreateWithoutTeachersInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSubjectsInput
    classSubjects?: ClassSubjectCreateNestedManyWithoutSubjectInput
    timetables?: TimetableCreateNestedManyWithoutSubjectInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutTeachersInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classSubjects?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSubjectInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutTeachersInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
  }

  export type UserUpsertWithoutTeacherSubjectsInput = {
    update: XOR<UserUpdateWithoutTeacherSubjectsInput, UserUncheckedUpdateWithoutTeacherSubjectsInput>
    create: XOR<UserCreateWithoutTeacherSubjectsInput, UserUncheckedCreateWithoutTeacherSubjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherSubjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherSubjectsInput, UserUncheckedUpdateWithoutTeacherSubjectsInput>
  }

  export type UserUpdateWithoutTeacherSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    trainerModules?: TrainerModuleUpdateManyWithoutTrainerNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutTeacherNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutTrainerNestedInput
    timetablesAsTeacher?: TimetableUpdateManyWithoutTeacherNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainerModules?: TrainerModuleUncheckedUpdateManyWithoutTrainerNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutTrainerNestedInput
    timetablesAsTeacher?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type SubjectUpsertWithoutTeachersInput = {
    update: XOR<SubjectUpdateWithoutTeachersInput, SubjectUncheckedUpdateWithoutTeachersInput>
    create: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutTeachersInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutTeachersInput, SubjectUncheckedUpdateWithoutTeachersInput>
  }

  export type SubjectUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    classSubjects?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    timetables?: TimetableUpdateManyWithoutSubjectNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classSubjects?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSubjectNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type UserCreateWithoutTrainerModulesInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutTeacherInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutTrainerInput
    timetablesAsTeacher?: TimetableCreateNestedManyWithoutTeacherInput
  }

  export type UserUncheckedCreateWithoutTrainerModulesInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    schoolId?: string | null
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutTeacherInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutTrainerInput
    timetablesAsTeacher?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type UserCreateOrConnectWithoutTrainerModulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainerModulesInput, UserUncheckedCreateWithoutTrainerModulesInput>
  }

  export type ModuleCreateWithoutTrainersInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutModulesInput
    timetables?: TimetableCreateNestedManyWithoutModuleInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutTrainersInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timetables?: TimetableUncheckedCreateNestedManyWithoutModuleInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutTrainersInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutTrainersInput, ModuleUncheckedCreateWithoutTrainersInput>
  }

  export type UserUpsertWithoutTrainerModulesInput = {
    update: XOR<UserUpdateWithoutTrainerModulesInput, UserUncheckedUpdateWithoutTrainerModulesInput>
    create: XOR<UserCreateWithoutTrainerModulesInput, UserUncheckedCreateWithoutTrainerModulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrainerModulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrainerModulesInput, UserUncheckedUpdateWithoutTrainerModulesInput>
  }

  export type UserUpdateWithoutTrainerModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutTeacherNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutTrainerNestedInput
    timetablesAsTeacher?: TimetableUpdateManyWithoutTeacherNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainerModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutTrainerNestedInput
    timetablesAsTeacher?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ModuleUpsertWithoutTrainersInput = {
    update: XOR<ModuleUpdateWithoutTrainersInput, ModuleUncheckedUpdateWithoutTrainersInput>
    create: XOR<ModuleCreateWithoutTrainersInput, ModuleUncheckedCreateWithoutTrainersInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutTrainersInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutTrainersInput, ModuleUncheckedUpdateWithoutTrainersInput>
  }

  export type ModuleUpdateWithoutTrainersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutModulesNestedInput
    timetables?: TimetableUpdateManyWithoutModuleNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutTrainersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetables?: TimetableUncheckedUpdateManyWithoutModuleNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ClassCreateWithoutSubjectsInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutClassInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutClassInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSubjectsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
  }

  export type SubjectCreateWithoutClassSubjectsInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSubjectsInput
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    timetables?: TimetableCreateNestedManyWithoutSubjectInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutClassSubjectsInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSubjectInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutClassSubjectsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutClassSubjectsInput, SubjectUncheckedCreateWithoutClassSubjectsInput>
  }

  export type ClassUpsertWithoutSubjectsInput = {
    update: XOR<ClassUpdateWithoutSubjectsInput, ClassUncheckedUpdateWithoutSubjectsInput>
    create: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSubjectsInput, ClassUncheckedUpdateWithoutSubjectsInput>
  }

  export type ClassUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutClassNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutClassSubjectsInput = {
    update: XOR<SubjectUpdateWithoutClassSubjectsInput, SubjectUncheckedUpdateWithoutClassSubjectsInput>
    create: XOR<SubjectCreateWithoutClassSubjectsInput, SubjectUncheckedCreateWithoutClassSubjectsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutClassSubjectsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutClassSubjectsInput, SubjectUncheckedUpdateWithoutClassSubjectsInput>
  }

  export type SubjectUpdateWithoutClassSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    timetables?: TimetableUpdateManyWithoutSubjectNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutClassSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSubjectNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SchoolCreateWithoutTimeSlotsInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    modules?: ModuleCreateNestedManyWithoutSchoolInput
    timetables?: TimetableCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutTimeSlotsInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    modules?: ModuleUncheckedCreateNestedManyWithoutSchoolInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutTimeSlotsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTimeSlotsInput, SchoolUncheckedCreateWithoutTimeSlotsInput>
  }

  export type TimetableCreateWithoutTimeSlotInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimetablesInput
    class: ClassCreateNestedOneWithoutTimetablesInput
    teacher: UserCreateNestedOneWithoutTimetablesAsTeacherInput
    subject?: SubjectCreateNestedOneWithoutTimetablesInput
    module?: ModuleCreateNestedOneWithoutTimetablesInput
  }

  export type TimetableUncheckedCreateWithoutTimeSlotInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    subjectId?: string | null
    moduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateOrConnectWithoutTimeSlotInput = {
    where: TimetableWhereUniqueInput
    create: XOR<TimetableCreateWithoutTimeSlotInput, TimetableUncheckedCreateWithoutTimeSlotInput>
  }

  export type TimetableCreateManyTimeSlotInputEnvelope = {
    data: TimetableCreateManyTimeSlotInput | TimetableCreateManyTimeSlotInput[]
  }

  export type SchoolUpsertWithoutTimeSlotsInput = {
    update: XOR<SchoolUpdateWithoutTimeSlotsInput, SchoolUncheckedUpdateWithoutTimeSlotsInput>
    create: XOR<SchoolCreateWithoutTimeSlotsInput, SchoolUncheckedCreateWithoutTimeSlotsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTimeSlotsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTimeSlotsInput, SchoolUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type SchoolUpdateWithoutTimeSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTimeSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type TimetableUpsertWithWhereUniqueWithoutTimeSlotInput = {
    where: TimetableWhereUniqueInput
    update: XOR<TimetableUpdateWithoutTimeSlotInput, TimetableUncheckedUpdateWithoutTimeSlotInput>
    create: XOR<TimetableCreateWithoutTimeSlotInput, TimetableUncheckedCreateWithoutTimeSlotInput>
  }

  export type TimetableUpdateWithWhereUniqueWithoutTimeSlotInput = {
    where: TimetableWhereUniqueInput
    data: XOR<TimetableUpdateWithoutTimeSlotInput, TimetableUncheckedUpdateWithoutTimeSlotInput>
  }

  export type TimetableUpdateManyWithWhereWithoutTimeSlotInput = {
    where: TimetableScalarWhereInput
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyWithoutTimeSlotInput>
  }

  export type SchoolCreateWithoutTimetablesInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    modules?: ModuleCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutTimetablesInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    modules?: ModuleUncheckedCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutTimetablesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTimetablesInput, SchoolUncheckedCreateWithoutTimetablesInput>
  }

  export type ClassCreateWithoutTimetablesInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutClassInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTimetablesInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutClassInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTimetablesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTimetablesInput, ClassUncheckedCreateWithoutTimetablesInput>
  }

  export type UserCreateWithoutTimetablesAsTeacherInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    trainerModules?: TrainerModuleCreateNestedManyWithoutTrainerInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutTeacherInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutTrainerInput
  }

  export type UserUncheckedCreateWithoutTimetablesAsTeacherInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    schoolId?: string | null
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    trainerModules?: TrainerModuleUncheckedCreateNestedManyWithoutTrainerInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutTeacherInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutTrainerInput
  }

  export type UserCreateOrConnectWithoutTimetablesAsTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimetablesAsTeacherInput, UserUncheckedCreateWithoutTimetablesAsTeacherInput>
  }

  export type SubjectCreateWithoutTimetablesInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSubjectsInput
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSubjects?: ClassSubjectCreateNestedManyWithoutSubjectInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutTimetablesInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSubjects?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutTimetablesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutTimetablesInput, SubjectUncheckedCreateWithoutTimetablesInput>
  }

  export type ModuleCreateWithoutTimetablesInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutModulesInput
    trainers?: TrainerModuleCreateNestedManyWithoutModuleInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutTimetablesInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainers?: TrainerModuleUncheckedCreateNestedManyWithoutModuleInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutTimetablesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutTimetablesInput, ModuleUncheckedCreateWithoutTimetablesInput>
  }

  export type TimeSlotCreateWithoutTimetablesInput = {
    id?: string
    day: string
    period: number
    name: string
    startTime: Date | string
    endTime: Date | string
    session: string
    isBreak?: boolean
    breakType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTimeSlotsInput
  }

  export type TimeSlotUncheckedCreateWithoutTimetablesInput = {
    id?: string
    schoolId: string
    day: string
    period: number
    name: string
    startTime: Date | string
    endTime: Date | string
    session: string
    isBreak?: boolean
    breakType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeSlotCreateOrConnectWithoutTimetablesInput = {
    where: TimeSlotWhereUniqueInput
    create: XOR<TimeSlotCreateWithoutTimetablesInput, TimeSlotUncheckedCreateWithoutTimetablesInput>
  }

  export type SchoolUpsertWithoutTimetablesInput = {
    update: XOR<SchoolUpdateWithoutTimetablesInput, SchoolUncheckedUpdateWithoutTimetablesInput>
    create: XOR<SchoolCreateWithoutTimetablesInput, SchoolUncheckedCreateWithoutTimetablesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTimetablesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTimetablesInput, SchoolUncheckedUpdateWithoutTimetablesInput>
  }

  export type SchoolUpdateWithoutTimetablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTimetablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type ClassUpsertWithoutTimetablesInput = {
    update: XOR<ClassUpdateWithoutTimetablesInput, ClassUncheckedUpdateWithoutTimetablesInput>
    create: XOR<ClassCreateWithoutTimetablesInput, ClassUncheckedCreateWithoutTimetablesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutTimetablesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutTimetablesInput, ClassUncheckedUpdateWithoutTimetablesInput>
  }

  export type ClassUpdateWithoutTimetablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutClassNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTimetablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutClassNestedInput
  }

  export type UserUpsertWithoutTimetablesAsTeacherInput = {
    update: XOR<UserUpdateWithoutTimetablesAsTeacherInput, UserUncheckedUpdateWithoutTimetablesAsTeacherInput>
    create: XOR<UserCreateWithoutTimetablesAsTeacherInput, UserUncheckedCreateWithoutTimetablesAsTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimetablesAsTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimetablesAsTeacherInput, UserUncheckedUpdateWithoutTimetablesAsTeacherInput>
  }

  export type UserUpdateWithoutTimetablesAsTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    trainerModules?: TrainerModuleUpdateManyWithoutTrainerNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutTeacherNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutTrainerNestedInput
  }

  export type UserUncheckedUpdateWithoutTimetablesAsTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    trainerModules?: TrainerModuleUncheckedUpdateManyWithoutTrainerNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutTrainerNestedInput
  }

  export type SubjectUpsertWithoutTimetablesInput = {
    update: XOR<SubjectUpdateWithoutTimetablesInput, SubjectUncheckedUpdateWithoutTimetablesInput>
    create: XOR<SubjectCreateWithoutTimetablesInput, SubjectUncheckedCreateWithoutTimetablesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutTimetablesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutTimetablesInput, SubjectUncheckedUpdateWithoutTimetablesInput>
  }

  export type SubjectUpdateWithoutTimetablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSubjects?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutTimetablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSubjects?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ModuleUpsertWithoutTimetablesInput = {
    update: XOR<ModuleUpdateWithoutTimetablesInput, ModuleUncheckedUpdateWithoutTimetablesInput>
    create: XOR<ModuleCreateWithoutTimetablesInput, ModuleUncheckedCreateWithoutTimetablesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutTimetablesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutTimetablesInput, ModuleUncheckedUpdateWithoutTimetablesInput>
  }

  export type ModuleUpdateWithoutTimetablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutModulesNestedInput
    trainers?: TrainerModuleUpdateManyWithoutModuleNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutTimetablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainers?: TrainerModuleUncheckedUpdateManyWithoutModuleNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type TimeSlotUpsertWithoutTimetablesInput = {
    update: XOR<TimeSlotUpdateWithoutTimetablesInput, TimeSlotUncheckedUpdateWithoutTimetablesInput>
    create: XOR<TimeSlotCreateWithoutTimetablesInput, TimeSlotUncheckedCreateWithoutTimetablesInput>
    where?: TimeSlotWhereInput
  }

  export type TimeSlotUpdateToOneWithWhereWithoutTimetablesInput = {
    where?: TimeSlotWhereInput
    data: XOR<TimeSlotUpdateWithoutTimetablesInput, TimeSlotUncheckedUpdateWithoutTimetablesInput>
  }

  export type TimeSlotUpdateWithoutTimetablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
    isBreak?: BoolFieldUpdateOperationsInput | boolean
    breakType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimeSlotsNestedInput
  }

  export type TimeSlotUncheckedUpdateWithoutTimetablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
    isBreak?: BoolFieldUpdateOperationsInput | boolean
    breakType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutTeacherClassSubjectsInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    trainerModules?: TrainerModuleCreateNestedManyWithoutTrainerInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutTrainerInput
    timetablesAsTeacher?: TimetableCreateNestedManyWithoutTeacherInput
  }

  export type UserUncheckedCreateWithoutTeacherClassSubjectsInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    schoolId?: string | null
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    trainerModules?: TrainerModuleUncheckedCreateNestedManyWithoutTrainerInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutTrainerInput
    timetablesAsTeacher?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type UserCreateOrConnectWithoutTeacherClassSubjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherClassSubjectsInput, UserUncheckedCreateWithoutTeacherClassSubjectsInput>
  }

  export type ClassCreateWithoutTeacherClassSubjectsInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTeacherClassSubjectsInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTeacherClassSubjectsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTeacherClassSubjectsInput, ClassUncheckedCreateWithoutTeacherClassSubjectsInput>
  }

  export type SubjectCreateWithoutTeacherClassSubjectsInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSubjectsInput
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classSubjects?: ClassSubjectCreateNestedManyWithoutSubjectInput
    timetables?: TimetableCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutTeacherClassSubjectsInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classSubjects?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutTeacherClassSubjectsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutTeacherClassSubjectsInput, SubjectUncheckedCreateWithoutTeacherClassSubjectsInput>
  }

  export type SchoolCreateWithoutTeacherClassSubjectsInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    modules?: ModuleCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSchoolInput
    timetables?: TimetableCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutTeacherClassSubjectsInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    modules?: ModuleUncheckedCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSchoolInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSchoolInput
    trainerClassModules?: TrainerClassModuleUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutTeacherClassSubjectsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTeacherClassSubjectsInput, SchoolUncheckedCreateWithoutTeacherClassSubjectsInput>
  }

  export type UserUpsertWithoutTeacherClassSubjectsInput = {
    update: XOR<UserUpdateWithoutTeacherClassSubjectsInput, UserUncheckedUpdateWithoutTeacherClassSubjectsInput>
    create: XOR<UserCreateWithoutTeacherClassSubjectsInput, UserUncheckedCreateWithoutTeacherClassSubjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherClassSubjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherClassSubjectsInput, UserUncheckedUpdateWithoutTeacherClassSubjectsInput>
  }

  export type UserUpdateWithoutTeacherClassSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    trainerModules?: TrainerModuleUpdateManyWithoutTrainerNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutTrainerNestedInput
    timetablesAsTeacher?: TimetableUpdateManyWithoutTeacherNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherClassSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    trainerModules?: TrainerModuleUncheckedUpdateManyWithoutTrainerNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutTrainerNestedInput
    timetablesAsTeacher?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassUpsertWithoutTeacherClassSubjectsInput = {
    update: XOR<ClassUpdateWithoutTeacherClassSubjectsInput, ClassUncheckedUpdateWithoutTeacherClassSubjectsInput>
    create: XOR<ClassCreateWithoutTeacherClassSubjectsInput, ClassUncheckedCreateWithoutTeacherClassSubjectsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutTeacherClassSubjectsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutTeacherClassSubjectsInput, ClassUncheckedUpdateWithoutTeacherClassSubjectsInput>
  }

  export type ClassUpdateWithoutTeacherClassSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTeacherClassSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutTeacherClassSubjectsInput = {
    update: XOR<SubjectUpdateWithoutTeacherClassSubjectsInput, SubjectUncheckedUpdateWithoutTeacherClassSubjectsInput>
    create: XOR<SubjectCreateWithoutTeacherClassSubjectsInput, SubjectUncheckedCreateWithoutTeacherClassSubjectsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutTeacherClassSubjectsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutTeacherClassSubjectsInput, SubjectUncheckedUpdateWithoutTeacherClassSubjectsInput>
  }

  export type SubjectUpdateWithoutTeacherClassSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSubjectsNestedInput
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSubjects?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    timetables?: TimetableUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutTeacherClassSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSubjects?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SchoolUpsertWithoutTeacherClassSubjectsInput = {
    update: XOR<SchoolUpdateWithoutTeacherClassSubjectsInput, SchoolUncheckedUpdateWithoutTeacherClassSubjectsInput>
    create: XOR<SchoolCreateWithoutTeacherClassSubjectsInput, SchoolUncheckedCreateWithoutTeacherClassSubjectsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTeacherClassSubjectsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTeacherClassSubjectsInput, SchoolUncheckedUpdateWithoutTeacherClassSubjectsInput>
  }

  export type SchoolUpdateWithoutTeacherClassSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTeacherClassSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSchoolNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type UserCreateWithoutTrainerClassModulesInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school?: SchoolCreateNestedOneWithoutUsersInput
    teacherSubjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    trainerModules?: TrainerModuleCreateNestedManyWithoutTrainerInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutTeacherInput
    timetablesAsTeacher?: TimetableCreateNestedManyWithoutTeacherInput
  }

  export type UserUncheckedCreateWithoutTrainerClassModulesInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    schoolId?: string | null
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherSubjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    trainerModules?: TrainerModuleUncheckedCreateNestedManyWithoutTrainerInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutTeacherInput
    timetablesAsTeacher?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type UserCreateOrConnectWithoutTrainerClassModulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainerClassModulesInput, UserUncheckedCreateWithoutTrainerClassModulesInput>
  }

  export type ClassCreateWithoutTrainerClassModulesInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTrainerClassModulesInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTrainerClassModulesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTrainerClassModulesInput, ClassUncheckedCreateWithoutTrainerClassModulesInput>
  }

  export type ModuleCreateWithoutTrainerClassModulesInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutModulesInput
    trainers?: TrainerModuleCreateNestedManyWithoutModuleInput
    timetables?: TimetableCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutTrainerClassModulesInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainers?: TrainerModuleUncheckedCreateNestedManyWithoutModuleInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutTrainerClassModulesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutTrainerClassModulesInput, ModuleUncheckedCreateWithoutTrainerClassModulesInput>
  }

  export type SchoolCreateWithoutTrainerClassModulesInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    subjects?: SubjectCreateNestedManyWithoutSchoolInput
    modules?: ModuleCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotCreateNestedManyWithoutSchoolInput
    timetables?: TimetableCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutTrainerClassModulesInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    province?: string | null
    district?: string | null
    sector?: string | null
    email: string
    phone?: string | null
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutSchoolInput
    modules?: ModuleUncheckedCreateNestedManyWithoutSchoolInput
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutSchoolInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutSchoolInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutTrainerClassModulesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTrainerClassModulesInput, SchoolUncheckedCreateWithoutTrainerClassModulesInput>
  }

  export type UserUpsertWithoutTrainerClassModulesInput = {
    update: XOR<UserUpdateWithoutTrainerClassModulesInput, UserUncheckedUpdateWithoutTrainerClassModulesInput>
    create: XOR<UserCreateWithoutTrainerClassModulesInput, UserUncheckedCreateWithoutTrainerClassModulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrainerClassModulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrainerClassModulesInput, UserUncheckedUpdateWithoutTrainerClassModulesInput>
  }

  export type UserUpdateWithoutTrainerClassModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneWithoutUsersNestedInput
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    trainerModules?: TrainerModuleUpdateManyWithoutTrainerNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutTeacherNestedInput
    timetablesAsTeacher?: TimetableUpdateManyWithoutTeacherNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainerClassModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    trainerModules?: TrainerModuleUncheckedUpdateManyWithoutTrainerNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    timetablesAsTeacher?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassUpsertWithoutTrainerClassModulesInput = {
    update: XOR<ClassUpdateWithoutTrainerClassModulesInput, ClassUncheckedUpdateWithoutTrainerClassModulesInput>
    create: XOR<ClassCreateWithoutTrainerClassModulesInput, ClassUncheckedCreateWithoutTrainerClassModulesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutTrainerClassModulesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutTrainerClassModulesInput, ClassUncheckedUpdateWithoutTrainerClassModulesInput>
  }

  export type ClassUpdateWithoutTrainerClassModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTrainerClassModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ModuleUpsertWithoutTrainerClassModulesInput = {
    update: XOR<ModuleUpdateWithoutTrainerClassModulesInput, ModuleUncheckedUpdateWithoutTrainerClassModulesInput>
    create: XOR<ModuleCreateWithoutTrainerClassModulesInput, ModuleUncheckedCreateWithoutTrainerClassModulesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutTrainerClassModulesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutTrainerClassModulesInput, ModuleUncheckedUpdateWithoutTrainerClassModulesInput>
  }

  export type ModuleUpdateWithoutTrainerClassModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutModulesNestedInput
    trainers?: TrainerModuleUpdateManyWithoutModuleNestedInput
    timetables?: TimetableUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutTrainerClassModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainers?: TrainerModuleUncheckedUpdateManyWithoutModuleNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type SchoolUpsertWithoutTrainerClassModulesInput = {
    update: XOR<SchoolUpdateWithoutTrainerClassModulesInput, SchoolUncheckedUpdateWithoutTrainerClassModulesInput>
    create: XOR<SchoolCreateWithoutTrainerClassModulesInput, SchoolUncheckedCreateWithoutTrainerClassModulesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTrainerClassModulesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTrainerClassModulesInput, SchoolUncheckedUpdateWithoutTrainerClassModulesInput>
  }

  export type SchoolUpdateWithoutTrainerClassModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTrainerClassModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutSchoolNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutSchoolNestedInput
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutSchoolNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSchoolNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type TeacherSubjectCreateManyTeacherInput = {
    id?: string
    subjectId: string
  }

  export type TrainerModuleCreateManyTrainerInput = {
    id?: string
    moduleId: string
  }

  export type TeacherClassSubjectCreateManyTeacherInput = {
    id?: string
    classId: string
    subjectId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerClassModuleCreateManyTrainerInput = {
    id?: string
    classId: string
    moduleId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateManyTeacherInput = {
    id?: string
    schoolId: string
    classId: string
    subjectId?: string | null
    moduleId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherSubjectUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: SubjectUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherSubjectUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type TrainerModuleUpdateWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: ModuleUpdateOneRequiredWithoutTrainersNestedInput
  }

  export type TrainerModuleUncheckedUpdateWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type TrainerModuleUncheckedUpdateManyWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherClassSubjectUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
  }

  export type TeacherClassSubjectUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassSubjectUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleUpdateWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    module?: ModuleUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    school?: SchoolUpdateOneRequiredWithoutTrainerClassModulesNestedInput
  }

  export type TrainerClassModuleUncheckedUpdateWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleUncheckedUpdateManyWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetablesNestedInput
    class?: ClassUpdateOneRequiredWithoutTimetablesNestedInput
    subject?: SubjectUpdateOneWithoutTimetablesNestedInput
    module?: ModuleUpdateOneWithoutTimetablesNestedInput
    timeSlot?: TimeSlotUpdateOneRequiredWithoutTimetablesNestedInput
  }

  export type TimetableUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManySchoolInput = {
    id?: string
    email: string
    name: string
    password: string
    role: string
    isActive?: boolean
    maxWeeklyHours?: number | null
    teachingStreams?: string | null
    unavailableDays?: string | null
    unavailablePeriods?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManySchoolInput = {
    id?: string
    name: string
    level?: string | null
    stream?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManySchoolInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    periodsPerWeek: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleCreateManySchoolInput = {
    id?: string
    name: string
    code?: string | null
    level?: string | null
    trade?: string | null
    totalHours: number
    category: string
    blockSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeSlotCreateManySchoolInput = {
    id?: string
    day: string
    period: number
    name: string
    startTime: Date | string
    endTime: Date | string
    session: string
    isBreak?: boolean
    breakType?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateManySchoolInput = {
    id?: string
    classId: string
    teacherId: string
    subjectId?: string | null
    moduleId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherClassSubjectCreateManySchoolInput = {
    id?: string
    teacherId: string
    classId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerClassModuleCreateManySchoolInput = {
    id?: string
    trainerId: string
    classId: string
    moduleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherSubjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    trainerModules?: TrainerModuleUpdateManyWithoutTrainerNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutTeacherNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutTrainerNestedInput
    timetablesAsTeacher?: TimetableUpdateManyWithoutTeacherNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherSubjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    trainerModules?: TrainerModuleUncheckedUpdateManyWithoutTrainerNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutTrainerNestedInput
    timetablesAsTeacher?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxWeeklyHours?: NullableIntFieldUpdateOperationsInput | number | null
    teachingStreams?: NullableStringFieldUpdateOperationsInput | string | null
    unavailableDays?: NullableStringFieldUpdateOperationsInput | string | null
    unavailablePeriods?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutClassNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    stream?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classSubjects?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    timetables?: TimetableUpdateManyWithoutSubjectNestedInput
    teacherClassSubjects?: TeacherClassSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classSubjects?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutSubjectNestedInput
    teacherClassSubjects?: TeacherClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    periodsPerWeek?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainers?: TrainerModuleUpdateManyWithoutModuleNestedInput
    timetables?: TimetableUpdateManyWithoutModuleNestedInput
    trainerClassModules?: TrainerClassModuleUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainers?: TrainerModuleUncheckedUpdateManyWithoutModuleNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutModuleNestedInput
    trainerClassModules?: TrainerClassModuleUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: NullableStringFieldUpdateOperationsInput | string | null
    totalHours?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    blockSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSlotUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
    isBreak?: BoolFieldUpdateOperationsInput | boolean
    breakType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetables?: TimetableUpdateManyWithoutTimeSlotNestedInput
  }

  export type TimeSlotUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
    isBreak?: BoolFieldUpdateOperationsInput | boolean
    breakType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timetables?: TimetableUncheckedUpdateManyWithoutTimeSlotNestedInput
  }

  export type TimeSlotUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
    isBreak?: BoolFieldUpdateOperationsInput | boolean
    breakType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTimetablesNestedInput
    teacher?: UserUpdateOneRequiredWithoutTimetablesAsTeacherNestedInput
    subject?: SubjectUpdateOneWithoutTimetablesNestedInput
    module?: ModuleUpdateOneWithoutTimetablesNestedInput
    timeSlot?: TimeSlotUpdateOneRequiredWithoutTimetablesNestedInput
  }

  export type TimetableUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassSubjectUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    class?: ClassUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
  }

  export type TeacherClassSubjectUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassSubjectUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    class?: ClassUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    module?: ModuleUpdateOneRequiredWithoutTrainerClassModulesNestedInput
  }

  export type TrainerClassModuleUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassSubjectCreateManyClassInput = {
    id?: string
    subjectId: string
  }

  export type TimetableCreateManyClassInput = {
    id?: string
    schoolId: string
    teacherId: string
    subjectId?: string | null
    moduleId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherClassSubjectCreateManyClassInput = {
    id?: string
    teacherId: string
    subjectId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerClassModuleCreateManyClassInput = {
    id?: string
    trainerId: string
    moduleId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassSubjectUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: SubjectUpdateOneRequiredWithoutClassSubjectsNestedInput
  }

  export type ClassSubjectUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSubjectUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type TimetableUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetablesNestedInput
    teacher?: UserUpdateOneRequiredWithoutTimetablesAsTeacherNestedInput
    subject?: SubjectUpdateOneWithoutTimetablesNestedInput
    module?: ModuleUpdateOneWithoutTimetablesNestedInput
    timeSlot?: TimeSlotUpdateOneRequiredWithoutTimetablesNestedInput
  }

  export type TimetableUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassSubjectUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
  }

  export type TeacherClassSubjectUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassSubjectUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    module?: ModuleUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    school?: SchoolUpdateOneRequiredWithoutTrainerClassModulesNestedInput
  }

  export type TrainerClassModuleUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherSubjectCreateManySubjectInput = {
    id?: string
    teacherId: string
  }

  export type ClassSubjectCreateManySubjectInput = {
    id?: string
    classId: string
  }

  export type TimetableCreateManySubjectInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    moduleId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherClassSubjectCreateManySubjectInput = {
    id?: string
    teacherId: string
    classId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherSubjectUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacher?: UserUpdateOneRequiredWithoutTeacherSubjectsNestedInput
  }

  export type TeacherSubjectUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSubjectUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type ClassSubjectUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSubjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type TimetableUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetablesNestedInput
    class?: ClassUpdateOneRequiredWithoutTimetablesNestedInput
    teacher?: UserUpdateOneRequiredWithoutTimetablesAsTeacherNestedInput
    module?: ModuleUpdateOneWithoutTimetablesNestedInput
    timeSlot?: TimeSlotUpdateOneRequiredWithoutTimetablesNestedInput
  }

  export type TimetableUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassSubjectUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: UserUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    class?: ClassUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
    school?: SchoolUpdateOneRequiredWithoutTeacherClassSubjectsNestedInput
  }

  export type TeacherClassSubjectUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassSubjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerModuleCreateManyModuleInput = {
    id?: string
    trainerId: string
  }

  export type TimetableCreateManyModuleInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    subjectId?: string | null
    timeSlotId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerClassModuleCreateManyModuleInput = {
    id?: string
    trainerId: string
    classId: string
    schoolId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainerModuleUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainer?: UserUpdateOneRequiredWithoutTrainerModulesNestedInput
  }

  export type TrainerModuleUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
  }

  export type TrainerModuleUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
  }

  export type TimetableUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetablesNestedInput
    class?: ClassUpdateOneRequiredWithoutTimetablesNestedInput
    teacher?: UserUpdateOneRequiredWithoutTimetablesAsTeacherNestedInput
    subject?: SubjectUpdateOneWithoutTimetablesNestedInput
    timeSlot?: TimeSlotUpdateOneRequiredWithoutTimetablesNestedInput
  }

  export type TimetableUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    class?: ClassUpdateOneRequiredWithoutTrainerClassModulesNestedInput
    school?: SchoolUpdateOneRequiredWithoutTrainerClassModulesNestedInput
  }

  export type TrainerClassModuleUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainerClassModuleUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableCreateManyTimeSlotInput = {
    id?: string
    schoolId: string
    classId: string
    teacherId: string
    subjectId?: string | null
    moduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableUpdateWithoutTimeSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTimetablesNestedInput
    class?: ClassUpdateOneRequiredWithoutTimetablesNestedInput
    teacher?: UserUpdateOneRequiredWithoutTimetablesAsTeacherNestedInput
    subject?: SubjectUpdateOneWithoutTimetablesNestedInput
    module?: ModuleUpdateOneWithoutTimetablesNestedInput
  }

  export type TimetableUncheckedUpdateWithoutTimeSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyWithoutTimeSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolCountOutputTypeDefaultArgs instead
     */
    export type SchoolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassCountOutputTypeDefaultArgs instead
     */
    export type ClassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubjectCountOutputTypeDefaultArgs instead
     */
    export type SubjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleCountOutputTypeDefaultArgs instead
     */
    export type ModuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeSlotCountOutputTypeDefaultArgs instead
     */
    export type TimeSlotCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeSlotCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolDefaultArgs instead
     */
    export type SchoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassDefaultArgs instead
     */
    export type ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubjectDefaultArgs instead
     */
    export type SubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleDefaultArgs instead
     */
    export type ModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherSubjectDefaultArgs instead
     */
    export type TeacherSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherSubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainerModuleDefaultArgs instead
     */
    export type TrainerModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainerModuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassSubjectDefaultArgs instead
     */
    export type ClassSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassSubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeSlotDefaultArgs instead
     */
    export type TimeSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeSlotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimetableDefaultArgs instead
     */
    export type TimetableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimetableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherClassSubjectDefaultArgs instead
     */
    export type TeacherClassSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherClassSubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainerClassModuleDefaultArgs instead
     */
    export type TrainerClassModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainerClassModuleDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}