"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_rsc_src_lib_timetable-generator_ts";
exports.ids = ["_rsc_src_lib_timetable-generator_ts"];
exports.modules = {

/***/ "(rsc)/./src/lib/lesson-preparation.ts":
/*!***************************************!*\
  !*** ./src/lib/lesson-preparation.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LessonPreparationService: () => (/* binding */ LessonPreparationService),\n/* harmony export */   prepareLessonsForSchool: () => (/* binding */ prepareLessonsForSchool)\n/* harmony export */ });\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/db */ \"(rsc)/./src/lib/db.ts\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/utils */ \"(rsc)/./src/lib/utils.ts\");\n\n\nclass LessonPreparationService {\n    constructor(schoolId){\n        this.schoolId = schoolId;\n    }\n    /**\r\n     * Prepare all lessons for scheduling using per-class assignments ONLY\r\n     * Converts teacher-class-subject and trainer-class-module assignments into lesson units\r\n     */ async prepareLessons() {\n        const school = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.school.findUnique({\n            where: {\n                id: this.schoolId\n            }\n        });\n        if (!school) {\n            throw new Error(\"School not found\");\n        }\n        const lessons = [];\n        // Prepare lessons ONLY from per-class assignments\n        const teacherClassSubjects = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.teacherClassSubject.findMany({\n            where: {\n                schoolId: this.schoolId\n            },\n            include: {\n                teacher: true,\n                subject: true,\n                class: true\n            }\n        });\n        const trainerClassModules = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.trainerClassModule.findMany({\n            where: {\n                schoolId: this.schoolId\n            },\n            include: {\n                trainer: true,\n                module: true,\n                class: true\n            }\n        });\n        // Process Teacher-Class-Subject assignments (Primary/Secondary)\n        for (const assignment of teacherClassSubjects){\n            const schoolType = this.determineSchoolType(assignment.class.level || \"\");\n            const level = assignment.class.level || assignment.subject.level || \"Unknown\";\n            const periodsPerWeek = assignment.subject.periodsPerWeek;\n            // ENFORCE DOUBLE PERIODS RULE: Maximum 2 consecutive periods\n            const blockSize = 2;\n            const numBlocks = Math.ceil(periodsPerWeek / blockSize);\n            // Create lesson blocks based on periodsPerWeek\n            for(let i = 0; i < numBlocks; i++){\n                const periodsInThisBlock = Math.min(blockSize, periodsPerWeek - i * blockSize);\n                lessons.push({\n                    teacherId: assignment.teacherId,\n                    subjectId: assignment.subjectId,\n                    classId: assignment.classId,\n                    lessonIndex: i + 1,\n                    totalLessons: numBlocks,\n                    lessonType: schoolType,\n                    priority: assignment.subject.periodsPerWeek,\n                    preferredTime: \"ANY\",\n                    streamType: schoolType,\n                    level: level,\n                    blockSize: periodsInThisBlock,\n                    periodsPerWeek: assignment.subject.periodsPerWeek,\n                    teacherName: assignment.teacher.name,\n                    subjectName: assignment.subject.name,\n                    className: assignment.class.name\n                });\n            }\n        }\n        // Process Trainer-Class-Module assignments (TSS)\n        for (const assignment of trainerClassModules){\n            const level = assignment.module.level || \"Unknown\";\n            const totalHours = assignment.module.totalHours;\n            const isComplementary = assignment.module.category === \"COMPLEMENTARY\";\n            // ENFORCE DOUBLE PERIODS RULE FOR SPECIFIC AND GENERAL MODULES\n            // SPECIFIC and GENERAL modules MUST have TWO consecutive periods\n            // COMPLEMENTARY modules fill remaining free spaces (flexible 1-2 periods)\n            if (isComplementary) {\n                // COMPLEMENTARY MODULES: Fill remaining free spaces\n                // Create individual single-period lessons to allow flexible scheduling\n                for(let i = 0; i < totalHours; i++){\n                    lessons.push({\n                        teacherId: assignment.trainerId,\n                        moduleId: assignment.moduleId,\n                        classId: assignment.classId,\n                        lessonIndex: i + 1,\n                        totalLessons: totalHours,\n                        lessonType: \"TSS\",\n                        priority: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.getModuleCategoryPriority)(assignment.module.category),\n                        preferredTime: \"ANY\",\n                        streamType: \"TSS\",\n                        level: level,\n                        blockSize: 1,\n                        periodsPerWeek: assignment.module.totalHours,\n                        moduleCategory: assignment.module.category,\n                        teacherName: assignment.trainer.name,\n                        moduleName: assignment.module.name,\n                        className: assignment.class.name\n                    });\n                }\n            } else {\n                // SPECIFIC AND GENERAL MODULES: Maximum 2 consecutive periods\n                const blockSize = 2;\n                const numBlocks = Math.ceil(totalHours / blockSize);\n                // Create lesson blocks - each block is 2 consecutive periods max\n                for(let i = 0; i < numBlocks; i++){\n                    const periodsInThisBlock = Math.min(blockSize, totalHours - i * blockSize);\n                    lessons.push({\n                        teacherId: assignment.trainerId,\n                        moduleId: assignment.moduleId,\n                        classId: assignment.classId,\n                        lessonIndex: i + 1,\n                        totalLessons: numBlocks,\n                        lessonType: \"TSS\",\n                        priority: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_1__.getModuleCategoryPriority)(assignment.module.category),\n                        preferredTime: \"MORNING\",\n                        streamType: \"TSS\",\n                        level: level,\n                        blockSize: periodsInThisBlock,\n                        periodsPerWeek: assignment.module.totalHours,\n                        moduleCategory: assignment.module.category,\n                        teacherName: assignment.trainer.name,\n                        moduleName: assignment.module.name,\n                        className: assignment.class.name\n                    });\n                }\n            }\n        }\n        return lessons;\n    }\n    /**\r\n     * Determine school type based on class level\r\n     */ determineSchoolType(level) {\n        if ([\n            \"L3\",\n            \"L4\",\n            \"L5\"\n        ].includes(level)) {\n            return \"TSS\";\n        }\n        if (level.startsWith(\"S\")) {\n            return \"SECONDARY\";\n        }\n        if (level.startsWith(\"P\")) {\n            return \"PRIMARY\";\n        }\n        return \"SECONDARY\" // default\n        ;\n    }\n    /**\r\n     * Get classes that have lessons assigned (for validation)\r\n     */ async getClassesWithAssignments() {\n        const teacherClassSubjects = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.teacherClassSubject.findMany({\n            where: {\n                schoolId: this.schoolId\n            },\n            select: {\n                classId: true\n            }\n        });\n        const trainerClassModules = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.trainerClassModule.findMany({\n            where: {\n                schoolId: this.schoolId\n            },\n            select: {\n                classId: true\n            }\n        });\n        const classIds = new Set();\n        teacherClassSubjects.forEach((assignment)=>classIds.add(assignment.classId));\n        trainerClassModules.forEach((assignment)=>classIds.add(assignment.classId));\n        return classIds;\n    }\n    /**\r\n     * Get teachers/trainers that have assignments (for validation)\r\n     */ async getAssignedTeachers() {\n        const teacherClassSubjects = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.teacherClassSubject.findMany({\n            where: {\n                schoolId: this.schoolId\n            },\n            select: {\n                teacherId: true\n            }\n        });\n        const trainerClassModules = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.trainerClassModule.findMany({\n            where: {\n                schoolId: this.schoolId\n            },\n            select: {\n                trainerId: true\n            }\n        });\n        const teacherIds = new Set();\n        teacherClassSubjects.forEach((assignment)=>teacherIds.add(assignment.teacherId));\n        trainerClassModules.forEach((assignment)=>teacherIds.add(assignment.trainerId));\n        return teacherIds;\n    }\n    /**\r\n     * Sort lessons by priority for optimal scheduling with full teacher scope consideration\r\n     * ENFORCE CONSECUTIVE DOUBLE PERIODS RULE priority order:\r\n     * 1) SPECIFIC modules (double periods, morning)\r\n     * 2) GENERAL modules (double periods, morning)\r\n     * 3) Mathematics & Physics (double periods)\r\n     * 4) Other subjects (single or configured block)\r\n     */ sortLessonsByPriority(lessons) {\n        return lessons.sort((a, b)=>{\n            // CRITICAL: Consider teacher scope when prioritizing\n            // Teachers with broader scope (multiple classes/subjects) get scheduling priority\n            const teacherAScope = this.calculateTeacherScope(lessons, a.teacherId);\n            const teacherBScope = this.calculateTeacherScope(lessons, b.teacherId);\n            // Teachers with larger scope get higher priority to prevent conflicts\n            const scopePriority = teacherBScope - teacherAScope;\n            if (scopePriority !== 0) {\n                return scopePriority;\n            }\n            // ENFORCE FLEXIBLE COMPLEMENTARY MODULES RULE: Priority order for scheduling\n            const getSchedulingPriority = (lesson)=>{\n                // 1) SPECIFIC modules (highest priority)\n                if (lesson.lessonType === \"TSS\" && lesson.moduleCategory === \"SPECIFIC\") {\n                    return 1;\n                }\n                // 2) GENERAL modules \n                if (lesson.lessonType === \"TSS\" && lesson.moduleCategory === \"GENERAL\") {\n                    return 2;\n                }\n                // 3) Mathematics & Physics (double periods)\n                const subjectName = (lesson.subjectName || \"\").toLowerCase();\n                if (lesson.lessonType !== \"TSS\" && (subjectName.includes(\"mathematics\") || subjectName.includes(\"physics\"))) {\n                    return 3;\n                }\n                // 4) Other required subjects\n                if (lesson.lessonType !== \"TSS\" && !(subjectName.includes(\"mathematics\") || subjectName.includes(\"physics\"))) {\n                    return 4;\n                }\n                // 5) COMPLEMENTARY modules (lowest priority - fill FREE slots)\n                if (lesson.lessonType === \"TSS\" && lesson.moduleCategory === \"COMPLEMENTARY\") {\n                    return 5;\n                }\n                // Default fallback\n                return 6;\n            };\n            const aPriority = getSchedulingPriority(a);\n            const bPriority = getSchedulingPriority(b);\n            if (aPriority !== bPriority) {\n                return aPriority - bPriority;\n            }\n            // Within same priority group, sort by lesson type\n            const typePriority = {\n                TSS: 3,\n                SECONDARY: 2,\n                PRIMARY: 1\n            };\n            if (typePriority[a.lessonType] !== typePriority[b.lessonType]) {\n                return typePriority[b.lessonType] - typePriority[a.lessonType];\n            }\n            // For TSS lessons, sort by category priority (SPECIFIC, GENERAL, COMPLEMENTARY)\n            if (a.lessonType === \"TSS\" && b.lessonType === \"TSS\") {\n                if (a.priority !== b.priority) return a.priority - b.priority;\n                return b.totalLessons - a.totalLessons;\n            }\n            // For regular subjects, sort by total lessons (higher = more urgent)\n            return b.totalLessons - a.totalLessons;\n        });\n    }\n    /**\r\n     * Calculate teacher's scope across the entire school for scheduling priority\r\n     * Teachers with broader scope get higher priority to prevent conflicts\r\n     */ calculateTeacherScope(lessons, teacherId) {\n        const teacherLessons = lessons.filter((lesson)=>lesson.teacherId === teacherId);\n        if (teacherLessons.length === 0) return 0;\n        // Count unique classes, subjects/modules, and levels the teacher teaches\n        const uniqueClasses = new Set(teacherLessons.map((l)=>l.classId)).size;\n        const uniqueSubjects = new Set(teacherLessons.filter((l)=>l.subjectId || l.moduleId).map((l)=>l.subjectId || l.moduleId)).size;\n        const uniqueLevels = new Set(teacherLessons.map((l)=>l.level)).size;\n        // Calculate scope score (higher = broader scope)\n        // Weight: classes * 3 + subjects * 2 + levels * 1\n        const scopeScore = uniqueClasses * 3 + uniqueSubjects * 2 + uniqueLevels;\n        console.log(`Teacher ${teacherId} scope: ${uniqueClasses} classes, ${uniqueSubjects} subjects/modules, ${uniqueLevels} levels = score ${scopeScore}`);\n        return scopeScore;\n    }\n    /**\r\n     * Get lesson statistics for reporting\r\n     */ getLessonStatistics(lessons) {\n        const stats = {\n            total: lessons.length,\n            byType: {\n                PRIMARY: 0,\n                SECONDARY: 0,\n                TSS: 0\n            },\n            byLevel: {},\n            byTeacher: {},\n            averageLessonsPerTeacher: 0,\n            maxLessonsPerTeacher: 0\n        };\n        const teacherLessonCount = {};\n        lessons.forEach((lesson)=>{\n            // Count by type\n            stats.byType[lesson.lessonType]++;\n            // Count by level\n            stats.byLevel[lesson.level] = (stats.byLevel[lesson.level] || 0) + 1;\n            // Count by teacher\n            const teacherKey = lesson.teacherName || lesson.teacherId;\n            teacherLessonCount[teacherKey] = (teacherLessonCount[teacherKey] || 0) + 1;\n        });\n        // Calculate teacher statistics\n        const teacherCounts = Object.values(teacherLessonCount);\n        stats.byTeacher = teacherLessonCount;\n        stats.averageLessonsPerTeacher = teacherCounts.length > 0 ? teacherCounts.reduce((sum, count)=>sum + count, 0) / teacherCounts.length : 0;\n        stats.maxLessonsPerTeacher = teacherCounts.length > 0 ? Math.max(...teacherCounts) : 0;\n        return stats;\n    }\n    /**\r\n     * Validate lesson assignments based on per-class assignments\r\n     */ async validateLessons(lessons) {\n        const errors = [];\n        const warnings = [];\n        try {\n            // Check for teachers/trainers with no assignments\n            const teachersWithLessons = new Set(lessons.map((l)=>l.teacherId));\n            const allTeachers = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.user.findMany({\n                where: {\n                    schoolId: this.schoolId,\n                    role: {\n                        in: [\n                            \"TEACHER\",\n                            \"TRAINER\"\n                        ]\n                    },\n                    isActive: true\n                }\n            });\n            const unassignedTeachers = allTeachers.filter((t)=>!teachersWithLessons.has(t.id));\n            if (unassignedTeachers.length > 0) {\n                warnings.push(`${unassignedTeachers.length} teachers/trainers have no per-class lesson assignments`);\n            }\n            // Check for classes with no lessons (this is now more important)\n            const classesWithLessons = new Set(lessons.map((l)=>l.classId));\n            const allClasses = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.class.findMany({\n                where: {\n                    schoolId: this.schoolId\n                }\n            });\n            const classesWithoutLessons = allClasses.filter((c)=>!classesWithLessons.has(c.id));\n            if (classesWithoutLessons.length > 0) {\n                warnings.push(`${classesWithoutLessons.length} classes have no lessons scheduled - they may need teacher assignments`);\n            }\n            // Check if we have any lessons at all\n            if (lessons.length === 0) {\n                errors.push(\"No lessons found. Please create teacher-class assignments first.\");\n            }\n            // Validate that lessons are properly distributed\n            const lessonsByClass = new Map();\n            lessons.forEach((lesson)=>{\n                const count = lessonsByClass.get(lesson.classId) || 0;\n                lessonsByClass.set(lesson.classId, count + 1);\n            });\n            const classesWithLowLessons = Array.from(lessonsByClass.entries()).filter(([classId, count])=>count < 5) // Arbitrary threshold\n            .map(([classId, count])=>`${classId} (${count} lessons)`);\n            if (classesWithLowLessons.length > 0) {\n                warnings.push(`Some classes have very few lessons: ${classesWithLowLessons.join(\", \")}`);\n            }\n        } catch (error) {\n            console.error(\"Validation error:\", error);\n            warnings.push(\"Unable to complete full validation due to database access issues\");\n        }\n        return {\n            isValid: errors.length === 0,\n            errors,\n            warnings\n        };\n    }\n}\n/**\r\n * Prepare lessons for a school\r\n */ async function prepareLessonsForSchool(schoolId) {\n    const service = new LessonPreparationService(schoolId);\n    const lessons = await service.prepareLessons();\n    const sortedLessons = service.sortLessonsByPriority(lessons);\n    const statistics = service.getLessonStatistics(sortedLessons);\n    const validation = await service.validateLessons(sortedLessons);\n    return {\n        lessons: sortedLessons,\n        statistics,\n        validation\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFDSHVHLFNBQVN6QixPQUFPNUIsTUFBTSxLQUFLO1lBQzNCNEI7WUFDQUM7UUFDSjtJQUNKO0FBQ0o7QUFFQTs7Q0FFQyxHQUNNLGVBQWV5Qix3QkFBd0J2SSxRQUFnQjtJQUsxRCxNQUFNd0ksVUFBVSxJQUFJMUkseUJBQXlCRTtJQUM3QyxNQUFNTyxVQUFVLE1BQU1pSSxRQUFRdkksY0FBYztJQUM1QyxNQUFNd0ksZ0JBQWdCRCxRQUFRMUUscUJBQXFCLENBQUN2RDtJQUNwRCxNQUFNbUksYUFBYUYsUUFBUTdDLG1CQUFtQixDQUFDOEM7SUFDL0MsTUFBTUUsYUFBYSxNQUFNSCxRQUFRNUIsZUFBZSxDQUFDNkI7SUFFakQsT0FBTztRQUNIbEksU0FBU2tJO1FBQ1RDO1FBQ0FDO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3NjaG9vbC10aW1ldGFibGUtbWFuYWdlbWVudC8uL3NyYy9saWIvbGVzc29uLXByZXBhcmF0aW9uLnRzP2VkOTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGIgfSBmcm9tICdAL2xpYi9kYidcclxuaW1wb3J0IHsgZ2V0TW9kdWxlQ2F0ZWdvcnlQcmlvcml0eSB9IGZyb20gJ0AvbGliL3V0aWxzJ1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQcmVwYXJlZExlc3NvbiB7XHJcbiAgICAvLyBDb3JlIGxlc3NvbiBkYXRhXHJcbiAgICB0ZWFjaGVySWQ6IHN0cmluZ1xyXG4gICAgc3ViamVjdElkPzogc3RyaW5nXHJcbiAgICBtb2R1bGVJZD86IHN0cmluZ1xyXG4gICAgY2xhc3NJZDogc3RyaW5nXHJcblxyXG4gICAgLy8gTGVzc29uIG1ldGFkYXRhXHJcbiAgICBsZXNzb25JbmRleDogbnVtYmVyXHJcbiAgICB0b3RhbExlc3NvbnM6IG51bWJlclxyXG4gICAgbGVzc29uVHlwZTogJ1BSSU1BUlknIHwgJ1NFQ09OREFSWScgfCAnVFNTJ1xyXG5cclxuICAgIC8vIFNjaGVkdWxpbmcgcHJlZmVyZW5jZXNcclxuICAgIHByaW9yaXR5OiBudW1iZXJcclxuICAgIHByZWZlcnJlZFRpbWU6ICdNT1JOSU5HJyB8ICdBTlknXHJcblxyXG4gICAgLy8gU3RyZWFtIGluZm9ybWF0aW9uXHJcbiAgICBzdHJlYW1UeXBlOiAnUFJJTUFSWScgfCAnU0VDT05EQVJZJyB8ICdUU1MnXHJcbiAgICBsZXZlbDogc3RyaW5nXHJcblxyXG4gICAgLy8gQmxvY2sgc2NoZWR1bGluZ1xyXG4gICAgYmxvY2tTaXplPzogbnVtYmVyIC8vIE51bWJlciBvZiBjb25zZWN1dGl2ZSBwZXJpb2RzIGluIHRoaXMgYmxvY2tcclxuICAgIHBlcmlvZHNQZXJXZWVrPzogbnVtYmVyIC8vIFRvdGFsIHBlcmlvZHMgcGVyIHdlZWsgZm9yIHRoaXMgc3ViamVjdC9tb2R1bGVcclxuICAgIG1vZHVsZUNhdGVnb3J5Pzogc3RyaW5nIC8vIFNQRUNJRklDLCBHRU5FUkFMLCBDT01QTEVNRU5UQVJZXHJcblxyXG4gICAgLy8gQXNzaWdubWVudCB0cmFja2luZ1xyXG4gICAgdGVhY2hlck5hbWU/OiBzdHJpbmdcclxuICAgIHN1YmplY3ROYW1lPzogc3RyaW5nXHJcbiAgICBtb2R1bGVOYW1lPzogc3RyaW5nXHJcbiAgICBjbGFzc05hbWU/OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIExlc3NvblByZXBhcmF0aW9uU2VydmljZSB7XHJcbiAgICBwcml2YXRlIHNjaG9vbElkOiBzdHJpbmdcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzY2hvb2xJZDogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5zY2hvb2xJZCA9IHNjaG9vbElkXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlIGFsbCBsZXNzb25zIGZvciBzY2hlZHVsaW5nIHVzaW5nIHBlci1jbGFzcyBhc3NpZ25tZW50cyBPTkxZXHJcbiAgICAgKiBDb252ZXJ0cyB0ZWFjaGVyLWNsYXNzLXN1YmplY3QgYW5kIHRyYWluZXItY2xhc3MtbW9kdWxlIGFzc2lnbm1lbnRzIGludG8gbGVzc29uIHVuaXRzXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHByZXBhcmVMZXNzb25zKCk6IFByb21pc2U8UHJlcGFyZWRMZXNzb25bXT4ge1xyXG4gICAgICAgIGNvbnN0IHNjaG9vbCA9IGF3YWl0IGRiLnNjaG9vbC5maW5kVW5pcXVlKHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHRoaXMuc2Nob29sSWQgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGlmICghc2Nob29sKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2Nob29sIG5vdCBmb3VuZCcpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBsZXNzb25zOiBQcmVwYXJlZExlc3NvbltdID0gW11cclxuXHJcbiAgICAgICAgLy8gUHJlcGFyZSBsZXNzb25zIE9OTFkgZnJvbSBwZXItY2xhc3MgYXNzaWdubWVudHNcclxuICAgICAgICBjb25zdCB0ZWFjaGVyQ2xhc3NTdWJqZWN0cyA9IGF3YWl0IGRiLnRlYWNoZXJDbGFzc1N1YmplY3QuZmluZE1hbnkoe1xyXG4gICAgICAgICAgICB3aGVyZTogeyBzY2hvb2xJZDogdGhpcy5zY2hvb2xJZCB9LFxyXG4gICAgICAgICAgICBpbmNsdWRlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZWFjaGVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3ViamVjdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNsYXNzOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBjb25zdCB0cmFpbmVyQ2xhc3NNb2R1bGVzID0gYXdhaXQgZGIudHJhaW5lckNsYXNzTW9kdWxlLmZpbmRNYW55KHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQgfSxcclxuICAgICAgICAgICAgaW5jbHVkZToge1xyXG4gICAgICAgICAgICAgICAgdHJhaW5lcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG1vZHVsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNsYXNzOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBQcm9jZXNzIFRlYWNoZXItQ2xhc3MtU3ViamVjdCBhc3NpZ25tZW50cyAoUHJpbWFyeS9TZWNvbmRhcnkpXHJcbiAgICAgICAgZm9yIChjb25zdCBhc3NpZ25tZW50IG9mIHRlYWNoZXJDbGFzc1N1YmplY3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjaG9vbFR5cGUgPSB0aGlzLmRldGVybWluZVNjaG9vbFR5cGUoYXNzaWdubWVudC5jbGFzcy5sZXZlbCB8fCAnJylcclxuICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSBhc3NpZ25tZW50LmNsYXNzLmxldmVsIHx8IGFzc2lnbm1lbnQuc3ViamVjdC5sZXZlbCB8fCAnVW5rbm93bidcclxuICAgICAgICAgICAgY29uc3QgcGVyaW9kc1BlcldlZWsgPSBhc3NpZ25tZW50LnN1YmplY3QucGVyaW9kc1BlcldlZWtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEVORk9SQ0UgRE9VQkxFIFBFUklPRFMgUlVMRTogTWF4aW11bSAyIGNvbnNlY3V0aXZlIHBlcmlvZHNcclxuICAgICAgICAgICAgY29uc3QgYmxvY2tTaXplID0gMlxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgbnVtQmxvY2tzID0gTWF0aC5jZWlsKHBlcmlvZHNQZXJXZWVrIC8gYmxvY2tTaXplKVxyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGxlc3NvbiBibG9ja3MgYmFzZWQgb24gcGVyaW9kc1BlcldlZWtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1CbG9ja3M7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGVyaW9kc0luVGhpc0Jsb2NrID0gTWF0aC5taW4oYmxvY2tTaXplLCBwZXJpb2RzUGVyV2VlayAtIChpICogYmxvY2tTaXplKSlcclxuICAgICAgICAgICAgICAgIGxlc3NvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVhY2hlcklkOiBhc3NpZ25tZW50LnRlYWNoZXJJZCxcclxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0SWQ6IGFzc2lnbm1lbnQuc3ViamVjdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzSWQ6IGFzc2lnbm1lbnQuY2xhc3NJZCxcclxuICAgICAgICAgICAgICAgICAgICBsZXNzb25JbmRleDogaSArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxMZXNzb25zOiBudW1CbG9ja3MsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVzc29uVHlwZTogc2Nob29sVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogYXNzaWdubWVudC5zdWJqZWN0LnBlcmlvZHNQZXJXZWVrLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZFRpbWU6ICdBTlknLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbVR5cGU6IHNjaG9vbFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2l6ZTogcGVyaW9kc0luVGhpc0Jsb2NrLCAvLyBBY3R1YWwgcGVyaW9kcyBpbiB0aGlzIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kc1BlcldlZWs6IGFzc2lnbm1lbnQuc3ViamVjdC5wZXJpb2RzUGVyV2VlayxcclxuICAgICAgICAgICAgICAgICAgICB0ZWFjaGVyTmFtZTogYXNzaWdubWVudC50ZWFjaGVyLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdE5hbWU6IGFzc2lnbm1lbnQuc3ViamVjdC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogYXNzaWdubWVudC5jbGFzcy5uYW1lXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcm9jZXNzIFRyYWluZXItQ2xhc3MtTW9kdWxlIGFzc2lnbm1lbnRzIChUU1MpXHJcbiAgICAgICAgZm9yIChjb25zdCBhc3NpZ25tZW50IG9mIHRyYWluZXJDbGFzc01vZHVsZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSBhc3NpZ25tZW50Lm1vZHVsZS5sZXZlbCB8fCAnVW5rbm93bidcclxuICAgICAgICAgICAgY29uc3QgdG90YWxIb3VycyA9IGFzc2lnbm1lbnQubW9kdWxlLnRvdGFsSG91cnNcclxuICAgICAgICAgICAgY29uc3QgaXNDb21wbGVtZW50YXJ5ID0gYXNzaWdubWVudC5tb2R1bGUuY2F0ZWdvcnkgPT09ICdDT01QTEVNRU5UQVJZJ1xyXG5cclxuICAgICAgICAgICAgLy8gRU5GT1JDRSBET1VCTEUgUEVSSU9EUyBSVUxFIEZPUiBTUEVDSUZJQyBBTkQgR0VORVJBTCBNT0RVTEVTXHJcbiAgICAgICAgICAgIC8vIFNQRUNJRklDIGFuZCBHRU5FUkFMIG1vZHVsZXMgTVVTVCBoYXZlIFRXTyBjb25zZWN1dGl2ZSBwZXJpb2RzXHJcbiAgICAgICAgICAgIC8vIENPTVBMRU1FTlRBUlkgbW9kdWxlcyBmaWxsIHJlbWFpbmluZyBmcmVlIHNwYWNlcyAoZmxleGlibGUgMS0yIHBlcmlvZHMpXHJcbiAgICAgICAgICAgIGlmIChpc0NvbXBsZW1lbnRhcnkpIHtcclxuICAgICAgICAgICAgICAgIC8vIENPTVBMRU1FTlRBUlkgTU9EVUxFUzogRmlsbCByZW1haW5pbmcgZnJlZSBzcGFjZXNcclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBpbmRpdmlkdWFsIHNpbmdsZS1wZXJpb2QgbGVzc29ucyB0byBhbGxvdyBmbGV4aWJsZSBzY2hlZHVsaW5nXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsSG91cnM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlc3NvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYWNoZXJJZDogYXNzaWdubWVudC50cmFpbmVySWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUlkOiBhc3NpZ25tZW50Lm1vZHVsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0lkOiBhc3NpZ25tZW50LmNsYXNzSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlc3NvbkluZGV4OiBpICsgMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxMZXNzb25zOiB0b3RhbEhvdXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXNzb25UeXBlOiAnVFNTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IGdldE1vZHVsZUNhdGVnb3J5UHJpb3JpdHkoYXNzaWdubWVudC5tb2R1bGUuY2F0ZWdvcnkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJyZWRUaW1lOiAnQU5ZJywgLy8gQ2FuIGJlIHNjaGVkdWxlZCBpbiBhbnkgZnJlZSBzbG90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbVR5cGU6ICdUU1MnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrU2l6ZTogMSwgLy8gU2luZ2xlIHBlcmlvZCAtIHdpbGwgdHJ5IGRvdWJsZSBmaXJzdCwgZmFsbGJhY2sgdG8gc2luZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmlvZHNQZXJXZWVrOiBhc3NpZ25tZW50Lm1vZHVsZS50b3RhbEhvdXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVDYXRlZ29yeTogYXNzaWdubWVudC5tb2R1bGUuY2F0ZWdvcnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYWNoZXJOYW1lOiBhc3NpZ25tZW50LnRyYWluZXIubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogYXNzaWdubWVudC5tb2R1bGUubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBhc3NpZ25tZW50LmNsYXNzLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU1BFQ0lGSUMgQU5EIEdFTkVSQUwgTU9EVUxFUzogTWF4aW11bSAyIGNvbnNlY3V0aXZlIHBlcmlvZHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IDJcclxuICAgICAgICAgICAgICAgIGNvbnN0IG51bUJsb2NrcyA9IE1hdGguY2VpbCh0b3RhbEhvdXJzIC8gYmxvY2tTaXplKVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBsZXNzb24gYmxvY2tzIC0gZWFjaCBibG9jayBpcyAyIGNvbnNlY3V0aXZlIHBlcmlvZHMgbWF4XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyaW9kc0luVGhpc0Jsb2NrID0gTWF0aC5taW4oYmxvY2tTaXplLCB0b3RhbEhvdXJzIC0gKGkgKiBibG9ja1NpemUpKVxyXG4gICAgICAgICAgICAgICAgICAgIGxlc3NvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYWNoZXJJZDogYXNzaWdubWVudC50cmFpbmVySWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUlkOiBhc3NpZ25tZW50Lm1vZHVsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0lkOiBhc3NpZ25tZW50LmNsYXNzSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlc3NvbkluZGV4OiBpICsgMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxMZXNzb25zOiBudW1CbG9ja3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlc3NvblR5cGU6ICdUU1MnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogZ2V0TW9kdWxlQ2F0ZWdvcnlQcmlvcml0eShhc3NpZ25tZW50Lm1vZHVsZS5jYXRlZ29yeSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZFRpbWU6ICdNT1JOSU5HJywgLy8gUHJlZmVyIG1vcm5pbmcgZm9yIGNvcmUgbW9kdWxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1UeXBlOiAnVFNTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja1NpemU6IHBlcmlvZHNJblRoaXNCbG9jaywgLy8gV2lsbCBiZSAyIGZvciBtb3N0IGJsb2NrcywgMSBmb3IgcmVtYWluZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmlvZHNQZXJXZWVrOiBhc3NpZ25tZW50Lm1vZHVsZS50b3RhbEhvdXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVDYXRlZ29yeTogYXNzaWdubWVudC5tb2R1bGUuY2F0ZWdvcnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYWNoZXJOYW1lOiBhc3NpZ25tZW50LnRyYWluZXIubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogYXNzaWdubWVudC5tb2R1bGUubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBhc3NpZ25tZW50LmNsYXNzLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbGVzc29uc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lIHNjaG9vbCB0eXBlIGJhc2VkIG9uIGNsYXNzIGxldmVsXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZGV0ZXJtaW5lU2Nob29sVHlwZShsZXZlbDogc3RyaW5nKTogJ1BSSU1BUlknIHwgJ1NFQ09OREFSWScgfCAnVFNTJyB7XHJcbiAgICAgICAgaWYgKFsnTDMnLCAnTDQnLCAnTDUnXS5pbmNsdWRlcyhsZXZlbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdUU1MnXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZXZlbC5zdGFydHNXaXRoKCdTJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdTRUNPTkRBUlknXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZXZlbC5zdGFydHNXaXRoKCdQJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdQUklNQVJZJ1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ1NFQ09OREFSWScgLy8gZGVmYXVsdFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGNsYXNzZXMgdGhhdCBoYXZlIGxlc3NvbnMgYXNzaWduZWQgKGZvciB2YWxpZGF0aW9uKVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldENsYXNzZXNXaXRoQXNzaWdubWVudHMoKTogUHJvbWlzZTxTZXQ8c3RyaW5nPj4ge1xyXG4gICAgICAgIGNvbnN0IHRlYWNoZXJDbGFzc1N1YmplY3RzID0gYXdhaXQgZGIudGVhY2hlckNsYXNzU3ViamVjdC5maW5kTWFueSh7XHJcbiAgICAgICAgICAgIHdoZXJlOiB7IHNjaG9vbElkOiB0aGlzLnNjaG9vbElkIH0sXHJcbiAgICAgICAgICAgIHNlbGVjdDogeyBjbGFzc0lkOiB0cnVlIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBjb25zdCB0cmFpbmVyQ2xhc3NNb2R1bGVzID0gYXdhaXQgZGIudHJhaW5lckNsYXNzTW9kdWxlLmZpbmRNYW55KHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQgfSxcclxuICAgICAgICAgICAgc2VsZWN0OiB7IGNsYXNzSWQ6IHRydWUgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNvbnN0IGNsYXNzSWRzID0gbmV3IFNldDxzdHJpbmc+KClcclxuICAgICAgICB0ZWFjaGVyQ2xhc3NTdWJqZWN0cy5mb3JFYWNoKChhc3NpZ25tZW50OiBhbnkpID0+IGNsYXNzSWRzLmFkZChhc3NpZ25tZW50LmNsYXNzSWQpKVxyXG4gICAgICAgIHRyYWluZXJDbGFzc01vZHVsZXMuZm9yRWFjaCgoYXNzaWdubWVudDogYW55KSA9PiBjbGFzc0lkcy5hZGQoYXNzaWdubWVudC5jbGFzc0lkKSlcclxuXHJcbiAgICAgICAgcmV0dXJuIGNsYXNzSWRzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGVhY2hlcnMvdHJhaW5lcnMgdGhhdCBoYXZlIGFzc2lnbm1lbnRzIChmb3IgdmFsaWRhdGlvbilcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRBc3NpZ25lZFRlYWNoZXJzKCk6IFByb21pc2U8U2V0PHN0cmluZz4+IHtcclxuICAgICAgICBjb25zdCB0ZWFjaGVyQ2xhc3NTdWJqZWN0cyA9IGF3YWl0IGRiLnRlYWNoZXJDbGFzc1N1YmplY3QuZmluZE1hbnkoe1xyXG4gICAgICAgICAgICB3aGVyZTogeyBzY2hvb2xJZDogdGhpcy5zY2hvb2xJZCB9LFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHsgdGVhY2hlcklkOiB0cnVlIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBjb25zdCB0cmFpbmVyQ2xhc3NNb2R1bGVzID0gYXdhaXQgZGIudHJhaW5lckNsYXNzTW9kdWxlLmZpbmRNYW55KHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQgfSxcclxuICAgICAgICAgICAgc2VsZWN0OiB7IHRyYWluZXJJZDogdHJ1ZSB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgY29uc3QgdGVhY2hlcklkcyA9IG5ldyBTZXQ8c3RyaW5nPigpXHJcbiAgICAgICAgdGVhY2hlckNsYXNzU3ViamVjdHMuZm9yRWFjaCgoYXNzaWdubWVudDogYW55KSA9PiB0ZWFjaGVySWRzLmFkZChhc3NpZ25tZW50LnRlYWNoZXJJZCkpXHJcbiAgICAgICAgdHJhaW5lckNsYXNzTW9kdWxlcy5mb3JFYWNoKChhc3NpZ25tZW50OiBhbnkpID0+IHRlYWNoZXJJZHMuYWRkKGFzc2lnbm1lbnQudHJhaW5lcklkKSlcclxuXHJcbiAgICAgICAgcmV0dXJuIHRlYWNoZXJJZHNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvcnQgbGVzc29ucyBieSBwcmlvcml0eSBmb3Igb3B0aW1hbCBzY2hlZHVsaW5nIHdpdGggZnVsbCB0ZWFjaGVyIHNjb3BlIGNvbnNpZGVyYXRpb25cclxuICAgICAqIEVORk9SQ0UgQ09OU0VDVVRJVkUgRE9VQkxFIFBFUklPRFMgUlVMRSBwcmlvcml0eSBvcmRlcjpcclxuICAgICAqIDEpIFNQRUNJRklDIG1vZHVsZXMgKGRvdWJsZSBwZXJpb2RzLCBtb3JuaW5nKVxyXG4gICAgICogMikgR0VORVJBTCBtb2R1bGVzIChkb3VibGUgcGVyaW9kcywgbW9ybmluZylcclxuICAgICAqIDMpIE1hdGhlbWF0aWNzICYgUGh5c2ljcyAoZG91YmxlIHBlcmlvZHMpXHJcbiAgICAgKiA0KSBPdGhlciBzdWJqZWN0cyAoc2luZ2xlIG9yIGNvbmZpZ3VyZWQgYmxvY2spXHJcbiAgICAgKi9cclxuICAgIHNvcnRMZXNzb25zQnlQcmlvcml0eShsZXNzb25zOiBQcmVwYXJlZExlc3NvbltdKTogUHJlcGFyZWRMZXNzb25bXSB7XHJcbiAgICAgICAgcmV0dXJuIGxlc3NvbnMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAvLyBDUklUSUNBTDogQ29uc2lkZXIgdGVhY2hlciBzY29wZSB3aGVuIHByaW9yaXRpemluZ1xyXG4gICAgICAgICAgICAvLyBUZWFjaGVycyB3aXRoIGJyb2FkZXIgc2NvcGUgKG11bHRpcGxlIGNsYXNzZXMvc3ViamVjdHMpIGdldCBzY2hlZHVsaW5nIHByaW9yaXR5XHJcbiAgICAgICAgICAgIGNvbnN0IHRlYWNoZXJBU2NvcGUgPSB0aGlzLmNhbGN1bGF0ZVRlYWNoZXJTY29wZShsZXNzb25zLCBhLnRlYWNoZXJJZClcclxuICAgICAgICAgICAgY29uc3QgdGVhY2hlckJTY29wZSA9IHRoaXMuY2FsY3VsYXRlVGVhY2hlclNjb3BlKGxlc3NvbnMsIGIudGVhY2hlcklkKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVGVhY2hlcnMgd2l0aCBsYXJnZXIgc2NvcGUgZ2V0IGhpZ2hlciBwcmlvcml0eSB0byBwcmV2ZW50IGNvbmZsaWN0c1xyXG4gICAgICAgICAgICBjb25zdCBzY29wZVByaW9yaXR5ID0gdGVhY2hlckJTY29wZSAtIHRlYWNoZXJBU2NvcGVcclxuICAgICAgICAgICAgaWYgKHNjb3BlUHJpb3JpdHkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZVByaW9yaXR5XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEVORk9SQ0UgRkxFWElCTEUgQ09NUExFTUVOVEFSWSBNT0RVTEVTIFJVTEU6IFByaW9yaXR5IG9yZGVyIGZvciBzY2hlZHVsaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IGdldFNjaGVkdWxpbmdQcmlvcml0eSA9IChsZXNzb246IFByZXBhcmVkTGVzc29uKTogbnVtYmVyID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIDEpIFNQRUNJRklDIG1vZHVsZXMgKGhpZ2hlc3QgcHJpb3JpdHkpXHJcbiAgICAgICAgICAgICAgICBpZiAobGVzc29uLmxlc3NvblR5cGUgPT09ICdUU1MnICYmIGxlc3Nvbi5tb2R1bGVDYXRlZ29yeSA9PT0gJ1NQRUNJRklDJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAyKSBHRU5FUkFMIG1vZHVsZXMgXHJcbiAgICAgICAgICAgICAgICBpZiAobGVzc29uLmxlc3NvblR5cGUgPT09ICdUU1MnICYmIGxlc3Nvbi5tb2R1bGVDYXRlZ29yeSA9PT0gJ0dFTkVSQUwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIDMpIE1hdGhlbWF0aWNzICYgUGh5c2ljcyAoZG91YmxlIHBlcmlvZHMpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJqZWN0TmFtZSA9IChsZXNzb24uc3ViamVjdE5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgICAgIGlmIChsZXNzb24ubGVzc29uVHlwZSAhPT0gJ1RTUycgJiYgKHN1YmplY3ROYW1lLmluY2x1ZGVzKCdtYXRoZW1hdGljcycpIHx8IHN1YmplY3ROYW1lLmluY2x1ZGVzKCdwaHlzaWNzJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIDQpIE90aGVyIHJlcXVpcmVkIHN1YmplY3RzXHJcbiAgICAgICAgICAgICAgICBpZiAobGVzc29uLmxlc3NvblR5cGUgIT09ICdUU1MnICYmICEoc3ViamVjdE5hbWUuaW5jbHVkZXMoJ21hdGhlbWF0aWNzJykgfHwgc3ViamVjdE5hbWUuaW5jbHVkZXMoJ3BoeXNpY3MnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gNSkgQ09NUExFTUVOVEFSWSBtb2R1bGVzIChsb3dlc3QgcHJpb3JpdHkgLSBmaWxsIEZSRUUgc2xvdHMpXHJcbiAgICAgICAgICAgICAgICBpZiAobGVzc29uLmxlc3NvblR5cGUgPT09ICdUU1MnICYmIGxlc3Nvbi5tb2R1bGVDYXRlZ29yeSA9PT0gJ0NPTVBMRU1FTlRBUlknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgZmFsbGJhY2tcclxuICAgICAgICAgICAgICAgIHJldHVybiA2XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFQcmlvcml0eSA9IGdldFNjaGVkdWxpbmdQcmlvcml0eShhKVxyXG4gICAgICAgICAgICBjb25zdCBiUHJpb3JpdHkgPSBnZXRTY2hlZHVsaW5nUHJpb3JpdHkoYilcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChhUHJpb3JpdHkgIT09IGJQcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFQcmlvcml0eSAtIGJQcmlvcml0eVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXaXRoaW4gc2FtZSBwcmlvcml0eSBncm91cCwgc29ydCBieSBsZXNzb24gdHlwZVxyXG4gICAgICAgICAgICBjb25zdCB0eXBlUHJpb3JpdHkgPSB7IFRTUzogMywgU0VDT05EQVJZOiAyLCBQUklNQVJZOiAxIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVQcmlvcml0eVthLmxlc3NvblR5cGVdICE9PSB0eXBlUHJpb3JpdHlbYi5sZXNzb25UeXBlXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVQcmlvcml0eVtiLmxlc3NvblR5cGVdIC0gdHlwZVByaW9yaXR5W2EubGVzc29uVHlwZV1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRm9yIFRTUyBsZXNzb25zLCBzb3J0IGJ5IGNhdGVnb3J5IHByaW9yaXR5IChTUEVDSUZJQywgR0VORVJBTCwgQ09NUExFTUVOVEFSWSlcclxuICAgICAgICAgICAgaWYgKGEubGVzc29uVHlwZSA9PT0gJ1RTUycgJiYgYi5sZXNzb25UeXBlID09PSAnVFNTJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEucHJpb3JpdHkgIT09IGIucHJpb3JpdHkpIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIudG90YWxMZXNzb25zIC0gYS50b3RhbExlc3NvbnNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRm9yIHJlZ3VsYXIgc3ViamVjdHMsIHNvcnQgYnkgdG90YWwgbGVzc29ucyAoaGlnaGVyID0gbW9yZSB1cmdlbnQpXHJcbiAgICAgICAgICAgIHJldHVybiBiLnRvdGFsTGVzc29ucyAtIGEudG90YWxMZXNzb25zXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0ZWFjaGVyJ3Mgc2NvcGUgYWNyb3NzIHRoZSBlbnRpcmUgc2Nob29sIGZvciBzY2hlZHVsaW5nIHByaW9yaXR5XHJcbiAgICAgKiBUZWFjaGVycyB3aXRoIGJyb2FkZXIgc2NvcGUgZ2V0IGhpZ2hlciBwcmlvcml0eSB0byBwcmV2ZW50IGNvbmZsaWN0c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVRlYWNoZXJTY29wZShsZXNzb25zOiBQcmVwYXJlZExlc3NvbltdLCB0ZWFjaGVySWQ6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgY29uc3QgdGVhY2hlckxlc3NvbnMgPSBsZXNzb25zLmZpbHRlcihsZXNzb24gPT4gbGVzc29uLnRlYWNoZXJJZCA9PT0gdGVhY2hlcklkKVxyXG4gICAgICAgIGlmICh0ZWFjaGVyTGVzc29ucy5sZW5ndGggPT09IDApIHJldHVybiAwXHJcblxyXG4gICAgICAgIC8vIENvdW50IHVuaXF1ZSBjbGFzc2VzLCBzdWJqZWN0cy9tb2R1bGVzLCBhbmQgbGV2ZWxzIHRoZSB0ZWFjaGVyIHRlYWNoZXNcclxuICAgICAgICBjb25zdCB1bmlxdWVDbGFzc2VzID0gbmV3IFNldCh0ZWFjaGVyTGVzc29ucy5tYXAobCA9PiBsLmNsYXNzSWQpKS5zaXplXHJcbiAgICAgICAgY29uc3QgdW5pcXVlU3ViamVjdHMgPSBuZXcgU2V0KFxyXG4gICAgICAgICAgICB0ZWFjaGVyTGVzc29uc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihsID0+IGwuc3ViamVjdElkIHx8IGwubW9kdWxlSWQpXHJcbiAgICAgICAgICAgICAgICAubWFwKGwgPT4gbC5zdWJqZWN0SWQgfHwgbC5tb2R1bGVJZClcclxuICAgICAgICApLnNpemVcclxuICAgICAgICBjb25zdCB1bmlxdWVMZXZlbHMgPSBuZXcgU2V0KHRlYWNoZXJMZXNzb25zLm1hcChsID0+IGwubGV2ZWwpKS5zaXplXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzY29wZSBzY29yZSAoaGlnaGVyID0gYnJvYWRlciBzY29wZSlcclxuICAgICAgICAvLyBXZWlnaHQ6IGNsYXNzZXMgKiAzICsgc3ViamVjdHMgKiAyICsgbGV2ZWxzICogMVxyXG4gICAgICAgIGNvbnN0IHNjb3BlU2NvcmUgPSAodW5pcXVlQ2xhc3NlcyAqIDMpICsgKHVuaXF1ZVN1YmplY3RzICogMikgKyB1bmlxdWVMZXZlbHNcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhgVGVhY2hlciAke3RlYWNoZXJJZH0gc2NvcGU6ICR7dW5pcXVlQ2xhc3Nlc30gY2xhc3NlcywgJHt1bmlxdWVTdWJqZWN0c30gc3ViamVjdHMvbW9kdWxlcywgJHt1bmlxdWVMZXZlbHN9IGxldmVscyA9IHNjb3JlICR7c2NvcGVTY29yZX1gKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBzY29wZVNjb3JlXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgbGVzc29uIHN0YXRpc3RpY3MgZm9yIHJlcG9ydGluZ1xyXG4gICAgICovXHJcbiAgICBnZXRMZXNzb25TdGF0aXN0aWNzKGxlc3NvbnM6IFByZXBhcmVkTGVzc29uW10pIHtcclxuICAgICAgICBjb25zdCBzdGF0cyA9IHtcclxuICAgICAgICAgICAgdG90YWw6IGxlc3NvbnMubGVuZ3RoLFxyXG4gICAgICAgICAgICBieVR5cGU6IHtcclxuICAgICAgICAgICAgICAgIFBSSU1BUlk6IDAsXHJcbiAgICAgICAgICAgICAgICBTRUNPTkRBUlk6IDAsXHJcbiAgICAgICAgICAgICAgICBUU1M6IDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYnlMZXZlbDoge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPixcclxuICAgICAgICAgICAgYnlUZWFjaGVyOiB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxyXG4gICAgICAgICAgICBhdmVyYWdlTGVzc29uc1BlclRlYWNoZXI6IDAsXHJcbiAgICAgICAgICAgIG1heExlc3NvbnNQZXJUZWFjaGVyOiAwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0ZWFjaGVyTGVzc29uQ291bnQ6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fVxyXG5cclxuICAgICAgICBsZXNzb25zLmZvckVhY2gobGVzc29uID0+IHtcclxuICAgICAgICAgICAgLy8gQ291bnQgYnkgdHlwZVxyXG4gICAgICAgICAgICBzdGF0cy5ieVR5cGVbbGVzc29uLmxlc3NvblR5cGVdKytcclxuXHJcbiAgICAgICAgICAgIC8vIENvdW50IGJ5IGxldmVsXHJcbiAgICAgICAgICAgIHN0YXRzLmJ5TGV2ZWxbbGVzc29uLmxldmVsXSA9IChzdGF0cy5ieUxldmVsW2xlc3Nvbi5sZXZlbF0gfHwgMCkgKyAxXHJcblxyXG4gICAgICAgICAgICAvLyBDb3VudCBieSB0ZWFjaGVyXHJcbiAgICAgICAgICAgIGNvbnN0IHRlYWNoZXJLZXkgPSBsZXNzb24udGVhY2hlck5hbWUgfHwgbGVzc29uLnRlYWNoZXJJZFxyXG4gICAgICAgICAgICB0ZWFjaGVyTGVzc29uQ291bnRbdGVhY2hlcktleV0gPSAodGVhY2hlckxlc3NvbkNvdW50W3RlYWNoZXJLZXldIHx8IDApICsgMVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0ZWFjaGVyIHN0YXRpc3RpY3NcclxuICAgICAgICBjb25zdCB0ZWFjaGVyQ291bnRzID0gT2JqZWN0LnZhbHVlcyh0ZWFjaGVyTGVzc29uQ291bnQpXHJcbiAgICAgICAgc3RhdHMuYnlUZWFjaGVyID0gdGVhY2hlckxlc3NvbkNvdW50XHJcbiAgICAgICAgc3RhdHMuYXZlcmFnZUxlc3NvbnNQZXJUZWFjaGVyID0gdGVhY2hlckNvdW50cy5sZW5ndGggPiAwXHJcbiAgICAgICAgICAgID8gdGVhY2hlckNvdW50cy5yZWR1Y2UoKHN1bSwgY291bnQpID0+IHN1bSArIGNvdW50LCAwKSAvIHRlYWNoZXJDb3VudHMubGVuZ3RoXHJcbiAgICAgICAgICAgIDogMFxyXG4gICAgICAgIHN0YXRzLm1heExlc3NvbnNQZXJUZWFjaGVyID0gdGVhY2hlckNvdW50cy5sZW5ndGggPiAwXHJcbiAgICAgICAgICAgID8gTWF0aC5tYXgoLi4udGVhY2hlckNvdW50cylcclxuICAgICAgICAgICAgOiAwXHJcblxyXG4gICAgICAgIHJldHVybiBzdGF0c1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgbGVzc29uIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHBlci1jbGFzcyBhc3NpZ25tZW50c1xyXG4gICAgICovXHJcbiAgICBhc3luYyB2YWxpZGF0ZUxlc3NvbnMobGVzc29uczogUHJlcGFyZWRMZXNzb25bXSk6IFByb21pc2U8e1xyXG4gICAgICAgIGlzVmFsaWQ6IGJvb2xlYW5cclxuICAgICAgICBlcnJvcnM6IHN0cmluZ1tdXHJcbiAgICAgICAgd2FybmluZ3M6IHN0cmluZ1tdXHJcbiAgICB9PiB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdXHJcbiAgICAgICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW11cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRlYWNoZXJzL3RyYWluZXJzIHdpdGggbm8gYXNzaWdubWVudHNcclxuICAgICAgICAgICAgY29uc3QgdGVhY2hlcnNXaXRoTGVzc29ucyA9IG5ldyBTZXQobGVzc29ucy5tYXAobCA9PiBsLnRlYWNoZXJJZCkpXHJcbiAgICAgICAgICAgIGNvbnN0IGFsbFRlYWNoZXJzID0gYXdhaXQgZGIudXNlci5maW5kTWFueSh7XHJcbiAgICAgICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaG9vbElkOiB0aGlzLnNjaG9vbElkLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IHsgaW46IFsnVEVBQ0hFUicsICdUUkFJTkVSJ10gfSxcclxuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdW5hc3NpZ25lZFRlYWNoZXJzID0gYWxsVGVhY2hlcnMuZmlsdGVyKHQgPT4gIXRlYWNoZXJzV2l0aExlc3NvbnMuaGFzKHQuaWQpKVxyXG4gICAgICAgICAgICBpZiAodW5hc3NpZ25lZFRlYWNoZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goYCR7dW5hc3NpZ25lZFRlYWNoZXJzLmxlbmd0aH0gdGVhY2hlcnMvdHJhaW5lcnMgaGF2ZSBubyBwZXItY2xhc3MgbGVzc29uIGFzc2lnbm1lbnRzYClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNsYXNzZXMgd2l0aCBubyBsZXNzb25zICh0aGlzIGlzIG5vdyBtb3JlIGltcG9ydGFudClcclxuICAgICAgICAgICAgY29uc3QgY2xhc3Nlc1dpdGhMZXNzb25zID0gbmV3IFNldChsZXNzb25zLm1hcChsID0+IGwuY2xhc3NJZCkpXHJcbiAgICAgICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBhd2FpdCBkYi5jbGFzcy5maW5kTWFueSh7XHJcbiAgICAgICAgICAgICAgICB3aGVyZTogeyBzY2hvb2xJZDogdGhpcy5zY2hvb2xJZCB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzV2l0aG91dExlc3NvbnMgPSBhbGxDbGFzc2VzLmZpbHRlcihjID0+ICFjbGFzc2VzV2l0aExlc3NvbnMuaGFzKGMuaWQpKVxyXG4gICAgICAgICAgICBpZiAoY2xhc3Nlc1dpdGhvdXRMZXNzb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goYCR7Y2xhc3Nlc1dpdGhvdXRMZXNzb25zLmxlbmd0aH0gY2xhc3NlcyBoYXZlIG5vIGxlc3NvbnMgc2NoZWR1bGVkIC0gdGhleSBtYXkgbmVlZCB0ZWFjaGVyIGFzc2lnbm1lbnRzYClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhbnkgbGVzc29ucyBhdCBhbGxcclxuICAgICAgICAgICAgaWYgKGxlc3NvbnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCgnTm8gbGVzc29ucyBmb3VuZC4gUGxlYXNlIGNyZWF0ZSB0ZWFjaGVyLWNsYXNzIGFzc2lnbm1lbnRzIGZpcnN0LicpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgbGVzc29ucyBhcmUgcHJvcGVybHkgZGlzdHJpYnV0ZWRcclxuICAgICAgICAgICAgY29uc3QgbGVzc29uc0J5Q2xhc3MgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpXHJcbiAgICAgICAgICAgIGxlc3NvbnMuZm9yRWFjaChsZXNzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBsZXNzb25zQnlDbGFzcy5nZXQobGVzc29uLmNsYXNzSWQpIHx8IDBcclxuICAgICAgICAgICAgICAgIGxlc3NvbnNCeUNsYXNzLnNldChsZXNzb24uY2xhc3NJZCwgY291bnQgKyAxKVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgY29uc3QgY2xhc3Nlc1dpdGhMb3dMZXNzb25zID0gQXJyYXkuZnJvbShsZXNzb25zQnlDbGFzcy5lbnRyaWVzKCkpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbY2xhc3NJZCwgY291bnRdKSA9PiBjb3VudCA8IDUpIC8vIEFyYml0cmFyeSB0aHJlc2hvbGRcclxuICAgICAgICAgICAgICAgIC5tYXAoKFtjbGFzc0lkLCBjb3VudF0pID0+IGAke2NsYXNzSWR9ICgke2NvdW50fSBsZXNzb25zKWApXHJcblxyXG4gICAgICAgICAgICBpZiAoY2xhc3Nlc1dpdGhMb3dMZXNzb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goYFNvbWUgY2xhc3NlcyBoYXZlIHZlcnkgZmV3IGxlc3NvbnM6ICR7Y2xhc3Nlc1dpdGhMb3dMZXNzb25zLmpvaW4oJywgJyl9YClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdWYWxpZGF0aW9uIGVycm9yOicsIGVycm9yKVxyXG4gICAgICAgICAgICB3YXJuaW5ncy5wdXNoKCdVbmFibGUgdG8gY29tcGxldGUgZnVsbCB2YWxpZGF0aW9uIGR1ZSB0byBkYXRhYmFzZSBhY2Nlc3MgaXNzdWVzJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXHJcbiAgICAgICAgICAgIGVycm9ycyxcclxuICAgICAgICAgICAgd2FybmluZ3NcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcmVwYXJlIGxlc3NvbnMgZm9yIGEgc2Nob29sXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUxlc3NvbnNGb3JTY2hvb2woc2Nob29sSWQ6IHN0cmluZyk6IFByb21pc2U8e1xyXG4gICAgbGVzc29uczogUHJlcGFyZWRMZXNzb25bXVxyXG4gICAgc3RhdGlzdGljczogYW55XHJcbiAgICB2YWxpZGF0aW9uOiBhbnlcclxufT4ge1xyXG4gICAgY29uc3Qgc2VydmljZSA9IG5ldyBMZXNzb25QcmVwYXJhdGlvblNlcnZpY2Uoc2Nob29sSWQpXHJcbiAgICBjb25zdCBsZXNzb25zID0gYXdhaXQgc2VydmljZS5wcmVwYXJlTGVzc29ucygpXHJcbiAgICBjb25zdCBzb3J0ZWRMZXNzb25zID0gc2VydmljZS5zb3J0TGVzc29uc0J5UHJpb3JpdHkobGVzc29ucylcclxuICAgIGNvbnN0IHN0YXRpc3RpY3MgPSBzZXJ2aWNlLmdldExlc3NvblN0YXRpc3RpY3Moc29ydGVkTGVzc29ucylcclxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCBzZXJ2aWNlLnZhbGlkYXRlTGVzc29ucyhzb3J0ZWRMZXNzb25zKVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVzc29uczogc29ydGVkTGVzc29ucyxcclxuICAgICAgICBzdGF0aXN0aWNzLFxyXG4gICAgICAgIHZhbGlkYXRpb25cclxuICAgIH1cclxufSJdLCJuYW1lcyI6WyJkYiIsImdldE1vZHVsZUNhdGVnb3J5UHJpb3JpdHkiLCJMZXNzb25QcmVwYXJhdGlvblNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsInNjaG9vbElkIiwicHJlcGFyZUxlc3NvbnMiLCJzY2hvb2wiLCJmaW5kVW5pcXVlIiwid2hlcmUiLCJpZCIsIkVycm9yIiwibGVzc29ucyIsInRlYWNoZXJDbGFzc1N1YmplY3RzIiwidGVhY2hlckNsYXNzU3ViamVjdCIsImZpbmRNYW55IiwiaW5jbHVkZSIsInRlYWNoZXIiLCJzdWJqZWN0IiwiY2xhc3MiLCJ0cmFpbmVyQ2xhc3NNb2R1bGVzIiwidHJhaW5lckNsYXNzTW9kdWxlIiwidHJhaW5lciIsIm1vZHVsZSIsImFzc2lnbm1lbnQiLCJzY2hvb2xUeXBlIiwiZGV0ZXJtaW5lU2Nob29sVHlwZSIsImxldmVsIiwicGVyaW9kc1BlcldlZWsiLCJibG9ja1NpemUiLCJudW1CbG9ja3MiLCJNYXRoIiwiY2VpbCIsImkiLCJwZXJpb2RzSW5UaGlzQmxvY2siLCJtaW4iLCJwdXNoIiwidGVhY2hlcklkIiwic3ViamVjdElkIiwiY2xhc3NJZCIsImxlc3NvbkluZGV4IiwidG90YWxMZXNzb25zIiwibGVzc29uVHlwZSIsInByaW9yaXR5IiwicHJlZmVycmVkVGltZSIsInN0cmVhbVR5cGUiLCJ0ZWFjaGVyTmFtZSIsIm5hbWUiLCJzdWJqZWN0TmFtZSIsImNsYXNzTmFtZSIsInRvdGFsSG91cnMiLCJpc0NvbXBsZW1lbnRhcnkiLCJjYXRlZ29yeSIsInRyYWluZXJJZCIsIm1vZHVsZUlkIiwibW9kdWxlQ2F0ZWdvcnkiLCJtb2R1bGVOYW1lIiwiaW5jbHVkZXMiLCJzdGFydHNXaXRoIiwiZ2V0Q2xhc3Nlc1dpdGhBc3NpZ25tZW50cyIsInNlbGVjdCIsImNsYXNzSWRzIiwiU2V0IiwiZm9yRWFjaCIsImFkZCIsImdldEFzc2lnbmVkVGVhY2hlcnMiLCJ0ZWFjaGVySWRzIiwic29ydExlc3NvbnNCeVByaW9yaXR5Iiwic29ydCIsImEiLCJiIiwidGVhY2hlckFTY29wZSIsImNhbGN1bGF0ZVRlYWNoZXJTY29wZSIsInRlYWNoZXJCU2NvcGUiLCJzY29wZVByaW9yaXR5IiwiZ2V0U2NoZWR1bGluZ1ByaW9yaXR5IiwibGVzc29uIiwidG9Mb3dlckNhc2UiLCJhUHJpb3JpdHkiLCJiUHJpb3JpdHkiLCJ0eXBlUHJpb3JpdHkiLCJUU1MiLCJTRUNPTkRBUlkiLCJQUklNQVJZIiwidGVhY2hlckxlc3NvbnMiLCJmaWx0ZXIiLCJsZW5ndGgiLCJ1bmlxdWVDbGFzc2VzIiwibWFwIiwibCIsInNpemUiLCJ1bmlxdWVTdWJqZWN0cyIsInVuaXF1ZUxldmVscyIsInNjb3BlU2NvcmUiLCJjb25zb2xlIiwibG9nIiwiZ2V0TGVzc29uU3RhdGlzdGljcyIsInN0YXRzIiwidG90YWwiLCJieVR5cGUiLCJieUxldmVsIiwiYnlUZWFjaGVyIiwiYXZlcmFnZUxlc3NvbnNQZXJUZWFjaGVyIiwibWF4TGVzc29uc1BlclRlYWNoZXIiLCJ0ZWFjaGVyTGVzc29uQ291bnQiLCJ0ZWFjaGVyS2V5IiwidGVhY2hlckNvdW50cyIsIk9iamVjdCIsInZhbHVlcyIsInJlZHVjZSIsInN1bSIsImNvdW50IiwibWF4IiwidmFsaWRhdGVMZXNzb25zIiwiZXJyb3JzIiwid2FybmluZ3MiLCJ0ZWFjaGVyc1dpdGhMZXNzb25zIiwiYWxsVGVhY2hlcnMiLCJ1c2VyIiwicm9sZSIsImluIiwiaXNBY3RpdmUiLCJ1bmFzc2lnbmVkVGVhY2hlcnMiLCJ0IiwiaGFzIiwiY2xhc3Nlc1dpdGhMZXNzb25zIiwiYWxsQ2xhc3NlcyIsImNsYXNzZXNXaXRob3V0TGVzc29ucyIsImMiLCJsZXNzb25zQnlDbGFzcyIsIk1hcCIsImdldCIsInNldCIsImNsYXNzZXNXaXRoTG93TGVzc29ucyIsIkFycmF5IiwiZnJvbSIsImVudHJpZXMiLCJqb2luIiwiZXJyb3IiLCJpc1ZhbGlkIiwicHJlcGFyZUxlc3NvbnNGb3JTY2hvb2wiLCJzZXJ2aWNlIiwic29ydGVkTGVzc29ucyIsInN0YXRpc3RpY3MiLCJ2YWxpZGF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/lesson-preparation.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/timetable-generator.ts":
/*!****************************************!*\
  !*** ./src/lib/timetable-generator.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TimetableGenerator: () => (/* binding */ TimetableGenerator),\n/* harmony export */   generateTimetable: () => (/* binding */ generateTimetable),\n/* harmony export */   generateTimetableForClass: () => (/* binding */ generateTimetableForClass),\n/* harmony export */   generateTimetableForTeacher: () => (/* binding */ generateTimetableForTeacher)\n/* harmony export */ });\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/db */ \"(rsc)/./src/lib/db.ts\");\n/* harmony import */ var _lib_lesson_preparation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/lesson-preparation */ \"(rsc)/./src/lib/lesson-preparation.ts\");\n\n\nclass TimetableGenerator {\n    constructor(schoolId){\n        this.scheduledLessons = [];\n        this.teacherAvailability = {};\n        this.classAvailability = {};\n        this.conflicts = [];\n        this.timeSlotsCache = [] // Cache time slots for break checking\n        ;\n        this.schoolId = schoolId;\n    }\n    async generate() {\n        try {\n            // Clear existing timetables for full school generation\n            await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timetable.deleteMany({\n                where: {\n                    schoolId: this.schoolId\n                }\n            });\n            // Initialize availability maps\n            await this.initializeAvailability();\n            // Load prepared lessons\n            const { lessons: preparedLessons } = await (0,_lib_lesson_preparation__WEBPACK_IMPORTED_MODULE_1__.prepareLessonsForSchool)(this.schoolId);\n            // Sort by priority and time preference with TSS rules\n            const sortedLessons = this.sortLessonsByPriorityAndTime(preparedLessons);\n            // Load time slots for validation\n            const timeSlots = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timeSlot.findMany({\n                where: {\n                    schoolId: this.schoolId,\n                    isActive: true\n                },\n                orderBy: [\n                    {\n                        day: \"asc\"\n                    },\n                    {\n                        period: \"asc\"\n                    }\n                ]\n            });\n            const validTimeSlots = timeSlots.filter((ts)=>{\n                const period = ts.period;\n                const day = ts.day;\n                const isValidPeriod = period >= 1 && period <= 10;\n                const isValidDay = day !== \"SATURDAY\" && [\n                    \"MONDAY\",\n                    \"TUESDAY\",\n                    \"WEDNESDAY\",\n                    \"THURSDAY\",\n                    \"FRIDAY\"\n                ].includes(day);\n                const isNotBreak = !ts.isBreak;\n                return isValidPeriod && isValidDay && isNotBreak;\n            });\n            const totalPeriods = sortedLessons.reduce((sum, lesson)=>sum + (lesson.blockSize || 1), 0);\n            if (validTimeSlots.length < totalPeriods) {\n                return {\n                    success: false,\n                    conflicts: [\n                        {\n                            type: \"unassigned\",\n                            message: `Not enough time slots available. Required: ${totalPeriods} periods, Available: ${validTimeSlots.length} slots. Please add more time slots or reduce lesson assignments.`\n                        }\n                    ]\n                };\n            }\n            // Schedule each lesson\n            for (const lesson of sortedLessons){\n                await this.scheduleLesson(lesson);\n            }\n            // Save all scheduled lessons to database\n            await this.saveToDatabase();\n            return {\n                success: true,\n                conflicts: this.conflicts\n            };\n        } catch (error) {\n            console.error(\"Timetable generation failed:\", error);\n            return {\n                success: false,\n                conflicts: [\n                    ...this.conflicts,\n                    {\n                        type: \"unassigned\",\n                        message: \"Timetable generation failed due to an internal error\"\n                    }\n                ]\n            };\n        }\n    }\n    async generateForClass(classId, options = {}) {\n        try {\n            const { incremental = false, regenerate = false } = options;\n            // For incremental mode, preserve existing timetables unless regenerate is true\n            if (!incremental || regenerate) {\n                // Clear existing timetables for this specific class only\n                await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timetable.deleteMany({\n                    where: {\n                        schoolId: this.schoolId,\n                        classId: classId\n                    }\n                });\n            }\n            // Initialize availability maps with existing timetables from OTHER classes only\n            await this.initializeAvailabilityWithExistingTimetables(classId);\n            // Load prepared lessons for the specific class only\n            const { lessons: preparedLessons } = await (0,_lib_lesson_preparation__WEBPACK_IMPORTED_MODULE_1__.prepareLessonsForSchool)(this.schoolId);\n            const classLessons = preparedLessons.filter((lesson)=>lesson.classId === classId);\n            if (classLessons.length === 0) {\n                return {\n                    success: false,\n                    conflicts: [\n                        {\n                            type: \"unassigned\",\n                            message: \"No lessons found for the selected class\"\n                        }\n                    ]\n                };\n            }\n            // Sort by priority and time preference\n            const sortedLessons = this.sortLessonsByPriorityAndTime(classLessons);\n            // Load time slots for validation\n            const timeSlots = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timeSlot.findMany({\n                where: {\n                    schoolId: this.schoolId,\n                    isActive: true\n                },\n                orderBy: [\n                    {\n                        day: \"asc\"\n                    },\n                    {\n                        period: \"asc\"\n                    }\n                ]\n            });\n            const validTimeSlots = timeSlots.filter((ts)=>{\n                const period = ts.period;\n                const day = ts.day;\n                const isValidPeriod = period >= 1 && period <= 10;\n                const isValidDay = day !== \"SATURDAY\" && [\n                    \"MONDAY\",\n                    \"TUESDAY\",\n                    \"WEDNESDAY\",\n                    \"THURSDAY\",\n                    \"FRIDAY\"\n                ].includes(day);\n                const isNotBreak = !ts.isBreak;\n                return isValidPeriod && isValidDay && isNotBreak;\n            });\n            const totalPeriods = sortedLessons.reduce((sum, lesson)=>sum + (lesson.blockSize || 1), 0);\n            if (validTimeSlots.length < totalPeriods) {\n                return {\n                    success: false,\n                    conflicts: [\n                        {\n                            type: \"unassigned\",\n                            message: `Not enough time slots available for class. Required: ${totalPeriods} periods, Available: ${validTimeSlots.length} slots. Please add more time slots or reduce lesson assignments for this class.`\n                        }\n                    ]\n                };\n            }\n            // Schedule each lesson\n            for (const lesson of sortedLessons){\n                await this.scheduleLesson(lesson);\n            }\n            // Save all scheduled lessons to database\n            await this.saveToDatabase();\n            return {\n                success: true,\n                conflicts: this.conflicts\n            };\n        } catch (error) {\n            console.error(\"Timetable generation for class failed:\", error);\n            return {\n                success: false,\n                conflicts: [\n                    ...this.conflicts,\n                    {\n                        type: \"unassigned\",\n                        message: \"Timetable generation for class failed due to an internal error\"\n                    }\n                ]\n            };\n        }\n    }\n    async generateForTeacher(teacherId, options = {}) {\n        try {\n            const { incremental = false, regenerate = false } = options;\n            // For incremental mode, preserve existing timetables unless regenerate is true\n            if (!incremental || regenerate) {\n                // Clear existing timetables for this teacher across ALL classes\n                await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timetable.deleteMany({\n                    where: {\n                        schoolId: this.schoolId,\n                        teacherId: teacherId\n                    }\n                });\n            }\n            // Initialize availability maps with existing timetables from OTHER teachers only\n            await this.initializeAvailabilityWithExistingTimetables(undefined, teacherId);\n            // Load prepared lessons for the specific teacher only\n            const { lessons: preparedLessons } = await (0,_lib_lesson_preparation__WEBPACK_IMPORTED_MODULE_1__.prepareLessonsForSchool)(this.schoolId);\n            const teacherLessons = preparedLessons.filter((lesson)=>lesson.teacherId === teacherId);\n            if (teacherLessons.length === 0) {\n                return {\n                    success: false,\n                    conflicts: [\n                        {\n                            type: \"unassigned\",\n                            message: \"No lessons found for the selected teacher\"\n                        }\n                    ]\n                };\n            }\n            // Sort by priority and time preference\n            const sortedLessons = this.sortLessonsByPriorityAndTime(teacherLessons);\n            // Schedule each lesson\n            for (const lesson of sortedLessons){\n                await this.scheduleLesson(lesson);\n            }\n            // Save all scheduled lessons to database\n            await this.saveToDatabase();\n            return {\n                success: true,\n                conflicts: this.conflicts\n            };\n        } catch (error) {\n            console.error(\"Timetable generation for teacher failed:\", error);\n            return {\n                success: false,\n                conflicts: [\n                    ...this.conflicts,\n                    {\n                        type: \"unassigned\",\n                        message: \"Timetable generation for teacher failed due to an internal error\"\n                    }\n                ]\n            };\n        }\n    }\n    async initializeAvailability() {\n        // Get all time slots for the school\n        const timeSlots = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timeSlot.findMany({\n            where: {\n                schoolId: this.schoolId,\n                isActive: true\n            },\n            orderBy: [\n                {\n                    day: \"asc\"\n                },\n                {\n                    period: \"asc\"\n                }\n            ]\n        });\n        // Cache time slots for break checking\n        this.timeSlotsCache = timeSlots;\n        // Initialize teacher and trainer availability\n        const teachersAndTrainers = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.user.findMany({\n            where: {\n                schoolId: this.schoolId,\n                role: {\n                    in: [\n                        \"TEACHER\",\n                        \"TRAINER\"\n                    ]\n                },\n                isActive: true\n            }\n        });\n        teachersAndTrainers.forEach((person)=>{\n            this.teacherAvailability[person.id] = new Set();\n        });\n        // Initialize class availability\n        const classes = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.class.findMany({\n            where: {\n                schoolId: this.schoolId\n            }\n        });\n        classes.forEach((cls)=>{\n            this.classAvailability[cls.id] = new Set();\n        });\n    }\n    async initializeAvailabilityWithExistingTimetables(excludeClassId, excludeTeacherId) {\n        // Get all time slots for the school\n        const timeSlots = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timeSlot.findMany({\n            where: {\n                schoolId: this.schoolId,\n                isActive: true\n            },\n            orderBy: [\n                {\n                    day: \"asc\"\n                },\n                {\n                    period: \"asc\"\n                }\n            ]\n        });\n        // Cache time slots for break checking\n        this.timeSlotsCache = timeSlots;\n        // Initialize teacher and trainer availability\n        const teachersAndTrainers = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.user.findMany({\n            where: {\n                schoolId: this.schoolId,\n                role: {\n                    in: [\n                        \"TEACHER\",\n                        \"TRAINER\"\n                    ]\n                },\n                isActive: true\n            }\n        });\n        teachersAndTrainers.forEach((person)=>{\n            this.teacherAvailability[person.id] = new Set();\n        });\n        // Initialize class availability\n        const classes = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.class.findMany({\n            where: {\n                schoolId: this.schoolId\n            }\n        });\n        classes.forEach((cls)=>{\n            this.classAvailability[cls.id] = new Set();\n        });\n        // Load existing timetables with exclusions\n        const existingTimetablesWhereClause = {\n            schoolId: this.schoolId\n        };\n        // Apply exclusions for class-specific or teacher-specific generation\n        if (excludeClassId) {\n            existingTimetablesWhereClause.classId = {\n                not: excludeClassId\n            };\n        }\n        if (excludeTeacherId) {\n            existingTimetablesWhereClause.teacherId = {\n                not: excludeTeacherId\n            };\n        }\n        const existingTimetables = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timetable.findMany({\n            where: existingTimetablesWhereClause,\n            include: {\n                timeSlot: {\n                    select: {\n                        day: true,\n                        period: true\n                    }\n                },\n                class: {\n                    select: {\n                        name: true\n                    }\n                },\n                teacher: {\n                    select: {\n                        name: true\n                    }\n                }\n            }\n        });\n        // Mark occupied slots from existing timetables (global teacher availability)\n        for (const timetable of existingTimetables){\n            const slotKey = `${timetable.timeSlot.day}-${timetable.timeSlot.period}`;\n            // Mark teacher as unavailable (global across all classes)\n            this.teacherAvailability[timetable.teacherId].add(slotKey);\n            // Mark class as unavailable\n            this.classAvailability[timetable.classId].add(slotKey);\n        }\n        console.log(`Loaded ${existingTimetables.length} existing timetable entries for global teacher availability check`);\n    }\n    sortLessonsByPriorityAndTime(lessons) {\n        return lessons.sort((a, b)=>{\n            // PRIORITY ORDER (FINAL)\n            // 1) SPECIFIC modules (double periods)\n            // 2) GENERAL modules (double periods)\n            // 3) Mathematics & Physics (double periods)\n            // 4) Other required subjects\n            // 5) COMPLEMENTARY modules (fill FREE slots)\n            // First, handle TSS modules by category\n            if (a.lessonType === \"TSS\" && b.lessonType === \"TSS\") {\n                const categoryOrder = {\n                    \"SPECIFIC\": 1,\n                    \"GENERAL\": 2,\n                    \"COMPLEMENTARY\": 5\n                };\n                const aCategory = a.moduleCategory || \"COMPLEMENTARY\";\n                const bCategory = b.moduleCategory || \"COMPLEMENTARY\";\n                if (categoryOrder[aCategory] !== categoryOrder[bCategory]) {\n                    return categoryOrder[aCategory] - categoryOrder[bCategory];\n                }\n                // Same category, prefer morning lessons\n                if (a.preferredTime !== b.preferredTime) {\n                    if (a.preferredTime === \"MORNING\") return -1;\n                    if (b.preferredTime === \"MORNING\") return 1;\n                }\n            } else if (a.lessonType === \"TSS\") {\n                // TSS has higher priority than regular subjects\n                return -1;\n            } else if (b.lessonType === \"TSS\") {\n                return 1;\n            }\n            // For regular subjects, prioritize Mathematics and Physics\n            const isMathPhysicsA = a.subjectName?.toLowerCase().includes(\"mathematics\") || a.subjectName?.toLowerCase().includes(\"physics\");\n            const isMathPhysicsB = b.subjectName?.toLowerCase().includes(\"mathematics\") || b.subjectName?.toLowerCase().includes(\"physics\");\n            if (isMathPhysicsA && !isMathPhysicsB) return -1;\n            if (!isMathPhysicsA && isMathPhysicsB) return 1;\n            // For non-priority subjects, sort by periods per week (higher = more urgent)\n            if (a.priority !== b.priority) {\n                return b.priority - a.priority;\n            }\n            // Finally by total lessons (higher first)\n            return b.totalLessons - a.totalLessons;\n        });\n    }\n    async scheduleLesson(lesson) {\n        const { periodsPerWeek = 2, blockSize = 2 } = lesson;\n        console.log(` STARTING LESSON SCHEDULING: Enforcing STRICT 08:00-16:50 time window (P1-P10 only)`);\n        const timeSlots = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timeSlot.findMany({\n            where: {\n                schoolId: this.schoolId,\n                isActive: true\n            },\n            orderBy: [\n                {\n                    day: \"asc\"\n                },\n                {\n                    period: \"asc\"\n                }\n            ]\n        });\n        console.log(` TOTAL TIME SLOTS LOADED: ${timeSlots.length} slots for school ${this.schoolId}`);\n        // Get teacher availability constraints and current workload\n        const teacherConstraints = await this.getTeacherConstraints(lesson.teacherId);\n        const teacherWorkload = await this.getTeacherWorkload(lesson.teacherId);\n        // Determine morning preference for TSS modules\n        const isTSSModule = lesson.lessonType === \"TSS\";\n        const prefersMorning = isTSSModule;\n        // CRITICAL: Get teacher's ALL assignments across school for scope validation\n        const teacherAllAssignments = await this.getTeacherAllAssignments(lesson.teacherId);\n        const teacherClasses = new Set(teacherAllAssignments.map((a)=>a.classId));\n        const teacherSubjects = new Set([\n            ...teacherAllAssignments.filter((a)=>a.subjectId).map((a)=>a.subjectId),\n            ...teacherAllAssignments.filter((a)=>a.moduleId).map((a)=>a.moduleId)\n        ]);\n        console.log(`Scheduling ${lesson.subjectId || lesson.moduleId} - block of ${blockSize} periods (${lesson.lessonIndex}/${lesson.totalLessons})`);\n        // ENFORCE FLEXIBLE COMPLEMENTARY MODULES RULE\n        // Check if this is a complementary module\n        const isComplementary = lesson.lessonType === \"TSS\" && lesson.moduleCategory === \"COMPLEMENTARY\";\n        // ENFORCE CORE TIME RULE: STRICTLY enforce 08:00-16:50 time window\n        // Only allow periods P1-P10 (08:00-16:50) and Monday-Friday only\n        // NO EXCEPTIONS - all lessons MUST be within this time frame\n        const validTimeSlots = timeSlots.filter((ts)=>{\n            const period = ts.period;\n            const day = ts.day;\n            const isValidPeriod = period >= 1 && period <= 10;\n            const isValidDay = day !== \"SATURDAY\" && [\n                \"MONDAY\",\n                \"TUESDAY\",\n                \"WEDNESDAY\",\n                \"THURSDAY\",\n                \"FRIDAY\"\n            ].includes(day);\n            const isNotBreak = !ts.isBreak;\n            // Log invalid slots for debugging\n            if (!isValidPeriod || !isValidDay || !isNotBreak) {\n                console.log(` INVALID SLOT FILTERED: ${day} P${period} - ValidPeriod: ${isValidPeriod}, ValidDay: ${isValidDay}, NotBreak: ${isNotBreak}`);\n            }\n            return isValidPeriod && isValidDay && isNotBreak;\n        });\n        console.log(` VALID TIME SLOTS FOUND: ${validTimeSlots.length} slots (P1-P10, Mon-Fri, no breaks)`);\n        // Try to find available slot with improved distribution across the week\n        // CRITICAL: Only use slots within 08:00-16:50 time window\n        // First pass: try morning slots for modules that prefer them (TSS Priority Rule)\n        let slotsToTry = prefersMorning ? [\n            ...validTimeSlots.filter((ts)=>ts.session === \"MORNING\"),\n            ...validTimeSlots.filter((ts)=>ts.session !== \"MORNING\")\n        ] : validTimeSlots;\n        // FINAL VALIDATION: Ensure no slot outside 08:00-16:50 gets through\n        slotsToTry = slotsToTry.filter((ts)=>{\n            const period = ts.period;\n            const day = ts.day;\n            const isWithinTimeWindow = period >= 1 && period <= 10 && day !== \"SATURDAY\";\n            if (!isWithinTimeWindow) {\n                console.log(` SLOT FILTERED OUT: ${day} P${period} - Outside 08:00-16:50 window`);\n            }\n            return isWithinTimeWindow;\n        });\n        // Update cache for break checking\n        this.timeSlotsCache = timeSlots;\n        // Sort slots to distribute lessons evenly across the week\n        slotsToTry = this.sortSlotsForEvenDistribution(slotsToTry, lesson.teacherId, lesson.classId);\n        for (const timeSlot of slotsToTry){\n            const ts = timeSlot// Cast to access new fields\n            ;\n            const slotKey = `${timeSlot.day}-${timeSlot.period}`;\n            // Check teacher unavailable days\n            if (teacherConstraints.unavailableDays?.includes(timeSlot.day)) continue;\n            // Check teacher unavailable periods\n            if (teacherConstraints.unavailablePeriods?.includes(ts.period.toString())) continue;\n            // ENFORCE DOUBLE PERIODS RULE FOR SPECIFIC AND GENERAL MODULES\n            // COMPLEMENTARY modules fill remaining free spaces\n            let canScheduleBlockSize = blockSize;\n            const isSpecificOrGeneral = lesson.lessonType === \"TSS\" && (lesson.moduleCategory === \"SPECIFIC\" || lesson.moduleCategory === \"GENERAL\");\n            if (isComplementary) {\n                // COMPLEMENTARY MODULES: Fill remaining free spaces - prioritize single periods to avoid conflicts\n                // Try single periods first (to avoid conflicts), use double periods only if available\n                if (this.canScheduleBlock(lesson.teacherId, lesson.classId, timeSlot.day, timeSlot.period, 1)) {\n                    canScheduleBlockSize = 1 // Prefer single periods to avoid conflicts\n                    ;\n                } else if (this.canScheduleBlock(lesson.teacherId, lesson.classId, timeSlot.day, timeSlot.period, 2)) {\n                    canScheduleBlockSize = 2 // Use double periods only if single not available\n                    ;\n                } else {\n                    continue; // No available slot at all\n                }\n            } else if (isSpecificOrGeneral) {\n                // SPECIFIC AND GENERAL MODULES: Use the prepared block size, with flexibility for odd periods\n                const periodsPerWeek = lesson.periodsPerWeek || 2;\n                const blockSize = lesson.blockSize || 2;\n                const isOddPeriods = periodsPerWeek % 2 === 1;\n                // Try the exact block size first\n                if (this.canScheduleBlock(lesson.teacherId, lesson.classId, timeSlot.day, timeSlot.period, blockSize)) {\n                    canScheduleBlockSize = blockSize;\n                } else if (blockSize === 2) {\n                    // If 2 not available, try 1 period\n                    if (this.canScheduleBlock(lesson.teacherId, lesson.classId, timeSlot.day, timeSlot.period, 1)) {\n                        canScheduleBlockSize = 1;\n                    } else {\n                        continue; // No available slot\n                    }\n                } else {\n                    continue;\n                }\n            } else {\n                // Other modules (regular subjects): use configured block size\n                if (!this.canScheduleBlock(lesson.teacherId, lesson.classId, timeSlot.day, timeSlot.period, blockSize)) {\n                    continue;\n                }\n            }\n            // CRITICAL: Check global teacher availability (respects ALL existing timetables across school)\n            const teacherAvailable = !this.teacherAvailability[lesson.teacherId]?.has(slotKey);\n            // Check class availability\n            const classAvailable = !this.classAvailability[lesson.classId]?.has(slotKey);\n            // Check max consecutive periods rule for this teacher\n            const respectsConsecutiveRule = this.canScheduleConsecutive(lesson.teacherId, timeSlot.day, timeSlot.period, 1);\n            // Enhanced scope validation: Check if teacher would be over-scheduled across all their classes\n            const respectsWorkloadBalance = this.isWorkloadBalanced(lesson.teacherId, lesson.classId, timeSlot.day);\n            if (teacherAvailable && classAvailable && respectsConsecutiveRule && respectsWorkloadBalance) {\n                // Schedule the block of consecutive periods\n                for(let i = 0; i < canScheduleBlockSize; i++){\n                    const currentPeriod = timeSlot.period + i;\n                    const currentSlotKey = `${timeSlot.day}-${currentPeriod}`;\n                    // Get the timeSlotId for this period (assuming periods are consecutive)\n                    const currentTimeSlot = timeSlots.find((ts)=>ts.day === timeSlot.day && ts.period === currentPeriod);\n                    if (!currentTimeSlot) continue;\n                    this.scheduledLessons.push({\n                        teacherId: lesson.teacherId,\n                        subjectId: lesson.subjectId,\n                        moduleId: lesson.moduleId,\n                        classId: lesson.classId,\n                        slot: {\n                            day: timeSlot.day,\n                            period: currentPeriod,\n                            timeSlotId: currentTimeSlot.id\n                        },\n                        priority: lesson.priority\n                    });\n                    // Mark as occupied in both teacher and class availability\n                    this.teacherAvailability[lesson.teacherId].add(currentSlotKey);\n                    this.classAvailability[lesson.classId].add(currentSlotKey);\n                }\n                const blockDescription = isComplementary && canScheduleBlockSize === 1 ? `CONFLICT-AVOID: 1 period` : `${canScheduleBlockSize} periods`;\n                console.log(` Scheduled ${blockDescription} for ${lesson.subjectId || lesson.moduleId} at ${slotKey}`);\n                return;\n            }\n        }\n        // No available slot found - flag unresolved conflict\n        const teacherName = lesson.teacherName || await this.getTeacherName(lesson.teacherId);\n        const className = lesson.className || await this.getClassName(lesson.classId);\n        const subjectName = lesson.subjectName || lesson.moduleName || (lesson.subjectId ? await this.getSubjectName(lesson.subjectId) : lesson.moduleId ? await this.getModuleName(lesson.moduleId) : \"Unknown\");\n        // Enhanced conflict analysis\n        const isGlobalConflict = this.isTeacherOverbooked(lesson.teacherId);\n        const hasMultipleClasses = teacherClasses.size > 1;\n        const hasMultipleSubjects = teacherSubjects.size > 1;\n        const scopeConflict = hasMultipleClasses || hasMultipleSubjects;\n        const isSpecificOrGeneral = lesson.lessonType === \"TSS\" && (lesson.moduleCategory === \"SPECIFIC\" || lesson.moduleCategory === \"GENERAL\");\n        let conflictDetail = \"\";\n        if (scopeConflict) {\n            const details = [];\n            if (hasMultipleClasses) details.push(`${teacherClasses.size} classes`);\n            if (hasMultipleSubjects) details.push(`${teacherSubjects.size} subjects/modules`);\n            conflictDetail = ` - Teacher scope: ${details.join(\", \")}`;\n        }\n        // ENFORCE DOUBLE PERIODS RULE: Different messaging based on module type\n        let conflictMessage;\n        let conflictSuggestions;\n        if (isSpecificOrGeneral) {\n            // SPECIFIC AND GENERAL MODULES: Consecutive periods based on periods per week\n            const isOddPeriods = (lesson.periodsPerWeek || 2) % 2 === 1;\n            if (isOddPeriods) {\n                // For odd periods per week: min 2, max 3 consecutive periods\n                conflictMessage = `Could not schedule ${subjectName} (REQUIRES 2 or 3 consecutive periods - SPECIFIC/GENERAL module with odd periods per week) for ${teacherName} in ${className}${conflictDetail}`;\n                conflictSuggestions = [\n                    \"CRITICAL: SPECIFIC and GENERAL modules with odd periods per week MUST have 2 or 3 consecutive periods\",\n                    \"Tried 2 periods first, then 3 periods\",\n                    \"Add more consecutive free slots in P1-P10 range (2 or 3 consecutive periods)\",\n                    \"Ensure no breaks interrupt the required consecutive period blocks\",\n                    \"Check teacher availability for consecutive morning slots\",\n                    \"Reduce teacher workload to free up consecutive periods\",\n                    \"Consider rescheduling other lessons to create 2-3 period blocks\",\n                    ...scopeConflict ? [\n                        `Teacher teaches across ${teacherClasses.size} classes and ${teacherSubjects.size} subjects/modules - may need workload redistribution`\n                    ] : [],\n                    \"SOLUTION: Ensure at least 2 or 3 consecutive free periods exist in teacher/class schedule\"\n                ];\n            } else {\n                // For even periods per week: 2 consecutive periods\n                conflictMessage = `Could not schedule ${subjectName} (REQUIRES 2 consecutive periods - SPECIFIC/GENERAL module) for ${teacherName} in ${className}${conflictDetail}`;\n                conflictSuggestions = [\n                    \"CRITICAL: SPECIFIC and GENERAL modules MUST have 2 consecutive periods\",\n                    \"Add more consecutive free slots in P1-P10 range\",\n                    \"Ensure no breaks interrupt the required 2-period blocks\",\n                    \"Check teacher availability for consecutive morning slots\",\n                    \"Reduce teacher workload to free up consecutive periods\",\n                    \"Consider rescheduling other lessons to create 2-period blocks\",\n                    ...scopeConflict ? [\n                        `Teacher teaches across ${teacherClasses.size} classes and ${teacherSubjects.size} subjects/modules - may need workload redistribution`\n                    ] : [],\n                    \"SOLUTION: Ensure at least 2 consecutive free periods exist in teacher/class schedule\"\n                ];\n            }\n        } else if (isComplementary) {\n            // COMPLEMENTARY MODULES: Fill remaining free spaces - prioritize single periods\n            conflictMessage = `Could not schedule ${subjectName} (tried 1 period preferred to avoid conflicts, then 2 periods) for ${teacherName} in ${className}${conflictDetail}`;\n            conflictSuggestions = [\n                \"COMPLEMENTARY MODULE: Fills remaining free spaces - prioritizes single periods to avoid conflicts\",\n                \"Add more free time slots anywhere in P1-P10\",\n                \"These modules are flexible and fill gaps in the schedule\",\n                \"Reduce teacher workload to create more free slots\",\n                \"Check for any remaining unscheduled periods\",\n                ...scopeConflict ? [\n                    `Teacher has broad scope - complementary modules fill remaining slots`\n                ] : [],\n                \"NOTE: Complementary modules prioritize single periods to avoid scheduling conflicts\"\n            ];\n        } else {\n            // Regular subjects: Use configured block size\n            conflictMessage = `Could not schedule ${subjectName} block (${blockSize} consecutive periods required) for ${teacherName} in ${className}${conflictDetail}`;\n            conflictSuggestions = [\n                \"Add more consecutive time slots to the schedule\",\n                \"Ensure no breaks interrupt the required consecutive periods\",\n                \"Reduce teacher workload or redistribute assignments\",\n                \"Check teacher availability constraints across all classes\",\n                \"Consider manual scheduling for this specific lesson\",\n                ...scopeConflict ? [\n                    `Teacher teaches across ${teacherClasses.size} classes and ${teacherSubjects.size} subjects/modules - consider workload redistribution`\n                ] : [],\n                `CRITICAL: ${subjectName} requires ${blockSize} CONSECUTIVE periods without breaks`\n            ];\n        }\n        this.conflicts.push({\n            type: \"unassigned\",\n            message: conflictMessage,\n            suggestions: conflictSuggestions.filter(Boolean)\n        });\n        console.log(` Failed to schedule ${subjectName} block for teacher ${lesson.teacherId} in class ${lesson.classId}`);\n    }\n    sortSlotsForEvenDistribution(slots, teacherId, classId) {\n        // Count current lessons per day for this teacher and class\n        const teacherLessonsByDay = new Map();\n        const classLessonsByDay = new Map();\n        // Count existing scheduled lessons\n        this.scheduledLessons.forEach((lesson)=>{\n            if (lesson.teacherId === teacherId) {\n                const count = teacherLessonsByDay.get(lesson.slot.day) || 0;\n                teacherLessonsByDay.set(lesson.slot.day, count + 1);\n            }\n            if (lesson.classId === classId) {\n                const count = classLessonsByDay.get(lesson.slot.day) || 0;\n                classLessonsByDay.set(lesson.slot.day, count + 1);\n            }\n        });\n        // Sort slots by combined score (lower is better - prefers days with fewer lessons)\n        return slots.sort((a, b)=>{\n            const teacherScoreA = teacherLessonsByDay.get(a.day) || 0;\n            const classScoreA = classLessonsByDay.get(a.day) || 0;\n            const totalScoreA = teacherScoreA + classScoreA;\n            const teacherScoreB = teacherLessonsByDay.get(b.day) || 0;\n            const classScoreB = classLessonsByDay.get(b.day) || 0;\n            const totalScoreB = teacherScoreB + classScoreB;\n            // If scores are equal, maintain original order (by period)\n            if (totalScoreA === totalScoreB) {\n                if (a.day === b.day) {\n                    return a.period - b.period;\n                }\n                return a.day.localeCompare(b.day);\n            }\n            return totalScoreA - totalScoreB;\n        });\n    }\n    canScheduleBlock(teacherId, classId, day, startPeriod, blockSize) {\n        // ENFORCE STRICT CORE TIME RULE: ALL lessons MUST be within 08:00-16:50 (P1-P10)\n        // NO EXCEPTIONS - reject any block that extends beyond P10\n        // CRITICAL: Check if the block would extend beyond P10 (16:50)\n        const endPeriod = startPeriod + blockSize - 1;\n        if (endPeriod > 10) {\n            console.log(` BLOCK REJECTED: End period ${endPeriod} exceeds P10 (16:50) limit`);\n            return false // Cannot schedule beyond period 10 (16:50)\n            ;\n        }\n        // ENFORCE START TIME RULE: Cannot start before P1 (08:00)\n        if (startPeriod < 1) {\n            console.log(` BLOCK REJECTED: Start period ${startPeriod} is before P1 (08:00)`);\n            return false // Cannot schedule before period 1 (08:00)\n            ;\n        }\n        for(let i = 0; i < blockSize; i++){\n            const period = startPeriod + i;\n            const slotKey = `${day}-${period}`;\n            // Check if period exists and is not a break\n            const timeSlot = this.timeSlotsCache?.find((ts)=>ts.day === day && ts.period === period);\n            if (!timeSlot || timeSlot.isBreak) {\n                return false // Cannot schedule on break periods\n                ;\n            }\n            // Check teacher and class availability\n            const teacherAvailable = !this.teacherAvailability[teacherId]?.has(slotKey);\n            const classAvailable = !this.classAvailability[classId]?.has(slotKey);\n            if (!teacherAvailable || !classAvailable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isTeacherOverbooked(teacherId) {\n        // Check if teacher has many scheduled lessons that might indicate overbooking\n        const teacherLessons = this.scheduledLessons.filter((lesson)=>lesson.teacherId === teacherId);\n        return teacherLessons.length > 10 // Threshold for potential overbooking\n        ;\n    }\n    canScheduleConsecutive(teacherId, day, period, maxConsecutive = 2) {\n        const teacherSlots = Array.from(this.teacherAvailability[teacherId] || []).filter((slot)=>slot.startsWith(day)).map((slot)=>parseInt(slot.split(\"-\")[1])).sort((a, b)=>a - b);\n        // Check if scheduling this period would create more than maxConsecutive consecutive periods\n        const consecutiveBefore = this.getConsecutiveCount(teacherSlots, period - 1);\n        const consecutiveAfter = this.getConsecutiveCount(teacherSlots, period + 1);\n        return consecutiveBefore < maxConsecutive && consecutiveAfter < maxConsecutive;\n    }\n    getConsecutiveCount(slots, period) {\n        let count = 0;\n        let current = period;\n        while(slots.includes(current)){\n            count++;\n            current++;\n        }\n        return count;\n    }\n    async getTeacherName(teacherId) {\n        const teacher = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.user.findUnique({\n            where: {\n                id: teacherId\n            },\n            select: {\n                name: true\n            }\n        });\n        return teacher?.name || \"Unknown Teacher\";\n    }\n    async getClassName(classId) {\n        const cls = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.class.findUnique({\n            where: {\n                id: classId\n            },\n            select: {\n                name: true\n            }\n        });\n        return cls?.name || \"Unknown Class\";\n    }\n    async getSubjectName(subjectId) {\n        const subject = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.subject.findUnique({\n            where: {\n                id: subjectId\n            },\n            select: {\n                name: true\n            }\n        });\n        return subject?.name || \"Unknown Subject\";\n    }\n    async getModuleName(moduleId) {\n        const module = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.module.findUnique({\n            where: {\n                id: moduleId\n            },\n            select: {\n                name: true\n            }\n        });\n        return module?.name || \"Unknown Module\";\n    }\n    async getTeacherConstraints(teacherId) {\n        const teacher = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.user.findUnique({\n            where: {\n                id: teacherId\n            },\n            select: {\n                unavailableDays: true,\n                unavailablePeriods: true\n            }\n        });\n        return {\n            unavailableDays: teacher?.unavailableDays || null,\n            unavailablePeriods: teacher?.unavailablePeriods || null\n        };\n    }\n    /**\r\n     * Get teacher's current workload across all classes for scope analysis\r\n     */ async getTeacherWorkload(teacherId) {\n        const scheduledLessons = this.scheduledLessons.filter((lesson)=>lesson.teacherId === teacherId);\n        const classIds = new Set(scheduledLessons.map((l)=>l.classId));\n        // Get all assignments for this teacher across school\n        const allAssignments = await this.getTeacherAllAssignments(teacherId);\n        const subjectIds = new Set(allAssignments.map((a)=>a.subjectId || a.moduleId).filter(Boolean));\n        // Calculate daily distribution\n        const dailyDistribution = {};\n        scheduledLessons.forEach((lesson)=>{\n            dailyDistribution[lesson.slot.day] = (dailyDistribution[lesson.slot.day] || 0) + 1;\n        });\n        return {\n            totalLessons: scheduledLessons.length,\n            classesCount: classIds.size,\n            subjectsCount: subjectIds.size,\n            dailyDistribution\n        };\n    }\n    /**\r\n     * Get ALL teacher assignments across school for full scope analysis\r\n     * This includes assignments from ALL classes, subjects, and modules\r\n     */ async getTeacherAllAssignments(teacherId) {\n        const assignments = [];\n        // Get teacher-class-subject assignments (Primary/Secondary)\n        const teacherClassSubjects = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.teacherClassSubject.findMany({\n            where: {\n                teacherId\n            },\n            include: {\n                class: {\n                    select: {\n                        level: true\n                    }\n                },\n                subject: {\n                    select: {\n                        level: true\n                    }\n                }\n            }\n        });\n        teacherClassSubjects.forEach((assignment)=>{\n            assignments.push({\n                classId: assignment.classId,\n                subjectId: assignment.subjectId,\n                level: assignment.class.level || assignment.subject.level || \"Unknown\",\n                type: this.determineSchoolType(assignment.class.level || assignment.subject.level || \"\")\n            });\n        });\n        // Get trainer-class-module assignments (TSS)\n        const trainerClassModules = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.trainerClassModule.findMany({\n            where: {\n                trainerId: teacherId\n            },\n            include: {\n                class: {\n                    select: {\n                        level: true\n                    }\n                },\n                module: {\n                    select: {\n                        level: true\n                    }\n                }\n            }\n        });\n        trainerClassModules.forEach((assignment)=>{\n            assignments.push({\n                classId: assignment.classId,\n                moduleId: assignment.moduleId,\n                level: assignment.class.level || assignment.module.level || \"Unknown\",\n                type: \"TSS\"\n            });\n        });\n        return assignments;\n    }\n    /**\r\n     * Determine school type based on class level\r\n     */ determineSchoolType(level) {\n        if ([\n            \"L3\",\n            \"L4\",\n            \"L5\"\n        ].includes(level)) {\n            return \"TSS\";\n        }\n        if (level.startsWith(\"S\")) {\n            return \"SECONDARY\";\n        }\n        if (level.startsWith(\"P\")) {\n            return \"PRIMARY\";\n        }\n        return \"SECONDARY\" // default\n        ;\n    }\n    /**\r\n     * Check if scheduling would maintain workload balance across teacher's classes\r\n     */ isWorkloadBalanced(teacherId, targetClassId, day) {\n        const teacherLessons = this.scheduledLessons.filter((lesson)=>lesson.teacherId === teacherId);\n        if (teacherLessons.length === 0) return true // First lesson for teacher\n        ;\n        // Count lessons per class for this teacher\n        const lessonsByClass = new Map();\n        teacherLessons.forEach((lesson)=>{\n            const count = lessonsByClass.get(lesson.classId) || 0;\n            lessonsByClass.set(lesson.classId, count + 1);\n        });\n        // Count lessons for target class on this day\n        const targetClassDayLessons = teacherLessons.filter((lesson)=>lesson.classId === targetClassId && lesson.slot.day === day).length;\n        // Prevent overloading a single class on a single day\n        // Allow max 3 lessons per class per day for any teacher\n        if (targetClassDayLessons >= 3) {\n            return false;\n        }\n        return true;\n    }\n    async saveToDatabase() {\n        for (const lesson of this.scheduledLessons){\n            await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timetable.create({\n                data: {\n                    schoolId: this.schoolId,\n                    classId: lesson.classId,\n                    teacherId: lesson.teacherId,\n                    subjectId: lesson.subjectId,\n                    moduleId: lesson.moduleId,\n                    timeSlotId: lesson.slot.timeSlotId\n                }\n            });\n        }\n    }\n    /**\r\n     * Generate timetables for all classes (without clearing existing teacher timetables)\r\n     */ async generateForAllClasses() {\n        try {\n            // Clear existing timetables for classes only (keep teacher-specific ones)\n            await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timetable.deleteMany({\n                where: {\n                    schoolId: this.schoolId\n                }\n            });\n            // Initialize availability maps\n            await this.initializeAvailability();\n            // Load prepared lessons\n            const { lessons: preparedLessons } = await (0,_lib_lesson_preparation__WEBPACK_IMPORTED_MODULE_1__.prepareLessonsForSchool)(this.schoolId);\n            // Sort by priority and time preference with TSS rules\n            const sortedLessons = this.sortLessonsByPriorityAndTime(preparedLessons);\n            // Schedule each lesson\n            for (const lesson of sortedLessons){\n                await this.scheduleLesson(lesson);\n            }\n            // Save all scheduled lessons to database\n            await this.saveToDatabase();\n            return {\n                success: true,\n                conflicts: this.conflicts\n            };\n        } catch (error) {\n            console.error(\"Timetable generation for all classes failed:\", error);\n            return {\n                success: false,\n                conflicts: [\n                    ...this.conflicts,\n                    {\n                        type: \"unassigned\",\n                        message: \"Timetable generation for all classes failed due to an internal error\"\n                    }\n                ]\n            };\n        }\n    }\n    /**\r\n     * Generate timetables for all teachers (without clearing existing class timetables)\r\n     */ async generateForAllTeachers() {\n        try {\n            // Clear existing timetables for teachers only (but this also clears class timetables since they're linked)\n            // Actually, timetables are shared - a single timetable entry has both classId and teacherId\n            // So we need to clear all and regenerate\n            await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.timetable.deleteMany({\n                where: {\n                    schoolId: this.schoolId\n                }\n            });\n            // Initialize availability maps\n            await this.initializeAvailability();\n            // Load prepared lessons\n            const { lessons: preparedLessons } = await (0,_lib_lesson_preparation__WEBPACK_IMPORTED_MODULE_1__.prepareLessonsForSchool)(this.schoolId);\n            // Sort by priority and time preference with TSS rules\n            const sortedLessons = this.sortLessonsByPriorityAndTime(preparedLessons);\n            // Schedule each lesson\n            for (const lesson of sortedLessons){\n                await this.scheduleLesson(lesson);\n            }\n            // Save all scheduled lessons to database\n            await this.saveToDatabase();\n            return {\n                success: true,\n                conflicts: this.conflicts\n            };\n        } catch (error) {\n            console.error(\"Timetable generation for all teachers failed:\", error);\n            return {\n                success: false,\n                conflicts: [\n                    ...this.conflicts,\n                    {\n                        type: \"unassigned\",\n                        message: \"Timetable generation for all teachers failed due to an internal error\"\n                    }\n                ]\n            };\n        }\n    }\n}\nasync function generateTimetable(schoolId, scope = \"both\") {\n    const generator = new TimetableGenerator(schoolId);\n    if (scope === \"all-classes\") {\n        return await generator.generateForAllClasses();\n    } else if (scope === \"all-teachers\") {\n        return await generator.generateForAllTeachers();\n    } else {\n        return await generator.generate();\n    }\n}\nasync function generateTimetableForClass(schoolId, classId, options = {}) {\n    const generator = new TimetableGenerator(schoolId);\n    return await generator.generateForClass(classId, options);\n}\nasync function generateTimetableForTeacher(schoolId, teacherId, options = {}) {\n    const generator = new TimetableGenerator(schoolId);\n    return await generator.generateForTeacher(teacherId, options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUMsVUFBNkIsQ0FBQyxDQUFDO0lBQzlHLE1BQU1xSyxZQUFZLElBQUlwTixtQkFBbUJFO0lBQ3pDLE9BQU8sTUFBTWtOLFVBQVV2SyxnQkFBZ0IsQ0FBQ0MsU0FBU0M7QUFDckQ7QUFFTyxlQUFldUssNEJBQTRCcE4sUUFBZ0IsRUFBRW1ELFNBQWlCLEVBQUVOLFVBQTZCLENBQUMsQ0FBQztJQUNsSCxNQUFNcUssWUFBWSxJQUFJcE4sbUJBQW1CRTtJQUN6QyxPQUFPLE1BQU1rTixVQUFVaEssa0JBQWtCLENBQUNDLFdBQVdOO0FBQ3pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2Nob29sLXRpbWV0YWJsZS1tYW5hZ2VtZW50Ly4vc3JjL2xpYi90aW1ldGFibGUtZ2VuZXJhdG9yLnRzP2VmZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGIgfSBmcm9tICdAL2xpYi9kYidcclxuaW1wb3J0IHsgZ2V0TW9kdWxlQ2F0ZWdvcnlQcmlvcml0eSwgaXNNb3JuaW5nUGVyaW9kIH0gZnJvbSAnQC9saWIvdXRpbHMnXHJcbmltcG9ydCB7IFRpbWV0YWJsZUdlbmVyYXRpb25PcHRpb25zLCBDb25mbGljdFJlc29sdXRpb24gfSBmcm9tICdAL3R5cGVzJ1xyXG5pbXBvcnQgeyBQcmVwYXJlZExlc3NvbiwgcHJlcGFyZUxlc3NvbnNGb3JTY2hvb2wgfSBmcm9tICdAL2xpYi9sZXNzb24tcHJlcGFyYXRpb24nXHJcblxyXG5pbnRlcmZhY2UgU2NoZWR1bGVTbG90IHtcclxuICAgIGRheTogc3RyaW5nXHJcbiAgICBwZXJpb2Q6IG51bWJlclxyXG4gICAgdGltZVNsb3RJZDogc3RyaW5nXHJcbn1cclxuXHJcbmludGVyZmFjZSBTY2hlZHVsZWRMZXNzb24ge1xyXG4gICAgdGVhY2hlcklkOiBzdHJpbmdcclxuICAgIHN1YmplY3RJZD86IHN0cmluZ1xyXG4gICAgbW9kdWxlSWQ/OiBzdHJpbmdcclxuICAgIGNsYXNzSWQ6IHN0cmluZ1xyXG4gICAgc2xvdDogU2NoZWR1bGVTbG90XHJcbiAgICBwcmlvcml0eTogbnVtYmVyXHJcbn1cclxuXHJcbmludGVyZmFjZSBUZWFjaGVyQXZhaWxhYmlsaXR5IHtcclxuICAgIFtrZXk6IHN0cmluZ106IFNldDxzdHJpbmc+IC8vIHRlYWNoZXJJZCAtPiBTZXQgb2YgXCJkYXktcGVyaW9kXCIga2V5c1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQ2xhc3NBdmFpbGFiaWxpdHkge1xyXG4gICAgW2tleTogc3RyaW5nXTogU2V0PHN0cmluZz4gLy8gY2xhc3NJZCAtPiBTZXQgb2YgXCJkYXktcGVyaW9kXCIga2V5c1xyXG59XHJcblxyXG5pbnRlcmZhY2UgR2VuZXJhdGlvbk9wdGlvbnMge1xyXG4gICAgaW5jcmVtZW50YWw/OiBib29sZWFuXHJcbiAgICByZWdlbmVyYXRlPzogYm9vbGVhblxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTY2hvb2xTY29wZSA9ICdhbGwtY2xhc3NlcycgfCAnYWxsLXRlYWNoZXJzJyB8ICdib3RoJ1xyXG5cclxuZXhwb3J0IGNsYXNzIFRpbWV0YWJsZUdlbmVyYXRvciB7XHJcbiAgICBwcml2YXRlIHNjaG9vbElkOiBzdHJpbmdcclxuICAgIHByaXZhdGUgc2NoZWR1bGVkTGVzc29uczogU2NoZWR1bGVkTGVzc29uW10gPSBbXVxyXG4gICAgcHJpdmF0ZSB0ZWFjaGVyQXZhaWxhYmlsaXR5OiBUZWFjaGVyQXZhaWxhYmlsaXR5ID0ge31cclxuICAgIHByaXZhdGUgY2xhc3NBdmFpbGFiaWxpdHk6IENsYXNzQXZhaWxhYmlsaXR5ID0ge31cclxuICAgIHByaXZhdGUgY29uZmxpY3RzOiBDb25mbGljdFJlc29sdXRpb25bXSA9IFtdXHJcbiAgICBwcml2YXRlIHRpbWVTbG90c0NhY2hlOiBhbnlbXSA9IFtdIC8vIENhY2hlIHRpbWUgc2xvdHMgZm9yIGJyZWFrIGNoZWNraW5nXHJcblxyXG4gICAgY29uc3RydWN0b3Ioc2Nob29sSWQ6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuc2Nob29sSWQgPSBzY2hvb2xJZFxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGdlbmVyYXRlKCk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBjb25mbGljdHM6IENvbmZsaWN0UmVzb2x1dGlvbltdIH0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyB0aW1ldGFibGVzIGZvciBmdWxsIHNjaG9vbCBnZW5lcmF0aW9uXHJcbiAgICAgICAgICAgIGF3YWl0IGRiLnRpbWV0YWJsZS5kZWxldGVNYW55KHtcclxuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHNjaG9vbElkOiB0aGlzLnNjaG9vbElkIH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgYXZhaWxhYmlsaXR5IG1hcHNcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQXZhaWxhYmlsaXR5KClcclxuXHJcbiAgICAgICAgICAgIC8vIExvYWQgcHJlcGFyZWQgbGVzc29uc1xyXG4gICAgICAgICAgICBjb25zdCB7IGxlc3NvbnM6IHByZXBhcmVkTGVzc29ucyB9ID0gYXdhaXQgcHJlcGFyZUxlc3NvbnNGb3JTY2hvb2wodGhpcy5zY2hvb2xJZClcclxuXHJcbiAgICAgICAgICAgIC8vIFNvcnQgYnkgcHJpb3JpdHkgYW5kIHRpbWUgcHJlZmVyZW5jZSB3aXRoIFRTUyBydWxlc1xyXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRMZXNzb25zID0gdGhpcy5zb3J0TGVzc29uc0J5UHJpb3JpdHlBbmRUaW1lKHByZXBhcmVkTGVzc29ucylcclxuXHJcbiAgICAgICAgICAgIC8vIExvYWQgdGltZSBzbG90cyBmb3IgdmFsaWRhdGlvblxyXG4gICAgICAgICAgICBjb25zdCB0aW1lU2xvdHMgPSBhd2FpdCBkYi50aW1lU2xvdC5maW5kTWFueSh7XHJcbiAgICAgICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaG9vbElkOiB0aGlzLnNjaG9vbElkLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb3JkZXJCeTogW1xyXG4gICAgICAgICAgICAgICAgICAgIHsgZGF5OiAnYXNjJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcGVyaW9kOiAnYXNjJyB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBjb25zdCB2YWxpZFRpbWVTbG90cyA9IHRpbWVTbG90cy5maWx0ZXIoKHRzOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmlvZCA9IHRzLnBlcmlvZFxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF5ID0gdHMuZGF5XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkUGVyaW9kID0gcGVyaW9kID49IDEgJiYgcGVyaW9kIDw9IDEwXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkRGF5ID0gZGF5ICE9PSAnU0FUVVJEQVknICYmIFsnTU9OREFZJywgJ1RVRVNEQVknLCAnV0VETkVTREFZJywgJ1RIVVJTREFZJywgJ0ZSSURBWSddLmluY2x1ZGVzKGRheSlcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzTm90QnJlYWsgPSAhKHRzIGFzIGFueSkuaXNCcmVha1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRQZXJpb2QgJiYgaXNWYWxpZERheSAmJiBpc05vdEJyZWFrXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBjb25zdCB0b3RhbFBlcmlvZHMgPSBzb3J0ZWRMZXNzb25zLnJlZHVjZSgoc3VtLCBsZXNzb24pID0+IHN1bSArIChsZXNzb24uYmxvY2tTaXplIHx8IDEpLCAwKVxyXG5cclxuICAgICAgICAgICAgaWYgKHZhbGlkVGltZVNsb3RzLmxlbmd0aCA8IHRvdGFsUGVyaW9kcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25mbGljdHM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bmFzc2lnbmVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vdCBlbm91Z2ggdGltZSBzbG90cyBhdmFpbGFibGUuIFJlcXVpcmVkOiAke3RvdGFsUGVyaW9kc30gcGVyaW9kcywgQXZhaWxhYmxlOiAke3ZhbGlkVGltZVNsb3RzLmxlbmd0aH0gc2xvdHMuIFBsZWFzZSBhZGQgbW9yZSB0aW1lIHNsb3RzIG9yIHJlZHVjZSBsZXNzb24gYXNzaWdubWVudHMuYFxyXG4gICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGVhY2ggbGVzc29uXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVzc29uIG9mIHNvcnRlZExlc3NvbnMpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2NoZWR1bGVMZXNzb24obGVzc29uKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTYXZlIGFsbCBzY2hlZHVsZWQgbGVzc29ucyB0byBkYXRhYmFzZVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVUb0RhdGFiYXNlKClcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmxpY3RzOiB0aGlzLmNvbmZsaWN0c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGltZXRhYmxlIGdlbmVyYXRpb24gZmFpbGVkOicsIGVycm9yKVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHM6IFsuLi50aGlzLmNvbmZsaWN0cywge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bmFzc2lnbmVkJyxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGltZXRhYmxlIGdlbmVyYXRpb24gZmFpbGVkIGR1ZSB0byBhbiBpbnRlcm5hbCBlcnJvcidcclxuICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZ2VuZXJhdGVGb3JDbGFzcyhjbGFzc0lkOiBzdHJpbmcsIG9wdGlvbnM6IEdlbmVyYXRpb25PcHRpb25zID0ge30pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgY29uZmxpY3RzOiBDb25mbGljdFJlc29sdXRpb25bXSB9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgeyBpbmNyZW1lbnRhbCA9IGZhbHNlLCByZWdlbmVyYXRlID0gZmFsc2UgfSA9IG9wdGlvbnNcclxuXHJcbiAgICAgICAgICAgIC8vIEZvciBpbmNyZW1lbnRhbCBtb2RlLCBwcmVzZXJ2ZSBleGlzdGluZyB0aW1ldGFibGVzIHVubGVzcyByZWdlbmVyYXRlIGlzIHRydWVcclxuICAgICAgICAgICAgaWYgKCFpbmNyZW1lbnRhbCB8fCByZWdlbmVyYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyB0aW1ldGFibGVzIGZvciB0aGlzIHNwZWNpZmljIGNsYXNzIG9ubHlcclxuICAgICAgICAgICAgICAgIGF3YWl0IGRiLnRpbWV0YWJsZS5kZWxldGVNYW55KHtcclxuICAgICAgICAgICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hvb2xJZDogdGhpcy5zY2hvb2xJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NJZDogY2xhc3NJZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgYXZhaWxhYmlsaXR5IG1hcHMgd2l0aCBleGlzdGluZyB0aW1ldGFibGVzIGZyb20gT1RIRVIgY2xhc3NlcyBvbmx5XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUF2YWlsYWJpbGl0eVdpdGhFeGlzdGluZ1RpbWV0YWJsZXMoY2xhc3NJZClcclxuXHJcbiAgICAgICAgICAgIC8vIExvYWQgcHJlcGFyZWQgbGVzc29ucyBmb3IgdGhlIHNwZWNpZmljIGNsYXNzIG9ubHlcclxuICAgICAgICAgICAgY29uc3QgeyBsZXNzb25zOiBwcmVwYXJlZExlc3NvbnMgfSA9IGF3YWl0IHByZXBhcmVMZXNzb25zRm9yU2Nob29sKHRoaXMuc2Nob29sSWQpXHJcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTGVzc29ucyA9IHByZXBhcmVkTGVzc29ucy5maWx0ZXIobGVzc29uID0+IGxlc3Nvbi5jbGFzc0lkID09PSBjbGFzc0lkKVxyXG5cclxuICAgICAgICAgICAgaWYgKGNsYXNzTGVzc29ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndW5hc3NpZ25lZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdObyBsZXNzb25zIGZvdW5kIGZvciB0aGUgc2VsZWN0ZWQgY2xhc3MnXHJcbiAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU29ydCBieSBwcmlvcml0eSBhbmQgdGltZSBwcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZExlc3NvbnMgPSB0aGlzLnNvcnRMZXNzb25zQnlQcmlvcml0eUFuZFRpbWUoY2xhc3NMZXNzb25zKVxyXG5cclxuICAgICAgICAgICAgLy8gTG9hZCB0aW1lIHNsb3RzIGZvciB2YWxpZGF0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTbG90cyA9IGF3YWl0IGRiLnRpbWVTbG90LmZpbmRNYW55KHtcclxuICAgICAgICAgICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmU6IHRydWVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvcmRlckJ5OiBbXHJcbiAgICAgICAgICAgICAgICAgICAgeyBkYXk6ICdhc2MnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBwZXJpb2Q6ICdhc2MnIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkVGltZVNsb3RzID0gdGltZVNsb3RzLmZpbHRlcigodHM6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGVyaW9kID0gdHMucGVyaW9kXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXkgPSB0cy5kYXlcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRQZXJpb2QgPSBwZXJpb2QgPj0gMSAmJiBwZXJpb2QgPD0gMTBcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWREYXkgPSBkYXkgIT09ICdTQVRVUkRBWScgJiYgWydNT05EQVknLCAnVFVFU0RBWScsICdXRURORVNEQVknLCAnVEhVUlNEQVknLCAnRlJJREFZJ10uaW5jbHVkZXMoZGF5KVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNOb3RCcmVhayA9ICEodHMgYXMgYW55KS5pc0JyZWFrXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZFBlcmlvZCAmJiBpc1ZhbGlkRGF5ICYmIGlzTm90QnJlYWtcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsUGVyaW9kcyA9IHNvcnRlZExlc3NvbnMucmVkdWNlKChzdW0sIGxlc3NvbikgPT4gc3VtICsgKGxlc3Nvbi5ibG9ja1NpemUgfHwgMSksIDApXHJcblxyXG4gICAgICAgICAgICBpZiAodmFsaWRUaW1lU2xvdHMubGVuZ3RoIDwgdG90YWxQZXJpb2RzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0czogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuYXNzaWduZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgTm90IGVub3VnaCB0aW1lIHNsb3RzIGF2YWlsYWJsZSBmb3IgY2xhc3MuIFJlcXVpcmVkOiAke3RvdGFsUGVyaW9kc30gcGVyaW9kcywgQXZhaWxhYmxlOiAke3ZhbGlkVGltZVNsb3RzLmxlbmd0aH0gc2xvdHMuIFBsZWFzZSBhZGQgbW9yZSB0aW1lIHNsb3RzIG9yIHJlZHVjZSBsZXNzb24gYXNzaWdubWVudHMgZm9yIHRoaXMgY2xhc3MuYFxyXG4gICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGVhY2ggbGVzc29uXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVzc29uIG9mIHNvcnRlZExlc3NvbnMpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2NoZWR1bGVMZXNzb24obGVzc29uKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTYXZlIGFsbCBzY2hlZHVsZWQgbGVzc29ucyB0byBkYXRhYmFzZVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVUb0RhdGFiYXNlKClcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmxpY3RzOiB0aGlzLmNvbmZsaWN0c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGltZXRhYmxlIGdlbmVyYXRpb24gZm9yIGNsYXNzIGZhaWxlZDonLCBlcnJvcilcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmxpY3RzOiBbLi4udGhpcy5jb25mbGljdHMsIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndW5hc3NpZ25lZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RpbWV0YWJsZSBnZW5lcmF0aW9uIGZvciBjbGFzcyBmYWlsZWQgZHVlIHRvIGFuIGludGVybmFsIGVycm9yJ1xyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBnZW5lcmF0ZUZvclRlYWNoZXIodGVhY2hlcklkOiBzdHJpbmcsIG9wdGlvbnM6IEdlbmVyYXRpb25PcHRpb25zID0ge30pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgY29uZmxpY3RzOiBDb25mbGljdFJlc29sdXRpb25bXSB9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgeyBpbmNyZW1lbnRhbCA9IGZhbHNlLCByZWdlbmVyYXRlID0gZmFsc2UgfSA9IG9wdGlvbnNcclxuXHJcbiAgICAgICAgICAgIC8vIEZvciBpbmNyZW1lbnRhbCBtb2RlLCBwcmVzZXJ2ZSBleGlzdGluZyB0aW1ldGFibGVzIHVubGVzcyByZWdlbmVyYXRlIGlzIHRydWVcclxuICAgICAgICAgICAgaWYgKCFpbmNyZW1lbnRhbCB8fCByZWdlbmVyYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyB0aW1ldGFibGVzIGZvciB0aGlzIHRlYWNoZXIgYWNyb3NzIEFMTCBjbGFzc2VzXHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYi50aW1ldGFibGUuZGVsZXRlTWFueSh7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYWNoZXJJZDogdGVhY2hlcklkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdmFpbGFiaWxpdHkgbWFwcyB3aXRoIGV4aXN0aW5nIHRpbWV0YWJsZXMgZnJvbSBPVEhFUiB0ZWFjaGVycyBvbmx5XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUF2YWlsYWJpbGl0eVdpdGhFeGlzdGluZ1RpbWV0YWJsZXModW5kZWZpbmVkLCB0ZWFjaGVySWQpXHJcblxyXG4gICAgICAgICAgICAvLyBMb2FkIHByZXBhcmVkIGxlc3NvbnMgZm9yIHRoZSBzcGVjaWZpYyB0ZWFjaGVyIG9ubHlcclxuICAgICAgICAgICAgY29uc3QgeyBsZXNzb25zOiBwcmVwYXJlZExlc3NvbnMgfSA9IGF3YWl0IHByZXBhcmVMZXNzb25zRm9yU2Nob29sKHRoaXMuc2Nob29sSWQpXHJcbiAgICAgICAgICAgIGNvbnN0IHRlYWNoZXJMZXNzb25zID0gcHJlcGFyZWRMZXNzb25zLmZpbHRlcihsZXNzb24gPT4gbGVzc29uLnRlYWNoZXJJZCA9PT0gdGVhY2hlcklkKVxyXG5cclxuICAgICAgICAgICAgaWYgKHRlYWNoZXJMZXNzb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25mbGljdHM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bmFzc2lnbmVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ05vIGxlc3NvbnMgZm91bmQgZm9yIHRoZSBzZWxlY3RlZCB0ZWFjaGVyJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvcnQgYnkgcHJpb3JpdHkgYW5kIHRpbWUgcHJlZmVyZW5jZVxyXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRMZXNzb25zID0gdGhpcy5zb3J0TGVzc29uc0J5UHJpb3JpdHlBbmRUaW1lKHRlYWNoZXJMZXNzb25zKVxyXG5cclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgZWFjaCBsZXNzb25cclxuICAgICAgICAgICAgZm9yIChjb25zdCBsZXNzb24gb2Ygc29ydGVkTGVzc29ucykge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2hlZHVsZUxlc3NvbihsZXNzb24pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgYWxsIHNjaGVkdWxlZCBsZXNzb25zIHRvIGRhdGFiYXNlXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZVRvRGF0YWJhc2UoKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHM6IHRoaXMuY29uZmxpY3RzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaW1ldGFibGUgZ2VuZXJhdGlvbiBmb3IgdGVhY2hlciBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZsaWN0czogWy4uLnRoaXMuY29uZmxpY3RzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuYXNzaWduZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaW1ldGFibGUgZ2VuZXJhdGlvbiBmb3IgdGVhY2hlciBmYWlsZWQgZHVlIHRvIGFuIGludGVybmFsIGVycm9yJ1xyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGluaXRpYWxpemVBdmFpbGFiaWxpdHkoKSB7XHJcbiAgICAgICAgLy8gR2V0IGFsbCB0aW1lIHNsb3RzIGZvciB0aGUgc2Nob29sXHJcbiAgICAgICAgY29uc3QgdGltZVNsb3RzID0gYXdhaXQgZGIudGltZVNsb3QuZmluZE1hbnkoe1xyXG4gICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQsXHJcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvcmRlckJ5OiBbXHJcbiAgICAgICAgICAgICAgICB7IGRheTogJ2FzYycgfSxcclxuICAgICAgICAgICAgICAgIHsgcGVyaW9kOiAnYXNjJyB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENhY2hlIHRpbWUgc2xvdHMgZm9yIGJyZWFrIGNoZWNraW5nXHJcbiAgICAgICAgdGhpcy50aW1lU2xvdHNDYWNoZSA9IHRpbWVTbG90c1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHRlYWNoZXIgYW5kIHRyYWluZXIgYXZhaWxhYmlsaXR5XHJcbiAgICAgICAgY29uc3QgdGVhY2hlcnNBbmRUcmFpbmVycyA9IGF3YWl0IGRiLnVzZXIuZmluZE1hbnkoe1xyXG4gICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQsXHJcbiAgICAgICAgICAgICAgICByb2xlOiB7IGluOiBbJ1RFQUNIRVInLCAnVFJBSU5FUiddIH0sXHJcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGVhY2hlcnNBbmRUcmFpbmVycy5mb3JFYWNoKChwZXJzb246IGFueSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRlYWNoZXJBdmFpbGFiaWxpdHlbcGVyc29uLmlkXSA9IG5ldyBTZXQoKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgY2xhc3MgYXZhaWxhYmlsaXR5XHJcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IGF3YWl0IGRiLmNsYXNzLmZpbmRNYW55KHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNsYXNzZXMuZm9yRWFjaCgoY2xzOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc0F2YWlsYWJpbGl0eVtjbHMuaWRdID0gbmV3IFNldCgpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGluaXRpYWxpemVBdmFpbGFiaWxpdHlXaXRoRXhpc3RpbmdUaW1ldGFibGVzKGV4Y2x1ZGVDbGFzc0lkPzogc3RyaW5nLCBleGNsdWRlVGVhY2hlcklkPzogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gR2V0IGFsbCB0aW1lIHNsb3RzIGZvciB0aGUgc2Nob29sXHJcbiAgICAgICAgY29uc3QgdGltZVNsb3RzID0gYXdhaXQgZGIudGltZVNsb3QuZmluZE1hbnkoe1xyXG4gICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQsXHJcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvcmRlckJ5OiBbXHJcbiAgICAgICAgICAgICAgICB7IGRheTogJ2FzYycgfSxcclxuICAgICAgICAgICAgICAgIHsgcGVyaW9kOiAnYXNjJyB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENhY2hlIHRpbWUgc2xvdHMgZm9yIGJyZWFrIGNoZWNraW5nXHJcbiAgICAgICAgdGhpcy50aW1lU2xvdHNDYWNoZSA9IHRpbWVTbG90c1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHRlYWNoZXIgYW5kIHRyYWluZXIgYXZhaWxhYmlsaXR5XHJcbiAgICAgICAgY29uc3QgdGVhY2hlcnNBbmRUcmFpbmVycyA9IGF3YWl0IGRiLnVzZXIuZmluZE1hbnkoe1xyXG4gICAgICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgICAgICAgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQsXHJcbiAgICAgICAgICAgICAgICByb2xlOiB7IGluOiBbJ1RFQUNIRVInLCAnVFJBSU5FUiddIH0sXHJcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGVhY2hlcnNBbmRUcmFpbmVycy5mb3JFYWNoKChwZXJzb246IGFueSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRlYWNoZXJBdmFpbGFiaWxpdHlbcGVyc29uLmlkXSA9IG5ldyBTZXQoKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgY2xhc3MgYXZhaWxhYmlsaXR5XHJcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IGF3YWl0IGRiLmNsYXNzLmZpbmRNYW55KHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNsYXNzZXMuZm9yRWFjaCgoY2xzOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc0F2YWlsYWJpbGl0eVtjbHMuaWRdID0gbmV3IFNldCgpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gTG9hZCBleGlzdGluZyB0aW1ldGFibGVzIHdpdGggZXhjbHVzaW9uc1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGltZXRhYmxlc1doZXJlQ2xhdXNlOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIHNjaG9vbElkOiB0aGlzLnNjaG9vbElkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFwcGx5IGV4Y2x1c2lvbnMgZm9yIGNsYXNzLXNwZWNpZmljIG9yIHRlYWNoZXItc3BlY2lmaWMgZ2VuZXJhdGlvblxyXG4gICAgICAgIGlmIChleGNsdWRlQ2xhc3NJZCkge1xyXG4gICAgICAgICAgICBleGlzdGluZ1RpbWV0YWJsZXNXaGVyZUNsYXVzZS5jbGFzc0lkID0ge1xyXG4gICAgICAgICAgICAgICAgbm90OiBleGNsdWRlQ2xhc3NJZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChleGNsdWRlVGVhY2hlcklkKSB7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nVGltZXRhYmxlc1doZXJlQ2xhdXNlLnRlYWNoZXJJZCA9IHtcclxuICAgICAgICAgICAgICAgIG5vdDogZXhjbHVkZVRlYWNoZXJJZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBleGlzdGluZ1RpbWV0YWJsZXMgPSBhd2FpdCBkYi50aW1ldGFibGUuZmluZE1hbnkoe1xyXG4gICAgICAgICAgICB3aGVyZTogZXhpc3RpbmdUaW1ldGFibGVzV2hlcmVDbGF1c2UsXHJcbiAgICAgICAgICAgIGluY2x1ZGU6IHtcclxuICAgICAgICAgICAgICAgIHRpbWVTbG90OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyaW9kOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNsYXNzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGVhY2hlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gTWFyayBvY2N1cGllZCBzbG90cyBmcm9tIGV4aXN0aW5nIHRpbWV0YWJsZXMgKGdsb2JhbCB0ZWFjaGVyIGF2YWlsYWJpbGl0eSlcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbWV0YWJsZSBvZiBleGlzdGluZ1RpbWV0YWJsZXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2xvdEtleSA9IGAke3RpbWV0YWJsZS50aW1lU2xvdC5kYXl9LSR7dGltZXRhYmxlLnRpbWVTbG90LnBlcmlvZH1gXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBNYXJrIHRlYWNoZXIgYXMgdW5hdmFpbGFibGUgKGdsb2JhbCBhY3Jvc3MgYWxsIGNsYXNzZXMpXHJcbiAgICAgICAgICAgIHRoaXMudGVhY2hlckF2YWlsYWJpbGl0eVt0aW1ldGFibGUudGVhY2hlcklkXS5hZGQoc2xvdEtleSlcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIE1hcmsgY2xhc3MgYXMgdW5hdmFpbGFibGVcclxuICAgICAgICAgICAgdGhpcy5jbGFzc0F2YWlsYWJpbGl0eVt0aW1ldGFibGUuY2xhc3NJZF0uYWRkKHNsb3RLZXkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgTG9hZGVkICR7ZXhpc3RpbmdUaW1ldGFibGVzLmxlbmd0aH0gZXhpc3RpbmcgdGltZXRhYmxlIGVudHJpZXMgZm9yIGdsb2JhbCB0ZWFjaGVyIGF2YWlsYWJpbGl0eSBjaGVja2ApXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzb3J0TGVzc29uc0J5UHJpb3JpdHlBbmRUaW1lKGxlc3NvbnM6IFByZXBhcmVkTGVzc29uW10pOiBQcmVwYXJlZExlc3NvbltdIHtcclxuICAgICAgICByZXR1cm4gbGVzc29ucy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFBSSU9SSVRZIE9SREVSIChGSU5BTClcclxuICAgICAgICAgICAgLy8gMSkgU1BFQ0lGSUMgbW9kdWxlcyAoZG91YmxlIHBlcmlvZHMpXHJcbiAgICAgICAgICAgIC8vIDIpIEdFTkVSQUwgbW9kdWxlcyAoZG91YmxlIHBlcmlvZHMpXHJcbiAgICAgICAgICAgIC8vIDMpIE1hdGhlbWF0aWNzICYgUGh5c2ljcyAoZG91YmxlIHBlcmlvZHMpXHJcbiAgICAgICAgICAgIC8vIDQpIE90aGVyIHJlcXVpcmVkIHN1YmplY3RzXHJcbiAgICAgICAgICAgIC8vIDUpIENPTVBMRU1FTlRBUlkgbW9kdWxlcyAoZmlsbCBGUkVFIHNsb3RzKVxyXG5cclxuICAgICAgICAgICAgLy8gRmlyc3QsIGhhbmRsZSBUU1MgbW9kdWxlcyBieSBjYXRlZ29yeVxyXG4gICAgICAgICAgICBpZiAoYS5sZXNzb25UeXBlID09PSAnVFNTJyAmJiBiLmxlc3NvblR5cGUgPT09ICdUU1MnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yeU9yZGVyID0geyAnU1BFQ0lGSUMnOiAxLCAnR0VORVJBTCc6IDIsICdDT01QTEVNRU5UQVJZJzogNSB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhQ2F0ZWdvcnkgPSAoYS5tb2R1bGVDYXRlZ29yeSB8fCAnQ09NUExFTUVOVEFSWScpIGFzIGtleW9mIHR5cGVvZiBjYXRlZ29yeU9yZGVyXHJcbiAgICAgICAgICAgICAgICBjb25zdCBiQ2F0ZWdvcnkgPSAoYi5tb2R1bGVDYXRlZ29yeSB8fCAnQ09NUExFTUVOVEFSWScpIGFzIGtleW9mIHR5cGVvZiBjYXRlZ29yeU9yZGVyXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5T3JkZXJbYUNhdGVnb3J5XSAhPT0gY2F0ZWdvcnlPcmRlcltiQ2F0ZWdvcnldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhdGVnb3J5T3JkZXJbYUNhdGVnb3J5XSAtIGNhdGVnb3J5T3JkZXJbYkNhdGVnb3J5XVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNhbWUgY2F0ZWdvcnksIHByZWZlciBtb3JuaW5nIGxlc3NvbnNcclxuICAgICAgICAgICAgICAgIGlmIChhLnByZWZlcnJlZFRpbWUgIT09IGIucHJlZmVycmVkVGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhLnByZWZlcnJlZFRpbWUgPT09ICdNT1JOSU5HJykgcmV0dXJuIC0xXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIucHJlZmVycmVkVGltZSA9PT0gJ01PUk5JTkcnKSByZXR1cm4gMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEubGVzc29uVHlwZSA9PT0gJ1RTUycpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRTUyBoYXMgaGlnaGVyIHByaW9yaXR5IHRoYW4gcmVndWxhciBzdWJqZWN0c1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5sZXNzb25UeXBlID09PSAnVFNTJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDFcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRm9yIHJlZ3VsYXIgc3ViamVjdHMsIHByaW9yaXRpemUgTWF0aGVtYXRpY3MgYW5kIFBoeXNpY3NcclxuICAgICAgICAgICAgY29uc3QgaXNNYXRoUGh5c2ljc0EgPSBhLnN1YmplY3ROYW1lPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdtYXRoZW1hdGljcycpIHx8IGEuc3ViamVjdE5hbWU/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3BoeXNpY3MnKVxyXG4gICAgICAgICAgICBjb25zdCBpc01hdGhQaHlzaWNzQiA9IGIuc3ViamVjdE5hbWU/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ21hdGhlbWF0aWNzJykgfHwgYi5zdWJqZWN0TmFtZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygncGh5c2ljcycpXHJcblxyXG4gICAgICAgICAgICBpZiAoaXNNYXRoUGh5c2ljc0EgJiYgIWlzTWF0aFBoeXNpY3NCKSByZXR1cm4gLTFcclxuICAgICAgICAgICAgaWYgKCFpc01hdGhQaHlzaWNzQSAmJiBpc01hdGhQaHlzaWNzQikgcmV0dXJuIDFcclxuXHJcbiAgICAgICAgICAgIC8vIEZvciBub24tcHJpb3JpdHkgc3ViamVjdHMsIHNvcnQgYnkgcGVyaW9kcyBwZXIgd2VlayAoaGlnaGVyID0gbW9yZSB1cmdlbnQpXHJcbiAgICAgICAgICAgIGlmIChhLnByaW9yaXR5ICE9PSBiLnByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmluYWxseSBieSB0b3RhbCBsZXNzb25zIChoaWdoZXIgZmlyc3QpXHJcbiAgICAgICAgICAgIHJldHVybiBiLnRvdGFsTGVzc29ucyAtIGEudG90YWxMZXNzb25zXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIHNjaGVkdWxlTGVzc29uKGxlc3NvbjogUHJlcGFyZWRMZXNzb24pIHtcclxuICAgICAgICBjb25zdCB7IHBlcmlvZHNQZXJXZWVrID0gMiwgYmxvY2tTaXplID0gMiB9ID0gbGVzc29uXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46vIFNUQVJUSU5HIExFU1NPTiBTQ0hFRFVMSU5HOiBFbmZvcmNpbmcgU1RSSUNUIDA4OjAwLTE2OjUwIHRpbWUgd2luZG93IChQMS1QMTAgb25seSlgKVxyXG5cclxuICAgICAgICBjb25zdCB0aW1lU2xvdHMgPSBhd2FpdCBkYi50aW1lU2xvdC5maW5kTWFueSh7XHJcbiAgICAgICAgICAgIHdoZXJlOiB7XHJcbiAgICAgICAgICAgICAgICBzY2hvb2xJZDogdGhpcy5zY2hvb2xJZCxcclxuICAgICAgICAgICAgICAgIGlzQWN0aXZlOiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9yZGVyQnk6IFtcclxuICAgICAgICAgICAgICAgIHsgZGF5OiAnYXNjJyB9LFxyXG4gICAgICAgICAgICAgICAgeyBwZXJpb2Q6ICdhc2MnIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFRPVEFMIFRJTUUgU0xPVFMgTE9BREVEOiAke3RpbWVTbG90cy5sZW5ndGh9IHNsb3RzIGZvciBzY2hvb2wgJHt0aGlzLnNjaG9vbElkfWApXHJcblxyXG4gICAgICAgIC8vIEdldCB0ZWFjaGVyIGF2YWlsYWJpbGl0eSBjb25zdHJhaW50cyBhbmQgY3VycmVudCB3b3JrbG9hZFxyXG4gICAgICAgIGNvbnN0IHRlYWNoZXJDb25zdHJhaW50cyA9IGF3YWl0IHRoaXMuZ2V0VGVhY2hlckNvbnN0cmFpbnRzKGxlc3Nvbi50ZWFjaGVySWQpXHJcbiAgICAgICAgY29uc3QgdGVhY2hlcldvcmtsb2FkID0gYXdhaXQgdGhpcy5nZXRUZWFjaGVyV29ya2xvYWQobGVzc29uLnRlYWNoZXJJZClcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIG1vcm5pbmcgcHJlZmVyZW5jZSBmb3IgVFNTIG1vZHVsZXNcclxuICAgICAgICBjb25zdCBpc1RTU01vZHVsZSA9IGxlc3Nvbi5sZXNzb25UeXBlID09PSAnVFNTJ1xyXG4gICAgICAgIGNvbnN0IHByZWZlcnNNb3JuaW5nID0gaXNUU1NNb2R1bGVcclxuXHJcbiAgICAgICAgLy8gQ1JJVElDQUw6IEdldCB0ZWFjaGVyJ3MgQUxMIGFzc2lnbm1lbnRzIGFjcm9zcyBzY2hvb2wgZm9yIHNjb3BlIHZhbGlkYXRpb25cclxuICAgICAgICBjb25zdCB0ZWFjaGVyQWxsQXNzaWdubWVudHMgPSBhd2FpdCB0aGlzLmdldFRlYWNoZXJBbGxBc3NpZ25tZW50cyhsZXNzb24udGVhY2hlcklkKVxyXG4gICAgICAgIGNvbnN0IHRlYWNoZXJDbGFzc2VzID0gbmV3IFNldCh0ZWFjaGVyQWxsQXNzaWdubWVudHMubWFwKGEgPT4gYS5jbGFzc0lkKSlcclxuICAgICAgICBjb25zdCB0ZWFjaGVyU3ViamVjdHMgPSBuZXcgU2V0KFtcclxuICAgICAgICAgICAgLi4udGVhY2hlckFsbEFzc2lnbm1lbnRzLmZpbHRlcihhID0+IGEuc3ViamVjdElkKS5tYXAoYSA9PiBhLnN1YmplY3RJZCEpLFxyXG4gICAgICAgICAgICAuLi50ZWFjaGVyQWxsQXNzaWdubWVudHMuZmlsdGVyKGEgPT4gYS5tb2R1bGVJZCkubWFwKGEgPT4gYS5tb2R1bGVJZCEpXHJcbiAgICAgICAgXSlcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYFNjaGVkdWxpbmcgJHtsZXNzb24uc3ViamVjdElkIHx8IGxlc3Nvbi5tb2R1bGVJZH0gLSBibG9jayBvZiAke2Jsb2NrU2l6ZX0gcGVyaW9kcyAoJHtsZXNzb24ubGVzc29uSW5kZXh9LyR7bGVzc29uLnRvdGFsTGVzc29uc30pYClcclxuXHJcbiAgICAgICAgLy8gRU5GT1JDRSBGTEVYSUJMRSBDT01QTEVNRU5UQVJZIE1PRFVMRVMgUlVMRVxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjb21wbGVtZW50YXJ5IG1vZHVsZVxyXG4gICAgICAgIGNvbnN0IGlzQ29tcGxlbWVudGFyeSA9IGxlc3Nvbi5sZXNzb25UeXBlID09PSAnVFNTJyAmJiBsZXNzb24ubW9kdWxlQ2F0ZWdvcnkgPT09ICdDT01QTEVNRU5UQVJZJ1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEVORk9SQ0UgQ09SRSBUSU1FIFJVTEU6IFNUUklDVExZIGVuZm9yY2UgMDg6MDAtMTY6NTAgdGltZSB3aW5kb3dcclxuICAgICAgICAvLyBPbmx5IGFsbG93IHBlcmlvZHMgUDEtUDEwICgwODowMC0xNjo1MCkgYW5kIE1vbmRheS1GcmlkYXkgb25seVxyXG4gICAgICAgIC8vIE5PIEVYQ0VQVElPTlMgLSBhbGwgbGVzc29ucyBNVVNUIGJlIHdpdGhpbiB0aGlzIHRpbWUgZnJhbWVcclxuICAgICAgICBjb25zdCB2YWxpZFRpbWVTbG90cyA9IHRpbWVTbG90cy5maWx0ZXIoKHRzOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGVyaW9kID0gdHMucGVyaW9kXHJcbiAgICAgICAgICAgIGNvbnN0IGRheSA9IHRzLmRheVxyXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkUGVyaW9kID0gcGVyaW9kID49IDEgJiYgcGVyaW9kIDw9IDEwXHJcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWREYXkgPSBkYXkgIT09ICdTQVRVUkRBWScgJiYgWydNT05EQVknLCAnVFVFU0RBWScsICdXRURORVNEQVknLCAnVEhVUlNEQVknLCAnRlJJREFZJ10uaW5jbHVkZXMoZGF5KVxyXG4gICAgICAgICAgICBjb25zdCBpc05vdEJyZWFrID0gISh0cyBhcyBhbnkpLmlzQnJlYWtcclxuXHJcbiAgICAgICAgICAgIC8vIExvZyBpbnZhbGlkIHNsb3RzIGZvciBkZWJ1Z2dpbmdcclxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkUGVyaW9kIHx8ICFpc1ZhbGlkRGF5IHx8ICFpc05vdEJyZWFrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4p2MIElOVkFMSUQgU0xPVCBGSUxURVJFRDogJHtkYXl9IFAke3BlcmlvZH0gLSBWYWxpZFBlcmlvZDogJHtpc1ZhbGlkUGVyaW9kfSwgVmFsaWREYXk6ICR7aXNWYWxpZERheX0sIE5vdEJyZWFrOiAke2lzTm90QnJlYWt9YClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRQZXJpb2QgJiYgaXNWYWxpZERheSAmJiBpc05vdEJyZWFrXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBWQUxJRCBUSU1FIFNMT1RTIEZPVU5EOiAke3ZhbGlkVGltZVNsb3RzLmxlbmd0aH0gc2xvdHMgKFAxLVAxMCwgTW9uLUZyaSwgbm8gYnJlYWtzKWApXHJcblxyXG4gICAgICAgIC8vIFRyeSB0byBmaW5kIGF2YWlsYWJsZSBzbG90IHdpdGggaW1wcm92ZWQgZGlzdHJpYnV0aW9uIGFjcm9zcyB0aGUgd2Vla1xyXG4gICAgICAgIC8vIENSSVRJQ0FMOiBPbmx5IHVzZSBzbG90cyB3aXRoaW4gMDg6MDAtMTY6NTAgdGltZSB3aW5kb3dcclxuICAgICAgICAvLyBGaXJzdCBwYXNzOiB0cnkgbW9ybmluZyBzbG90cyBmb3IgbW9kdWxlcyB0aGF0IHByZWZlciB0aGVtIChUU1MgUHJpb3JpdHkgUnVsZSlcclxuICAgICAgICBsZXQgc2xvdHNUb1RyeSA9IHByZWZlcnNNb3JuaW5nID9cclxuICAgICAgICAgICAgWy4uLnZhbGlkVGltZVNsb3RzLmZpbHRlcigodHM6IGFueSkgPT4gKHRzIGFzIGFueSkuc2Vzc2lvbiA9PT0gJ01PUk5JTkcnKSxcclxuICAgICAgICAgICAgIC4uLnZhbGlkVGltZVNsb3RzLmZpbHRlcigodHM6IGFueSkgPT4gKHRzIGFzIGFueSkuc2Vzc2lvbiAhPT0gJ01PUk5JTkcnKV0gOlxyXG4gICAgICAgICAgICB2YWxpZFRpbWVTbG90c1xyXG5cclxuICAgICAgICAvLyBGSU5BTCBWQUxJREFUSU9OOiBFbnN1cmUgbm8gc2xvdCBvdXRzaWRlIDA4OjAwLTE2OjUwIGdldHMgdGhyb3VnaFxyXG4gICAgICAgIHNsb3RzVG9UcnkgPSBzbG90c1RvVHJ5LmZpbHRlcigodHM6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwZXJpb2QgPSB0cy5wZXJpb2RcclxuICAgICAgICAgICAgY29uc3QgZGF5ID0gdHMuZGF5XHJcbiAgICAgICAgICAgIGNvbnN0IGlzV2l0aGluVGltZVdpbmRvdyA9IHBlcmlvZCA+PSAxICYmIHBlcmlvZCA8PSAxMCAmJiBkYXkgIT09ICdTQVRVUkRBWSdcclxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpblRpbWVXaW5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIFNMT1QgRklMVEVSRUQgT1VUOiAke2RheX0gUCR7cGVyaW9kfSAtIE91dHNpZGUgMDg6MDAtMTY6NTAgd2luZG93YClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXNXaXRoaW5UaW1lV2luZG93XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGNhY2hlIGZvciBicmVhayBjaGVja2luZ1xyXG4gICAgICAgIHRoaXMudGltZVNsb3RzQ2FjaGUgPSB0aW1lU2xvdHNcclxuXHJcbiAgICAgICAgLy8gU29ydCBzbG90cyB0byBkaXN0cmlidXRlIGxlc3NvbnMgZXZlbmx5IGFjcm9zcyB0aGUgd2Vla1xyXG4gICAgICAgIHNsb3RzVG9UcnkgPSB0aGlzLnNvcnRTbG90c0ZvckV2ZW5EaXN0cmlidXRpb24oc2xvdHNUb1RyeSwgbGVzc29uLnRlYWNoZXJJZCwgbGVzc29uLmNsYXNzSWQpXHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgdGltZVNsb3Qgb2Ygc2xvdHNUb1RyeSkge1xyXG4gICAgICAgICAgICBjb25zdCB0cyA9IHRpbWVTbG90IGFzIGFueSAvLyBDYXN0IHRvIGFjY2VzcyBuZXcgZmllbGRzXHJcblxyXG4gICAgICAgICAgICBjb25zdCBzbG90S2V5ID0gYCR7dGltZVNsb3QuZGF5fS0ke3RpbWVTbG90LnBlcmlvZH1gXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB0ZWFjaGVyIHVuYXZhaWxhYmxlIGRheXNcclxuICAgICAgICAgICAgaWYgKHRlYWNoZXJDb25zdHJhaW50cy51bmF2YWlsYWJsZURheXM/LmluY2x1ZGVzKHRpbWVTbG90LmRheSkpIGNvbnRpbnVlXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB0ZWFjaGVyIHVuYXZhaWxhYmxlIHBlcmlvZHNcclxuICAgICAgICAgICAgaWYgKHRlYWNoZXJDb25zdHJhaW50cy51bmF2YWlsYWJsZVBlcmlvZHM/LmluY2x1ZGVzKHRzLnBlcmlvZC50b1N0cmluZygpKSkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIC8vIEVORk9SQ0UgRE9VQkxFIFBFUklPRFMgUlVMRSBGT1IgU1BFQ0lGSUMgQU5EIEdFTkVSQUwgTU9EVUxFU1xyXG4gICAgICAgICAgICAvLyBDT01QTEVNRU5UQVJZIG1vZHVsZXMgZmlsbCByZW1haW5pbmcgZnJlZSBzcGFjZXNcclxuICAgICAgICAgICAgbGV0IGNhblNjaGVkdWxlQmxvY2tTaXplID0gYmxvY2tTaXplXHJcbiAgICAgICAgICAgIGNvbnN0IGlzU3BlY2lmaWNPckdlbmVyYWwgPSBsZXNzb24ubGVzc29uVHlwZSA9PT0gJ1RTUycgJiZcclxuICAgICAgICAgICAgICAgIChsZXNzb24ubW9kdWxlQ2F0ZWdvcnkgPT09ICdTUEVDSUZJQycgfHwgbGVzc29uLm1vZHVsZUNhdGVnb3J5ID09PSAnR0VORVJBTCcpXHJcblxyXG4gICAgICAgICAgICBpZiAoaXNDb21wbGVtZW50YXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDT01QTEVNRU5UQVJZIE1PRFVMRVM6IEZpbGwgcmVtYWluaW5nIGZyZWUgc3BhY2VzIC0gcHJpb3JpdGl6ZSBzaW5nbGUgcGVyaW9kcyB0byBhdm9pZCBjb25mbGljdHNcclxuICAgICAgICAgICAgICAgIC8vIFRyeSBzaW5nbGUgcGVyaW9kcyBmaXJzdCAodG8gYXZvaWQgY29uZmxpY3RzKSwgdXNlIGRvdWJsZSBwZXJpb2RzIG9ubHkgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5TY2hlZHVsZUJsb2NrKGxlc3Nvbi50ZWFjaGVySWQsIGxlc3Nvbi5jbGFzc0lkLCB0aW1lU2xvdC5kYXksIHRpbWVTbG90LnBlcmlvZCwgMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5TY2hlZHVsZUJsb2NrU2l6ZSA9IDEgLy8gUHJlZmVyIHNpbmdsZSBwZXJpb2RzIHRvIGF2b2lkIGNvbmZsaWN0c1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNhblNjaGVkdWxlQmxvY2sobGVzc29uLnRlYWNoZXJJZCwgbGVzc29uLmNsYXNzSWQsIHRpbWVTbG90LmRheSwgdGltZVNsb3QucGVyaW9kLCAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhblNjaGVkdWxlQmxvY2tTaXplID0gMiAvLyBVc2UgZG91YmxlIHBlcmlvZHMgb25seSBpZiBzaW5nbGUgbm90IGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSAvLyBObyBhdmFpbGFibGUgc2xvdCBhdCBhbGxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1NwZWNpZmljT3JHZW5lcmFsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTUEVDSUZJQyBBTkQgR0VORVJBTCBNT0RVTEVTOiBVc2UgdGhlIHByZXBhcmVkIGJsb2NrIHNpemUsIHdpdGggZmxleGliaWxpdHkgZm9yIG9kZCBwZXJpb2RzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJpb2RzUGVyV2VlayA9IGxlc3Nvbi5wZXJpb2RzUGVyV2VlayB8fCAyXHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja1NpemUgPSBsZXNzb24uYmxvY2tTaXplIHx8IDJcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzT2RkUGVyaW9kcyA9IHBlcmlvZHNQZXJXZWVrICUgMiA9PT0gMVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRyeSB0aGUgZXhhY3QgYmxvY2sgc2l6ZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuU2NoZWR1bGVCbG9jayhsZXNzb24udGVhY2hlcklkLCBsZXNzb24uY2xhc3NJZCwgdGltZVNsb3QuZGF5LCB0aW1lU2xvdC5wZXJpb2QsIGJsb2NrU2l6ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5TY2hlZHVsZUJsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChibG9ja1NpemUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiAyIG5vdCBhdmFpbGFibGUsIHRyeSAxIHBlcmlvZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhblNjaGVkdWxlQmxvY2sobGVzc29uLnRlYWNoZXJJZCwgbGVzc29uLmNsYXNzSWQsIHRpbWVTbG90LmRheSwgdGltZVNsb3QucGVyaW9kLCAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5TY2hlZHVsZUJsb2NrU2l6ZSA9IDFcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSAvLyBObyBhdmFpbGFibGUgc2xvdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2tTaXplID09PSAxIGFuZCBub3QgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE90aGVyIG1vZHVsZXMgKHJlZ3VsYXIgc3ViamVjdHMpOiB1c2UgY29uZmlndXJlZCBibG9jayBzaXplXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2FuU2NoZWR1bGVCbG9jayhsZXNzb24udGVhY2hlcklkLCBsZXNzb24uY2xhc3NJZCwgdGltZVNsb3QuZGF5LCB0aW1lU2xvdC5wZXJpb2QsIGJsb2NrU2l6ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDUklUSUNBTDogQ2hlY2sgZ2xvYmFsIHRlYWNoZXIgYXZhaWxhYmlsaXR5IChyZXNwZWN0cyBBTEwgZXhpc3RpbmcgdGltZXRhYmxlcyBhY3Jvc3Mgc2Nob29sKVxyXG4gICAgICAgICAgICBjb25zdCB0ZWFjaGVyQXZhaWxhYmxlID0gIXRoaXMudGVhY2hlckF2YWlsYWJpbGl0eVtsZXNzb24udGVhY2hlcklkXT8uaGFzKHNsb3RLZXkpXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBjbGFzcyBhdmFpbGFiaWxpdHlcclxuICAgICAgICAgICAgY29uc3QgY2xhc3NBdmFpbGFibGUgPSAhdGhpcy5jbGFzc0F2YWlsYWJpbGl0eVtsZXNzb24uY2xhc3NJZF0/LmhhcyhzbG90S2V5KVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgbWF4IGNvbnNlY3V0aXZlIHBlcmlvZHMgcnVsZSBmb3IgdGhpcyB0ZWFjaGVyXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BlY3RzQ29uc2VjdXRpdmVSdWxlID0gdGhpcy5jYW5TY2hlZHVsZUNvbnNlY3V0aXZlKGxlc3Nvbi50ZWFjaGVySWQsIHRpbWVTbG90LmRheSwgdGltZVNsb3QucGVyaW9kLCAxKVxyXG5cclxuICAgICAgICAgICAgLy8gRW5oYW5jZWQgc2NvcGUgdmFsaWRhdGlvbjogQ2hlY2sgaWYgdGVhY2hlciB3b3VsZCBiZSBvdmVyLXNjaGVkdWxlZCBhY3Jvc3MgYWxsIHRoZWlyIGNsYXNzZXNcclxuICAgICAgICAgICAgY29uc3QgcmVzcGVjdHNXb3JrbG9hZEJhbGFuY2UgPSB0aGlzLmlzV29ya2xvYWRCYWxhbmNlZChsZXNzb24udGVhY2hlcklkLCBsZXNzb24uY2xhc3NJZCwgdGltZVNsb3QuZGF5KVxyXG5cclxuICAgICAgICAgICAgaWYgKHRlYWNoZXJBdmFpbGFibGUgJiYgY2xhc3NBdmFpbGFibGUgJiYgcmVzcGVjdHNDb25zZWN1dGl2ZVJ1bGUgJiYgcmVzcGVjdHNXb3JrbG9hZEJhbGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBibG9jayBvZiBjb25zZWN1dGl2ZSBwZXJpb2RzXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhblNjaGVkdWxlQmxvY2tTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGVyaW9kID0gdGltZVNsb3QucGVyaW9kICsgaVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTbG90S2V5ID0gYCR7dGltZVNsb3QuZGF5fS0ke2N1cnJlbnRQZXJpb2R9YFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRpbWVTbG90SWQgZm9yIHRoaXMgcGVyaW9kIChhc3N1bWluZyBwZXJpb2RzIGFyZSBjb25zZWN1dGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZVNsb3QgPSB0aW1lU2xvdHMuZmluZCgodHM6IGFueSkgPT4gdHMuZGF5ID09PSB0aW1lU2xvdC5kYXkgJiYgdHMucGVyaW9kID09PSBjdXJyZW50UGVyaW9kKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFRpbWVTbG90KSBjb250aW51ZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlZExlc3NvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYWNoZXJJZDogbGVzc29uLnRlYWNoZXJJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdElkOiBsZXNzb24uc3ViamVjdElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVJZDogbGVzc29uLm1vZHVsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0lkOiBsZXNzb24uY2xhc3NJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5OiB0aW1lU2xvdC5kYXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJpb2Q6IGN1cnJlbnRQZXJpb2QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lU2xvdElkOiBjdXJyZW50VGltZVNsb3QuaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IGxlc3Nvbi5wcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgYXMgb2NjdXBpZWQgaW4gYm90aCB0ZWFjaGVyIGFuZCBjbGFzcyBhdmFpbGFiaWxpdHlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlYWNoZXJBdmFpbGFiaWxpdHlbbGVzc29uLnRlYWNoZXJJZF0uYWRkKGN1cnJlbnRTbG90S2V5KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NBdmFpbGFiaWxpdHlbbGVzc29uLmNsYXNzSWRdLmFkZChjdXJyZW50U2xvdEtleSlcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja0Rlc2NyaXB0aW9uID0gaXNDb21wbGVtZW50YXJ5ICYmIGNhblNjaGVkdWxlQmxvY2tTaXplID09PSAxXHJcbiAgICAgICAgICAgICAgICAgICAgPyBgQ09ORkxJQ1QtQVZPSUQ6IDEgcGVyaW9kYFxyXG4gICAgICAgICAgICAgICAgICAgIDogYCR7Y2FuU2NoZWR1bGVCbG9ja1NpemV9IHBlcmlvZHNgXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgU2NoZWR1bGVkICR7YmxvY2tEZXNjcmlwdGlvbn0gZm9yICR7bGVzc29uLnN1YmplY3RJZCB8fCBsZXNzb24ubW9kdWxlSWR9IGF0ICR7c2xvdEtleX1gKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vIGF2YWlsYWJsZSBzbG90IGZvdW5kIC0gZmxhZyB1bnJlc29sdmVkIGNvbmZsaWN0XHJcbiAgICAgICAgY29uc3QgdGVhY2hlck5hbWUgPSBsZXNzb24udGVhY2hlck5hbWUgfHwgYXdhaXQgdGhpcy5nZXRUZWFjaGVyTmFtZShsZXNzb24udGVhY2hlcklkKVxyXG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGxlc3Nvbi5jbGFzc05hbWUgfHwgYXdhaXQgdGhpcy5nZXRDbGFzc05hbWUobGVzc29uLmNsYXNzSWQpXHJcbiAgICAgICAgY29uc3Qgc3ViamVjdE5hbWUgPSBsZXNzb24uc3ViamVjdE5hbWUgfHwgbGVzc29uLm1vZHVsZU5hbWUgfHxcclxuICAgICAgICAgICAgKGxlc3Nvbi5zdWJqZWN0SWQgPyBhd2FpdCB0aGlzLmdldFN1YmplY3ROYW1lKGxlc3Nvbi5zdWJqZWN0SWQhKSA6IChsZXNzb24ubW9kdWxlSWQgPyBhd2FpdCB0aGlzLmdldE1vZHVsZU5hbWUobGVzc29uLm1vZHVsZUlkISkgOiAnVW5rbm93bicpKVxyXG5cclxuICAgICAgICAvLyBFbmhhbmNlZCBjb25mbGljdCBhbmFseXNpc1xyXG4gICAgICAgIGNvbnN0IGlzR2xvYmFsQ29uZmxpY3QgPSB0aGlzLmlzVGVhY2hlck92ZXJib29rZWQobGVzc29uLnRlYWNoZXJJZClcclxuICAgICAgICBjb25zdCBoYXNNdWx0aXBsZUNsYXNzZXMgPSB0ZWFjaGVyQ2xhc3Nlcy5zaXplID4gMVxyXG4gICAgICAgIGNvbnN0IGhhc011bHRpcGxlU3ViamVjdHMgPSB0ZWFjaGVyU3ViamVjdHMuc2l6ZSA+IDFcclxuICAgICAgICBjb25zdCBzY29wZUNvbmZsaWN0ID0gaGFzTXVsdGlwbGVDbGFzc2VzIHx8IGhhc011bHRpcGxlU3ViamVjdHNcclxuICAgICAgICBjb25zdCBpc1NwZWNpZmljT3JHZW5lcmFsID0gbGVzc29uLmxlc3NvblR5cGUgPT09ICdUU1MnICYmXHJcbiAgICAgICAgICAgIChsZXNzb24ubW9kdWxlQ2F0ZWdvcnkgPT09ICdTUEVDSUZJQycgfHwgbGVzc29uLm1vZHVsZUNhdGVnb3J5ID09PSAnR0VORVJBTCcpXHJcblxyXG4gICAgICAgIGxldCBjb25mbGljdERldGFpbCA9ICcnXHJcbiAgICAgICAgaWYgKHNjb3BlQ29uZmxpY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgZGV0YWlsczogc3RyaW5nW10gPSBbXVxyXG4gICAgICAgICAgICBpZiAoaGFzTXVsdGlwbGVDbGFzc2VzKSBkZXRhaWxzLnB1c2goYCR7dGVhY2hlckNsYXNzZXMuc2l6ZX0gY2xhc3Nlc2ApXHJcbiAgICAgICAgICAgIGlmIChoYXNNdWx0aXBsZVN1YmplY3RzKSBkZXRhaWxzLnB1c2goYCR7dGVhY2hlclN1YmplY3RzLnNpemV9IHN1YmplY3RzL21vZHVsZXNgKVxyXG4gICAgICAgICAgICBjb25mbGljdERldGFpbCA9IGAgLSBUZWFjaGVyIHNjb3BlOiAke2RldGFpbHMuam9pbignLCAnKX1gXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFTkZPUkNFIERPVUJMRSBQRVJJT0RTIFJVTEU6IERpZmZlcmVudCBtZXNzYWdpbmcgYmFzZWQgb24gbW9kdWxlIHR5cGVcclxuICAgICAgICBsZXQgY29uZmxpY3RNZXNzYWdlOiBzdHJpbmdcclxuICAgICAgICBsZXQgY29uZmxpY3RTdWdnZXN0aW9uczogc3RyaW5nW11cclxuXHJcbiAgICAgICAgaWYgKGlzU3BlY2lmaWNPckdlbmVyYWwpIHtcclxuICAgICAgICAgICAgLy8gU1BFQ0lGSUMgQU5EIEdFTkVSQUwgTU9EVUxFUzogQ29uc2VjdXRpdmUgcGVyaW9kcyBiYXNlZCBvbiBwZXJpb2RzIHBlciB3ZWVrXHJcbiAgICAgICAgICAgIGNvbnN0IGlzT2RkUGVyaW9kcyA9IChsZXNzb24ucGVyaW9kc1BlcldlZWsgfHwgMikgJSAyID09PSAxXHJcbiAgICAgICAgICAgIGlmIChpc09kZFBlcmlvZHMpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZvciBvZGQgcGVyaW9kcyBwZXIgd2VlazogbWluIDIsIG1heCAzIGNvbnNlY3V0aXZlIHBlcmlvZHNcclxuICAgICAgICAgICAgICAgIGNvbmZsaWN0TWVzc2FnZSA9IGBDb3VsZCBub3Qgc2NoZWR1bGUgJHtzdWJqZWN0TmFtZX0gKFJFUVVJUkVTIDIgb3IgMyBjb25zZWN1dGl2ZSBwZXJpb2RzIC0gU1BFQ0lGSUMvR0VORVJBTCBtb2R1bGUgd2l0aCBvZGQgcGVyaW9kcyBwZXIgd2VlaykgZm9yICR7dGVhY2hlck5hbWV9IGluICR7Y2xhc3NOYW1lfSR7Y29uZmxpY3REZXRhaWx9YFxyXG4gICAgICAgICAgICAgICAgY29uZmxpY3RTdWdnZXN0aW9ucyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAnQ1JJVElDQUw6IFNQRUNJRklDIGFuZCBHRU5FUkFMIG1vZHVsZXMgd2l0aCBvZGQgcGVyaW9kcyBwZXIgd2VlayBNVVNUIGhhdmUgMiBvciAzIGNvbnNlY3V0aXZlIHBlcmlvZHMnLFxyXG4gICAgICAgICAgICAgICAgICAgICdUcmllZCAyIHBlcmlvZHMgZmlyc3QsIHRoZW4gMyBwZXJpb2RzJyxcclxuICAgICAgICAgICAgICAgICAgICAnQWRkIG1vcmUgY29uc2VjdXRpdmUgZnJlZSBzbG90cyBpbiBQMS1QMTAgcmFuZ2UgKDIgb3IgMyBjb25zZWN1dGl2ZSBwZXJpb2RzKScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ0Vuc3VyZSBubyBicmVha3MgaW50ZXJydXB0IHRoZSByZXF1aXJlZCBjb25zZWN1dGl2ZSBwZXJpb2QgYmxvY2tzJyxcclxuICAgICAgICAgICAgICAgICAgICAnQ2hlY2sgdGVhY2hlciBhdmFpbGFiaWxpdHkgZm9yIGNvbnNlY3V0aXZlIG1vcm5pbmcgc2xvdHMnLFxyXG4gICAgICAgICAgICAgICAgICAgICdSZWR1Y2UgdGVhY2hlciB3b3JrbG9hZCB0byBmcmVlIHVwIGNvbnNlY3V0aXZlIHBlcmlvZHMnLFxyXG4gICAgICAgICAgICAgICAgICAgICdDb25zaWRlciByZXNjaGVkdWxpbmcgb3RoZXIgbGVzc29ucyB0byBjcmVhdGUgMi0zIHBlcmlvZCBibG9ja3MnLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLihzY29wZUNvbmZsaWN0ID8gW2BUZWFjaGVyIHRlYWNoZXMgYWNyb3NzICR7dGVhY2hlckNsYXNzZXMuc2l6ZX0gY2xhc3NlcyBhbmQgJHt0ZWFjaGVyU3ViamVjdHMuc2l6ZX0gc3ViamVjdHMvbW9kdWxlcyAtIG1heSBuZWVkIHdvcmtsb2FkIHJlZGlzdHJpYnV0aW9uYF0gOiBbXSksXHJcbiAgICAgICAgICAgICAgICAgICAgJ1NPTFVUSU9OOiBFbnN1cmUgYXQgbGVhc3QgMiBvciAzIGNvbnNlY3V0aXZlIGZyZWUgcGVyaW9kcyBleGlzdCBpbiB0ZWFjaGVyL2NsYXNzIHNjaGVkdWxlJ1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV2ZW4gcGVyaW9kcyBwZXIgd2VlazogMiBjb25zZWN1dGl2ZSBwZXJpb2RzXHJcbiAgICAgICAgICAgICAgICBjb25mbGljdE1lc3NhZ2UgPSBgQ291bGQgbm90IHNjaGVkdWxlICR7c3ViamVjdE5hbWV9IChSRVFVSVJFUyAyIGNvbnNlY3V0aXZlIHBlcmlvZHMgLSBTUEVDSUZJQy9HRU5FUkFMIG1vZHVsZSkgZm9yICR7dGVhY2hlck5hbWV9IGluICR7Y2xhc3NOYW1lfSR7Y29uZmxpY3REZXRhaWx9YFxyXG4gICAgICAgICAgICAgICAgY29uZmxpY3RTdWdnZXN0aW9ucyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAnQ1JJVElDQUw6IFNQRUNJRklDIGFuZCBHRU5FUkFMIG1vZHVsZXMgTVVTVCBoYXZlIDIgY29uc2VjdXRpdmUgcGVyaW9kcycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ0FkZCBtb3JlIGNvbnNlY3V0aXZlIGZyZWUgc2xvdHMgaW4gUDEtUDEwIHJhbmdlJyxcclxuICAgICAgICAgICAgICAgICAgICAnRW5zdXJlIG5vIGJyZWFrcyBpbnRlcnJ1cHQgdGhlIHJlcXVpcmVkIDItcGVyaW9kIGJsb2NrcycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ0NoZWNrIHRlYWNoZXIgYXZhaWxhYmlsaXR5IGZvciBjb25zZWN1dGl2ZSBtb3JuaW5nIHNsb3RzJyxcclxuICAgICAgICAgICAgICAgICAgICAnUmVkdWNlIHRlYWNoZXIgd29ya2xvYWQgdG8gZnJlZSB1cCBjb25zZWN1dGl2ZSBwZXJpb2RzJyxcclxuICAgICAgICAgICAgICAgICAgICAnQ29uc2lkZXIgcmVzY2hlZHVsaW5nIG90aGVyIGxlc3NvbnMgdG8gY3JlYXRlIDItcGVyaW9kIGJsb2NrcycsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uKHNjb3BlQ29uZmxpY3QgPyBbYFRlYWNoZXIgdGVhY2hlcyBhY3Jvc3MgJHt0ZWFjaGVyQ2xhc3Nlcy5zaXplfSBjbGFzc2VzIGFuZCAke3RlYWNoZXJTdWJqZWN0cy5zaXplfSBzdWJqZWN0cy9tb2R1bGVzIC0gbWF5IG5lZWQgd29ya2xvYWQgcmVkaXN0cmlidXRpb25gXSA6IFtdKSxcclxuICAgICAgICAgICAgICAgICAgICAnU09MVVRJT046IEVuc3VyZSBhdCBsZWFzdCAyIGNvbnNlY3V0aXZlIGZyZWUgcGVyaW9kcyBleGlzdCBpbiB0ZWFjaGVyL2NsYXNzIHNjaGVkdWxlJ1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0NvbXBsZW1lbnRhcnkpIHtcclxuICAgICAgICAgICAgLy8gQ09NUExFTUVOVEFSWSBNT0RVTEVTOiBGaWxsIHJlbWFpbmluZyBmcmVlIHNwYWNlcyAtIHByaW9yaXRpemUgc2luZ2xlIHBlcmlvZHNcclxuICAgICAgICAgICAgY29uZmxpY3RNZXNzYWdlID0gYENvdWxkIG5vdCBzY2hlZHVsZSAke3N1YmplY3ROYW1lfSAodHJpZWQgMSBwZXJpb2QgcHJlZmVycmVkIHRvIGF2b2lkIGNvbmZsaWN0cywgdGhlbiAyIHBlcmlvZHMpIGZvciAke3RlYWNoZXJOYW1lfSBpbiAke2NsYXNzTmFtZX0ke2NvbmZsaWN0RGV0YWlsfWBcclxuICAgICAgICAgICAgY29uZmxpY3RTdWdnZXN0aW9ucyA9IFtcclxuICAgICAgICAgICAgICAgICdDT01QTEVNRU5UQVJZIE1PRFVMRTogRmlsbHMgcmVtYWluaW5nIGZyZWUgc3BhY2VzIC0gcHJpb3JpdGl6ZXMgc2luZ2xlIHBlcmlvZHMgdG8gYXZvaWQgY29uZmxpY3RzJyxcclxuICAgICAgICAgICAgICAgICdBZGQgbW9yZSBmcmVlIHRpbWUgc2xvdHMgYW55d2hlcmUgaW4gUDEtUDEwJyxcclxuICAgICAgICAgICAgICAgICdUaGVzZSBtb2R1bGVzIGFyZSBmbGV4aWJsZSBhbmQgZmlsbCBnYXBzIGluIHRoZSBzY2hlZHVsZScsXHJcbiAgICAgICAgICAgICAgICAnUmVkdWNlIHRlYWNoZXIgd29ya2xvYWQgdG8gY3JlYXRlIG1vcmUgZnJlZSBzbG90cycsXHJcbiAgICAgICAgICAgICAgICAnQ2hlY2sgZm9yIGFueSByZW1haW5pbmcgdW5zY2hlZHVsZWQgcGVyaW9kcycsXHJcbiAgICAgICAgICAgICAgICAuLi4oc2NvcGVDb25mbGljdCA/IFtgVGVhY2hlciBoYXMgYnJvYWQgc2NvcGUgLSBjb21wbGVtZW50YXJ5IG1vZHVsZXMgZmlsbCByZW1haW5pbmcgc2xvdHNgXSA6IFtdKSxcclxuICAgICAgICAgICAgICAgICdOT1RFOiBDb21wbGVtZW50YXJ5IG1vZHVsZXMgcHJpb3JpdGl6ZSBzaW5nbGUgcGVyaW9kcyB0byBhdm9pZCBzY2hlZHVsaW5nIGNvbmZsaWN0cydcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgc3ViamVjdHM6IFVzZSBjb25maWd1cmVkIGJsb2NrIHNpemVcclxuICAgICAgICAgICAgY29uZmxpY3RNZXNzYWdlID0gYENvdWxkIG5vdCBzY2hlZHVsZSAke3N1YmplY3ROYW1lfSBibG9jayAoJHtibG9ja1NpemV9IGNvbnNlY3V0aXZlIHBlcmlvZHMgcmVxdWlyZWQpIGZvciAke3RlYWNoZXJOYW1lfSBpbiAke2NsYXNzTmFtZX0ke2NvbmZsaWN0RGV0YWlsfWBcclxuICAgICAgICAgICAgY29uZmxpY3RTdWdnZXN0aW9ucyA9IFtcclxuICAgICAgICAgICAgICAgICdBZGQgbW9yZSBjb25zZWN1dGl2ZSB0aW1lIHNsb3RzIHRvIHRoZSBzY2hlZHVsZScsXHJcbiAgICAgICAgICAgICAgICAnRW5zdXJlIG5vIGJyZWFrcyBpbnRlcnJ1cHQgdGhlIHJlcXVpcmVkIGNvbnNlY3V0aXZlIHBlcmlvZHMnLFxyXG4gICAgICAgICAgICAgICAgJ1JlZHVjZSB0ZWFjaGVyIHdvcmtsb2FkIG9yIHJlZGlzdHJpYnV0ZSBhc3NpZ25tZW50cycsXHJcbiAgICAgICAgICAgICAgICAnQ2hlY2sgdGVhY2hlciBhdmFpbGFiaWxpdHkgY29uc3RyYWludHMgYWNyb3NzIGFsbCBjbGFzc2VzJyxcclxuICAgICAgICAgICAgICAgICdDb25zaWRlciBtYW51YWwgc2NoZWR1bGluZyBmb3IgdGhpcyBzcGVjaWZpYyBsZXNzb24nLFxyXG4gICAgICAgICAgICAgICAgLi4uKHNjb3BlQ29uZmxpY3QgPyBbYFRlYWNoZXIgdGVhY2hlcyBhY3Jvc3MgJHt0ZWFjaGVyQ2xhc3Nlcy5zaXplfSBjbGFzc2VzIGFuZCAke3RlYWNoZXJTdWJqZWN0cy5zaXplfSBzdWJqZWN0cy9tb2R1bGVzIC0gY29uc2lkZXIgd29ya2xvYWQgcmVkaXN0cmlidXRpb25gXSA6IFtdKSxcclxuICAgICAgICAgICAgICAgIGBDUklUSUNBTDogJHtzdWJqZWN0TmFtZX0gcmVxdWlyZXMgJHtibG9ja1NpemV9IENPTlNFQ1VUSVZFIHBlcmlvZHMgd2l0aG91dCBicmVha3NgXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmxpY3RzLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiAndW5hc3NpZ25lZCcsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNvbmZsaWN0TWVzc2FnZSxcclxuICAgICAgICAgICAgc3VnZ2VzdGlvbnM6IGNvbmZsaWN0U3VnZ2VzdGlvbnMuZmlsdGVyKEJvb2xlYW4pIGFzIHN0cmluZ1tdXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYOKdjCBGYWlsZWQgdG8gc2NoZWR1bGUgJHtzdWJqZWN0TmFtZX0gYmxvY2sgZm9yIHRlYWNoZXIgJHtsZXNzb24udGVhY2hlcklkfSBpbiBjbGFzcyAke2xlc3Nvbi5jbGFzc0lkfWApXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzb3J0U2xvdHNGb3JFdmVuRGlzdHJpYnV0aW9uKHNsb3RzOiBhbnlbXSwgdGVhY2hlcklkOiBzdHJpbmcsIGNsYXNzSWQ6IHN0cmluZyk6IGFueVtdIHtcclxuICAgICAgICAvLyBDb3VudCBjdXJyZW50IGxlc3NvbnMgcGVyIGRheSBmb3IgdGhpcyB0ZWFjaGVyIGFuZCBjbGFzc1xyXG4gICAgICAgIGNvbnN0IHRlYWNoZXJMZXNzb25zQnlEYXkgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpXHJcbiAgICAgICAgY29uc3QgY2xhc3NMZXNzb25zQnlEYXkgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpXHJcblxyXG4gICAgICAgIC8vIENvdW50IGV4aXN0aW5nIHNjaGVkdWxlZCBsZXNzb25zXHJcbiAgICAgICAgdGhpcy5zY2hlZHVsZWRMZXNzb25zLmZvckVhY2gobGVzc29uID0+IHtcclxuICAgICAgICAgICAgaWYgKGxlc3Nvbi50ZWFjaGVySWQgPT09IHRlYWNoZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSB0ZWFjaGVyTGVzc29uc0J5RGF5LmdldChsZXNzb24uc2xvdC5kYXkpIHx8IDBcclxuICAgICAgICAgICAgICAgIHRlYWNoZXJMZXNzb25zQnlEYXkuc2V0KGxlc3Nvbi5zbG90LmRheSwgY291bnQgKyAxKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZXNzb24uY2xhc3NJZCA9PT0gY2xhc3NJZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBjbGFzc0xlc3NvbnNCeURheS5nZXQobGVzc29uLnNsb3QuZGF5KSB8fCAwXHJcbiAgICAgICAgICAgICAgICBjbGFzc0xlc3NvbnNCeURheS5zZXQobGVzc29uLnNsb3QuZGF5LCBjb3VudCArIDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyBTb3J0IHNsb3RzIGJ5IGNvbWJpbmVkIHNjb3JlIChsb3dlciBpcyBiZXR0ZXIgLSBwcmVmZXJzIGRheXMgd2l0aCBmZXdlciBsZXNzb25zKVxyXG4gICAgICAgIHJldHVybiBzbG90cy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlYWNoZXJTY29yZUEgPSB0ZWFjaGVyTGVzc29uc0J5RGF5LmdldChhLmRheSkgfHwgMFxyXG4gICAgICAgICAgICBjb25zdCBjbGFzc1Njb3JlQSA9IGNsYXNzTGVzc29uc0J5RGF5LmdldChhLmRheSkgfHwgMFxyXG4gICAgICAgICAgICBjb25zdCB0b3RhbFNjb3JlQSA9IHRlYWNoZXJTY29yZUEgKyBjbGFzc1Njb3JlQVxyXG5cclxuICAgICAgICAgICAgY29uc3QgdGVhY2hlclNjb3JlQiA9IHRlYWNoZXJMZXNzb25zQnlEYXkuZ2V0KGIuZGF5KSB8fCAwXHJcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzU2NvcmVCID0gY2xhc3NMZXNzb25zQnlEYXkuZ2V0KGIuZGF5KSB8fCAwXHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsU2NvcmVCID0gdGVhY2hlclNjb3JlQiArIGNsYXNzU2NvcmVCXHJcblxyXG4gICAgICAgICAgICAvLyBJZiBzY29yZXMgYXJlIGVxdWFsLCBtYWludGFpbiBvcmlnaW5hbCBvcmRlciAoYnkgcGVyaW9kKVxyXG4gICAgICAgICAgICBpZiAodG90YWxTY29yZUEgPT09IHRvdGFsU2NvcmVCKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5kYXkgPT09IGIuZGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEucGVyaW9kIC0gYi5wZXJpb2RcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmRheS5sb2NhbGVDb21wYXJlKGIuZGF5KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG90YWxTY29yZUEgLSB0b3RhbFNjb3JlQlxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjYW5TY2hlZHVsZUJsb2NrKHRlYWNoZXJJZDogc3RyaW5nLCBjbGFzc0lkOiBzdHJpbmcsIGRheTogc3RyaW5nLCBzdGFydFBlcmlvZDogbnVtYmVyLCBibG9ja1NpemU6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vIEVORk9SQ0UgU1RSSUNUIENPUkUgVElNRSBSVUxFOiBBTEwgbGVzc29ucyBNVVNUIGJlIHdpdGhpbiAwODowMC0xNjo1MCAoUDEtUDEwKVxyXG4gICAgICAgIC8vIE5PIEVYQ0VQVElPTlMgLSByZWplY3QgYW55IGJsb2NrIHRoYXQgZXh0ZW5kcyBiZXlvbmQgUDEwXHJcblxyXG4gICAgICAgIC8vIENSSVRJQ0FMOiBDaGVjayBpZiB0aGUgYmxvY2sgd291bGQgZXh0ZW5kIGJleW9uZCBQMTAgKDE2OjUwKVxyXG4gICAgICAgIGNvbnN0IGVuZFBlcmlvZCA9IHN0YXJ0UGVyaW9kICsgYmxvY2tTaXplIC0gMVxyXG4gICAgICAgIGlmIChlbmRQZXJpb2QgPiAxMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4p2MIEJMT0NLIFJFSkVDVEVEOiBFbmQgcGVyaW9kICR7ZW5kUGVyaW9kfSBleGNlZWRzIFAxMCAoMTY6NTApIGxpbWl0YClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlIC8vIENhbm5vdCBzY2hlZHVsZSBiZXlvbmQgcGVyaW9kIDEwICgxNjo1MClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVORk9SQ0UgU1RBUlQgVElNRSBSVUxFOiBDYW5ub3Qgc3RhcnQgYmVmb3JlIFAxICgwODowMClcclxuICAgICAgICBpZiAoc3RhcnRQZXJpb2QgPCAxKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinYwgQkxPQ0sgUkVKRUNURUQ6IFN0YXJ0IHBlcmlvZCAke3N0YXJ0UGVyaW9kfSBpcyBiZWZvcmUgUDEgKDA4OjAwKWApXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZSAvLyBDYW5ub3Qgc2NoZWR1bGUgYmVmb3JlIHBlcmlvZCAxICgwODowMClcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwZXJpb2QgPSBzdGFydFBlcmlvZCArIGlcclxuICAgICAgICAgICAgY29uc3Qgc2xvdEtleSA9IGAke2RheX0tJHtwZXJpb2R9YFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcGVyaW9kIGV4aXN0cyBhbmQgaXMgbm90IGEgYnJlYWtcclxuICAgICAgICAgICAgY29uc3QgdGltZVNsb3QgPSB0aGlzLnRpbWVTbG90c0NhY2hlPy5maW5kKHRzID0+IHRzLmRheSA9PT0gZGF5ICYmIHRzLnBlcmlvZCA9PT0gcGVyaW9kKVxyXG4gICAgICAgICAgICBpZiAoIXRpbWVTbG90IHx8IHRpbWVTbG90LmlzQnJlYWspIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZSAvLyBDYW5ub3Qgc2NoZWR1bGUgb24gYnJlYWsgcGVyaW9kc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDaGVjayB0ZWFjaGVyIGFuZCBjbGFzcyBhdmFpbGFiaWxpdHlcclxuICAgICAgICAgICAgY29uc3QgdGVhY2hlckF2YWlsYWJsZSA9ICF0aGlzLnRlYWNoZXJBdmFpbGFiaWxpdHlbdGVhY2hlcklkXT8uaGFzKHNsb3RLZXkpXHJcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzQXZhaWxhYmxlID0gIXRoaXMuY2xhc3NBdmFpbGFiaWxpdHlbY2xhc3NJZF0/LmhhcyhzbG90S2V5KVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCF0ZWFjaGVyQXZhaWxhYmxlIHx8ICFjbGFzc0F2YWlsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGlzVGVhY2hlck92ZXJib29rZWQodGVhY2hlcklkOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICAvLyBDaGVjayBpZiB0ZWFjaGVyIGhhcyBtYW55IHNjaGVkdWxlZCBsZXNzb25zIHRoYXQgbWlnaHQgaW5kaWNhdGUgb3ZlcmJvb2tpbmdcclxuICAgICAgICBjb25zdCB0ZWFjaGVyTGVzc29ucyA9IHRoaXMuc2NoZWR1bGVkTGVzc29ucy5maWx0ZXIobGVzc29uID0+IGxlc3Nvbi50ZWFjaGVySWQgPT09IHRlYWNoZXJJZClcclxuICAgICAgICByZXR1cm4gdGVhY2hlckxlc3NvbnMubGVuZ3RoID4gMTAgLy8gVGhyZXNob2xkIGZvciBwb3RlbnRpYWwgb3ZlcmJvb2tpbmdcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNhblNjaGVkdWxlQ29uc2VjdXRpdmUodGVhY2hlcklkOiBzdHJpbmcsIGRheTogc3RyaW5nLCBwZXJpb2Q6IG51bWJlciwgbWF4Q29uc2VjdXRpdmU6IG51bWJlciA9IDIpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCB0ZWFjaGVyU2xvdHMgPSBBcnJheS5mcm9tKHRoaXMudGVhY2hlckF2YWlsYWJpbGl0eVt0ZWFjaGVySWRdIHx8IFtdKVxyXG4gICAgICAgICAgICAuZmlsdGVyKHNsb3QgPT4gc2xvdC5zdGFydHNXaXRoKGRheSkpXHJcbiAgICAgICAgICAgIC5tYXAoc2xvdCA9PiBwYXJzZUludChzbG90LnNwbGl0KCctJylbMV0pKVxyXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpXHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHNjaGVkdWxpbmcgdGhpcyBwZXJpb2Qgd291bGQgY3JlYXRlIG1vcmUgdGhhbiBtYXhDb25zZWN1dGl2ZSBjb25zZWN1dGl2ZSBwZXJpb2RzXHJcbiAgICAgICAgY29uc3QgY29uc2VjdXRpdmVCZWZvcmUgPSB0aGlzLmdldENvbnNlY3V0aXZlQ291bnQodGVhY2hlclNsb3RzLCBwZXJpb2QgLSAxKVxyXG4gICAgICAgIGNvbnN0IGNvbnNlY3V0aXZlQWZ0ZXIgPSB0aGlzLmdldENvbnNlY3V0aXZlQ291bnQodGVhY2hlclNsb3RzLCBwZXJpb2QgKyAxKVxyXG5cclxuICAgICAgICByZXR1cm4gKGNvbnNlY3V0aXZlQmVmb3JlIDwgbWF4Q29uc2VjdXRpdmUpICYmIChjb25zZWN1dGl2ZUFmdGVyIDwgbWF4Q29uc2VjdXRpdmUpXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRDb25zZWN1dGl2ZUNvdW50KHNsb3RzOiBudW1iZXJbXSwgcGVyaW9kOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBjb3VudCA9IDBcclxuICAgICAgICBsZXQgY3VycmVudCA9IHBlcmlvZFxyXG5cclxuICAgICAgICB3aGlsZSAoc2xvdHMuaW5jbHVkZXMoY3VycmVudCkpIHtcclxuICAgICAgICAgICAgY291bnQrK1xyXG4gICAgICAgICAgICBjdXJyZW50KytcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb3VudFxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0VGVhY2hlck5hbWUodGVhY2hlcklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGNvbnN0IHRlYWNoZXIgPSBhd2FpdCBkYi51c2VyLmZpbmRVbmlxdWUoe1xyXG4gICAgICAgICAgICB3aGVyZTogeyBpZDogdGVhY2hlcklkIH0sXHJcbiAgICAgICAgICAgIHNlbGVjdDogeyBuYW1lOiB0cnVlIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiB0ZWFjaGVyPy5uYW1lIHx8ICdVbmtub3duIFRlYWNoZXInXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRDbGFzc05hbWUoY2xhc3NJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICBjb25zdCBjbHMgPSBhd2FpdCBkYi5jbGFzcy5maW5kVW5pcXVlKHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGNsYXNzSWQgfSxcclxuICAgICAgICAgICAgc2VsZWN0OiB7IG5hbWU6IHRydWUgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIGNscz8ubmFtZSB8fCAnVW5rbm93biBDbGFzcydcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldFN1YmplY3ROYW1lKHN1YmplY3RJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICBjb25zdCBzdWJqZWN0ID0gYXdhaXQgZGIuc3ViamVjdC5maW5kVW5pcXVlKHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHN1YmplY3RJZCB9LFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gc3ViamVjdD8ubmFtZSB8fCAnVW5rbm93biBTdWJqZWN0J1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0TW9kdWxlTmFtZShtb2R1bGVJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBkYi5tb2R1bGUuZmluZFVuaXF1ZSh7XHJcbiAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBtb2R1bGVJZCB9LFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gbW9kdWxlPy5uYW1lIHx8ICdVbmtub3duIE1vZHVsZSdcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldFRlYWNoZXJDb25zdHJhaW50cyh0ZWFjaGVySWQ6IHN0cmluZyk6IFByb21pc2U8e1xyXG4gICAgICAgIHVuYXZhaWxhYmxlRGF5czogc3RyaW5nW10gfCBudWxsXHJcbiAgICAgICAgdW5hdmFpbGFibGVQZXJpb2RzOiBzdHJpbmdbXSB8IG51bGxcclxuICAgIH0+IHtcclxuICAgICAgICBjb25zdCB0ZWFjaGVyID0gYXdhaXQgZGIudXNlci5maW5kVW5pcXVlKHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHRlYWNoZXJJZCB9LFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHtcclxuICAgICAgICAgICAgICAgIHVuYXZhaWxhYmxlRGF5czogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHVuYXZhaWxhYmxlUGVyaW9kczogdHJ1ZVxyXG4gICAgICAgICAgICB9IGFzIGFueVxyXG4gICAgICAgIH0pIGFzIGFueVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1bmF2YWlsYWJsZURheXM6IHRlYWNoZXI/LnVuYXZhaWxhYmxlRGF5cyB8fCBudWxsLFxyXG4gICAgICAgICAgICB1bmF2YWlsYWJsZVBlcmlvZHM6IHRlYWNoZXI/LnVuYXZhaWxhYmxlUGVyaW9kcyB8fCBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRlYWNoZXIncyBjdXJyZW50IHdvcmtsb2FkIGFjcm9zcyBhbGwgY2xhc3NlcyBmb3Igc2NvcGUgYW5hbHlzaXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRUZWFjaGVyV29ya2xvYWQodGVhY2hlcklkOiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICAgICAgICB0b3RhbExlc3NvbnM6IG51bWJlclxyXG4gICAgICAgIGNsYXNzZXNDb3VudDogbnVtYmVyXHJcbiAgICAgICAgc3ViamVjdHNDb3VudDogbnVtYmVyXHJcbiAgICAgICAgZGFpbHlEaXN0cmlidXRpb246IFJlY29yZDxzdHJpbmcsIG51bWJlcj5cclxuICAgIH0+IHtcclxuICAgICAgICBjb25zdCBzY2hlZHVsZWRMZXNzb25zID0gdGhpcy5zY2hlZHVsZWRMZXNzb25zLmZpbHRlcihsZXNzb24gPT4gbGVzc29uLnRlYWNoZXJJZCA9PT0gdGVhY2hlcklkKVxyXG4gICAgICAgIGNvbnN0IGNsYXNzSWRzID0gbmV3IFNldChzY2hlZHVsZWRMZXNzb25zLm1hcChsID0+IGwuY2xhc3NJZCkpXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2V0IGFsbCBhc3NpZ25tZW50cyBmb3IgdGhpcyB0ZWFjaGVyIGFjcm9zcyBzY2hvb2xcclxuICAgICAgICBjb25zdCBhbGxBc3NpZ25tZW50cyA9IGF3YWl0IHRoaXMuZ2V0VGVhY2hlckFsbEFzc2lnbm1lbnRzKHRlYWNoZXJJZClcclxuICAgICAgICBjb25zdCBzdWJqZWN0SWRzID0gbmV3IFNldChhbGxBc3NpZ25tZW50cy5tYXAoYSA9PiBhLnN1YmplY3RJZCB8fCBhLm1vZHVsZUlkKS5maWx0ZXIoQm9vbGVhbikpXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkYWlseSBkaXN0cmlidXRpb25cclxuICAgICAgICBjb25zdCBkYWlseURpc3RyaWJ1dGlvbjogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XHJcbiAgICAgICAgc2NoZWR1bGVkTGVzc29ucy5mb3JFYWNoKGxlc3NvbiA9PiB7XHJcbiAgICAgICAgICAgIGRhaWx5RGlzdHJpYnV0aW9uW2xlc3Nvbi5zbG90LmRheV0gPSAoZGFpbHlEaXN0cmlidXRpb25bbGVzc29uLnNsb3QuZGF5XSB8fCAwKSArIDFcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b3RhbExlc3NvbnM6IHNjaGVkdWxlZExlc3NvbnMubGVuZ3RoLFxyXG4gICAgICAgICAgICBjbGFzc2VzQ291bnQ6IGNsYXNzSWRzLnNpemUsXHJcbiAgICAgICAgICAgIHN1YmplY3RzQ291bnQ6IHN1YmplY3RJZHMuc2l6ZSxcclxuICAgICAgICAgICAgZGFpbHlEaXN0cmlidXRpb25cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgQUxMIHRlYWNoZXIgYXNzaWdubWVudHMgYWNyb3NzIHNjaG9vbCBmb3IgZnVsbCBzY29wZSBhbmFseXNpc1xyXG4gICAgICogVGhpcyBpbmNsdWRlcyBhc3NpZ25tZW50cyBmcm9tIEFMTCBjbGFzc2VzLCBzdWJqZWN0cywgYW5kIG1vZHVsZXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRUZWFjaGVyQWxsQXNzaWdubWVudHModGVhY2hlcklkOiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PHtcclxuICAgICAgICBjbGFzc0lkOiBzdHJpbmdcclxuICAgICAgICBzdWJqZWN0SWQ/OiBzdHJpbmdcclxuICAgICAgICBtb2R1bGVJZD86IHN0cmluZ1xyXG4gICAgICAgIGxldmVsOiBzdHJpbmdcclxuICAgICAgICB0eXBlOiAnUFJJTUFSWScgfCAnU0VDT05EQVJZJyB8ICdUU1MnXHJcbiAgICB9Pj4ge1xyXG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnRzOiBBcnJheTx7XHJcbiAgICAgICAgICAgIGNsYXNzSWQ6IHN0cmluZ1xyXG4gICAgICAgICAgICBzdWJqZWN0SWQ/OiBzdHJpbmdcclxuICAgICAgICAgICAgbW9kdWxlSWQ/OiBzdHJpbmdcclxuICAgICAgICAgICAgbGV2ZWw6IHN0cmluZ1xyXG4gICAgICAgICAgICB0eXBlOiAnUFJJTUFSWScgfCAnU0VDT05EQVJZJyB8ICdUU1MnXHJcbiAgICAgICAgfT4gPSBbXVxyXG5cclxuICAgICAgICAvLyBHZXQgdGVhY2hlci1jbGFzcy1zdWJqZWN0IGFzc2lnbm1lbnRzIChQcmltYXJ5L1NlY29uZGFyeSlcclxuICAgICAgICBjb25zdCB0ZWFjaGVyQ2xhc3NTdWJqZWN0cyA9IGF3YWl0IGRiLnRlYWNoZXJDbGFzc1N1YmplY3QuZmluZE1hbnkoe1xyXG4gICAgICAgICAgICB3aGVyZTogeyB0ZWFjaGVySWQgfSxcclxuICAgICAgICAgICAgaW5jbHVkZToge1xyXG4gICAgICAgICAgICAgICAgY2xhc3M6IHsgc2VsZWN0OiB7IGxldmVsOiB0cnVlIH0gfSxcclxuICAgICAgICAgICAgICAgIHN1YmplY3Q6IHsgc2VsZWN0OiB7IGxldmVsOiB0cnVlIH0gfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGVhY2hlckNsYXNzU3ViamVjdHMuZm9yRWFjaCgoYXNzaWdubWVudDogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGFzc2lnbm1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgY2xhc3NJZDogYXNzaWdubWVudC5jbGFzc0lkLFxyXG4gICAgICAgICAgICAgICAgc3ViamVjdElkOiBhc3NpZ25tZW50LnN1YmplY3RJZCxcclxuICAgICAgICAgICAgICAgIGxldmVsOiBhc3NpZ25tZW50LmNsYXNzLmxldmVsIHx8IGFzc2lnbm1lbnQuc3ViamVjdC5sZXZlbCB8fCAnVW5rbm93bicsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmRldGVybWluZVNjaG9vbFR5cGUoYXNzaWdubWVudC5jbGFzcy5sZXZlbCB8fCBhc3NpZ25tZW50LnN1YmplY3QubGV2ZWwgfHwgJycpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLy8gR2V0IHRyYWluZXItY2xhc3MtbW9kdWxlIGFzc2lnbm1lbnRzIChUU1MpXHJcbiAgICAgICAgY29uc3QgdHJhaW5lckNsYXNzTW9kdWxlcyA9IGF3YWl0IGRiLnRyYWluZXJDbGFzc01vZHVsZS5maW5kTWFueSh7XHJcbiAgICAgICAgICAgIHdoZXJlOiB7IHRyYWluZXJJZDogdGVhY2hlcklkIH0sXHJcbiAgICAgICAgICAgIGluY2x1ZGU6IHtcclxuICAgICAgICAgICAgICAgIGNsYXNzOiB7IHNlbGVjdDogeyBsZXZlbDogdHJ1ZSB9IH0sXHJcbiAgICAgICAgICAgICAgICBtb2R1bGU6IHsgc2VsZWN0OiB7IGxldmVsOiB0cnVlIH0gfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdHJhaW5lckNsYXNzTW9kdWxlcy5mb3JFYWNoKChhc3NpZ25tZW50OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgYXNzaWdubWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBjbGFzc0lkOiBhc3NpZ25tZW50LmNsYXNzSWQsXHJcbiAgICAgICAgICAgICAgICBtb2R1bGVJZDogYXNzaWdubWVudC5tb2R1bGVJZCxcclxuICAgICAgICAgICAgICAgIGxldmVsOiBhc3NpZ25tZW50LmNsYXNzLmxldmVsIHx8IGFzc2lnbm1lbnQubW9kdWxlLmxldmVsIHx8ICdVbmtub3duJyxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdUU1MnIGFzIGNvbnN0XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIGFzc2lnbm1lbnRzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmUgc2Nob29sIHR5cGUgYmFzZWQgb24gY2xhc3MgbGV2ZWxcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkZXRlcm1pbmVTY2hvb2xUeXBlKGxldmVsOiBzdHJpbmcpOiAnUFJJTUFSWScgfCAnU0VDT05EQVJZJyB8ICdUU1MnIHtcclxuICAgICAgICBpZiAoWydMMycsICdMNCcsICdMNSddLmluY2x1ZGVzKGxldmVsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1RTUydcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxldmVsLnN0YXJ0c1dpdGgoJ1MnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1NFQ09OREFSWSdcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxldmVsLnN0YXJ0c1dpdGgoJ1AnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1BSSU1BUlknXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnU0VDT05EQVJZJyAvLyBkZWZhdWx0XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBzY2hlZHVsaW5nIHdvdWxkIG1haW50YWluIHdvcmtsb2FkIGJhbGFuY2UgYWNyb3NzIHRlYWNoZXIncyBjbGFzc2VzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaXNXb3JrbG9hZEJhbGFuY2VkKHRlYWNoZXJJZDogc3RyaW5nLCB0YXJnZXRDbGFzc0lkOiBzdHJpbmcsIGRheTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgdGVhY2hlckxlc3NvbnMgPSB0aGlzLnNjaGVkdWxlZExlc3NvbnMuZmlsdGVyKGxlc3NvbiA9PiBsZXNzb24udGVhY2hlcklkID09PSB0ZWFjaGVySWQpXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRlYWNoZXJMZXNzb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWUgLy8gRmlyc3QgbGVzc29uIGZvciB0ZWFjaGVyXHJcblxyXG4gICAgICAgIC8vIENvdW50IGxlc3NvbnMgcGVyIGNsYXNzIGZvciB0aGlzIHRlYWNoZXJcclxuICAgICAgICBjb25zdCBsZXNzb25zQnlDbGFzcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KClcclxuICAgICAgICB0ZWFjaGVyTGVzc29ucy5mb3JFYWNoKGxlc3NvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gbGVzc29uc0J5Q2xhc3MuZ2V0KGxlc3Nvbi5jbGFzc0lkKSB8fCAwXHJcbiAgICAgICAgICAgIGxlc3NvbnNCeUNsYXNzLnNldChsZXNzb24uY2xhc3NJZCwgY291bnQgKyAxKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8vIENvdW50IGxlc3NvbnMgZm9yIHRhcmdldCBjbGFzcyBvbiB0aGlzIGRheVxyXG4gICAgICAgIGNvbnN0IHRhcmdldENsYXNzRGF5TGVzc29ucyA9IHRlYWNoZXJMZXNzb25zLmZpbHRlcihcclxuICAgICAgICAgICAgbGVzc29uID0+IGxlc3Nvbi5jbGFzc0lkID09PSB0YXJnZXRDbGFzc0lkICYmIGxlc3Nvbi5zbG90LmRheSA9PT0gZGF5XHJcbiAgICAgICAgKS5sZW5ndGhcclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBvdmVybG9hZGluZyBhIHNpbmdsZSBjbGFzcyBvbiBhIHNpbmdsZSBkYXlcclxuICAgICAgICAvLyBBbGxvdyBtYXggMyBsZXNzb25zIHBlciBjbGFzcyBwZXIgZGF5IGZvciBhbnkgdGVhY2hlclxyXG4gICAgICAgIGlmICh0YXJnZXRDbGFzc0RheUxlc3NvbnMgPj0gMykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBzYXZlVG9EYXRhYmFzZSgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGxlc3NvbiBvZiB0aGlzLnNjaGVkdWxlZExlc3NvbnMpIHtcclxuICAgICAgICAgICAgYXdhaXQgZGIudGltZXRhYmxlLmNyZWF0ZSh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NJZDogbGVzc29uLmNsYXNzSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGVhY2hlcklkOiBsZXNzb24udGVhY2hlcklkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3RJZDogbGVzc29uLnN1YmplY3RJZCxcclxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVJZDogbGVzc29uLm1vZHVsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVTbG90SWQ6IGxlc3Nvbi5zbG90LnRpbWVTbG90SWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSB0aW1ldGFibGVzIGZvciBhbGwgY2xhc3NlcyAod2l0aG91dCBjbGVhcmluZyBleGlzdGluZyB0ZWFjaGVyIHRpbWV0YWJsZXMpXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdlbmVyYXRlRm9yQWxsQ2xhc3NlcygpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgY29uZmxpY3RzOiBDb25mbGljdFJlc29sdXRpb25bXSB9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgdGltZXRhYmxlcyBmb3IgY2xhc3NlcyBvbmx5IChrZWVwIHRlYWNoZXItc3BlY2lmaWMgb25lcylcclxuICAgICAgICAgICAgYXdhaXQgZGIudGltZXRhYmxlLmRlbGV0ZU1hbnkoe1xyXG4gICAgICAgICAgICAgICAgd2hlcmU6IHsgc2Nob29sSWQ6IHRoaXMuc2Nob29sSWQgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdmFpbGFiaWxpdHkgbWFwc1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVBdmFpbGFiaWxpdHkoKVxyXG5cclxuICAgICAgICAgICAgLy8gTG9hZCBwcmVwYXJlZCBsZXNzb25zXHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGVzc29uczogcHJlcGFyZWRMZXNzb25zIH0gPSBhd2FpdCBwcmVwYXJlTGVzc29uc0ZvclNjaG9vbCh0aGlzLnNjaG9vbElkKVxyXG5cclxuICAgICAgICAgICAgLy8gU29ydCBieSBwcmlvcml0eSBhbmQgdGltZSBwcmVmZXJlbmNlIHdpdGggVFNTIHJ1bGVzXHJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZExlc3NvbnMgPSB0aGlzLnNvcnRMZXNzb25zQnlQcmlvcml0eUFuZFRpbWUocHJlcGFyZWRMZXNzb25zKVxyXG5cclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgZWFjaCBsZXNzb25cclxuICAgICAgICAgICAgZm9yIChjb25zdCBsZXNzb24gb2Ygc29ydGVkTGVzc29ucykge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2hlZHVsZUxlc3NvbihsZXNzb24pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgYWxsIHNjaGVkdWxlZCBsZXNzb25zIHRvIGRhdGFiYXNlXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZVRvRGF0YWJhc2UoKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHM6IHRoaXMuY29uZmxpY3RzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaW1ldGFibGUgZ2VuZXJhdGlvbiBmb3IgYWxsIGNsYXNzZXMgZmFpbGVkOicsIGVycm9yKVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb25mbGljdHM6IFsuLi50aGlzLmNvbmZsaWN0cywge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bmFzc2lnbmVkJyxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGltZXRhYmxlIGdlbmVyYXRpb24gZm9yIGFsbCBjbGFzc2VzIGZhaWxlZCBkdWUgdG8gYW4gaW50ZXJuYWwgZXJyb3InXHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgdGltZXRhYmxlcyBmb3IgYWxsIHRlYWNoZXJzICh3aXRob3V0IGNsZWFyaW5nIGV4aXN0aW5nIGNsYXNzIHRpbWV0YWJsZXMpXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdlbmVyYXRlRm9yQWxsVGVhY2hlcnMoKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGNvbmZsaWN0czogQ29uZmxpY3RSZXNvbHV0aW9uW10gfT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIENsZWFyIGV4aXN0aW5nIHRpbWV0YWJsZXMgZm9yIHRlYWNoZXJzIG9ubHkgKGJ1dCB0aGlzIGFsc28gY2xlYXJzIGNsYXNzIHRpbWV0YWJsZXMgc2luY2UgdGhleSdyZSBsaW5rZWQpXHJcbiAgICAgICAgICAgIC8vIEFjdHVhbGx5LCB0aW1ldGFibGVzIGFyZSBzaGFyZWQgLSBhIHNpbmdsZSB0aW1ldGFibGUgZW50cnkgaGFzIGJvdGggY2xhc3NJZCBhbmQgdGVhY2hlcklkXHJcbiAgICAgICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gY2xlYXIgYWxsIGFuZCByZWdlbmVyYXRlXHJcbiAgICAgICAgICAgIGF3YWl0IGRiLnRpbWV0YWJsZS5kZWxldGVNYW55KHtcclxuICAgICAgICAgICAgICAgIHdoZXJlOiB7IHNjaG9vbElkOiB0aGlzLnNjaG9vbElkIH1cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgYXZhaWxhYmlsaXR5IG1hcHNcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQXZhaWxhYmlsaXR5KClcclxuXHJcbiAgICAgICAgICAgIC8vIExvYWQgcHJlcGFyZWQgbGVzc29uc1xyXG4gICAgICAgICAgICBjb25zdCB7IGxlc3NvbnM6IHByZXBhcmVkTGVzc29ucyB9ID0gYXdhaXQgcHJlcGFyZUxlc3NvbnNGb3JTY2hvb2wodGhpcy5zY2hvb2xJZClcclxuXHJcbiAgICAgICAgICAgIC8vIFNvcnQgYnkgcHJpb3JpdHkgYW5kIHRpbWUgcHJlZmVyZW5jZSB3aXRoIFRTUyBydWxlc1xyXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRMZXNzb25zID0gdGhpcy5zb3J0TGVzc29uc0J5UHJpb3JpdHlBbmRUaW1lKHByZXBhcmVkTGVzc29ucylcclxuXHJcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGVhY2ggbGVzc29uXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVzc29uIG9mIHNvcnRlZExlc3NvbnMpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2NoZWR1bGVMZXNzb24obGVzc29uKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTYXZlIGFsbCBzY2hlZHVsZWQgbGVzc29ucyB0byBkYXRhYmFzZVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVUb0RhdGFiYXNlKClcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmxpY3RzOiB0aGlzLmNvbmZsaWN0c1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGltZXRhYmxlIGdlbmVyYXRpb24gZm9yIGFsbCB0ZWFjaGVycyBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbmZsaWN0czogWy4uLnRoaXMuY29uZmxpY3RzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuYXNzaWduZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaW1ldGFibGUgZ2VuZXJhdGlvbiBmb3IgYWxsIHRlYWNoZXJzIGZhaWxlZCBkdWUgdG8gYW4gaW50ZXJuYWwgZXJyb3InXHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUaW1ldGFibGUoc2Nob29sSWQ6IHN0cmluZywgc2NvcGU6IFNjaG9vbFNjb3BlID0gJ2JvdGgnKSB7XHJcbiAgICBjb25zdCBnZW5lcmF0b3IgPSBuZXcgVGltZXRhYmxlR2VuZXJhdG9yKHNjaG9vbElkKVxyXG4gICAgXHJcbiAgICBpZiAoc2NvcGUgPT09ICdhbGwtY2xhc3NlcycpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgZ2VuZXJhdG9yLmdlbmVyYXRlRm9yQWxsQ2xhc3NlcygpXHJcbiAgICB9IGVsc2UgaWYgKHNjb3BlID09PSAnYWxsLXRlYWNoZXJzJykge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBnZW5lcmF0b3IuZ2VuZXJhdGVGb3JBbGxUZWFjaGVycygpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBnZW5lcmF0b3IuZ2VuZXJhdGUoKVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUaW1ldGFibGVGb3JDbGFzcyhzY2hvb2xJZDogc3RyaW5nLCBjbGFzc0lkOiBzdHJpbmcsIG9wdGlvbnM6IEdlbmVyYXRpb25PcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGdlbmVyYXRvciA9IG5ldyBUaW1ldGFibGVHZW5lcmF0b3Ioc2Nob29sSWQpXHJcbiAgICByZXR1cm4gYXdhaXQgZ2VuZXJhdG9yLmdlbmVyYXRlRm9yQ2xhc3MoY2xhc3NJZCwgb3B0aW9ucylcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVGltZXRhYmxlRm9yVGVhY2hlcihzY2hvb2xJZDogc3RyaW5nLCB0ZWFjaGVySWQ6IHN0cmluZywgb3B0aW9uczogR2VuZXJhdGlvbk9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgZ2VuZXJhdG9yID0gbmV3IFRpbWV0YWJsZUdlbmVyYXRvcihzY2hvb2xJZClcclxuICAgIHJldHVybiBhd2FpdCBnZW5lcmF0b3IuZ2VuZXJhdGVGb3JUZWFjaGVyKHRlYWNoZXJJZCwgb3B0aW9ucylcclxufSJdLCJuYW1lcyI6WyJkYiIsInByZXBhcmVMZXNzb25zRm9yU2Nob29sIiwiVGltZXRhYmxlR2VuZXJhdG9yIiwiY29uc3RydWN0b3IiLCJzY2hvb2xJZCIsInNjaGVkdWxlZExlc3NvbnMiLCJ0ZWFjaGVyQXZhaWxhYmlsaXR5IiwiY2xhc3NBdmFpbGFiaWxpdHkiLCJjb25mbGljdHMiLCJ0aW1lU2xvdHNDYWNoZSIsImdlbmVyYXRlIiwidGltZXRhYmxlIiwiZGVsZXRlTWFueSIsIndoZXJlIiwiaW5pdGlhbGl6ZUF2YWlsYWJpbGl0eSIsImxlc3NvbnMiLCJwcmVwYXJlZExlc3NvbnMiLCJzb3J0ZWRMZXNzb25zIiwic29ydExlc3NvbnNCeVByaW9yaXR5QW5kVGltZSIsInRpbWVTbG90cyIsInRpbWVTbG90IiwiZmluZE1hbnkiLCJpc0FjdGl2ZSIsIm9yZGVyQnkiLCJkYXkiLCJwZXJpb2QiLCJ2YWxpZFRpbWVTbG90cyIsImZpbHRlciIsInRzIiwiaXNWYWxpZFBlcmlvZCIsImlzVmFsaWREYXkiLCJpbmNsdWRlcyIsImlzTm90QnJlYWsiLCJpc0JyZWFrIiwidG90YWxQZXJpb2RzIiwicmVkdWNlIiwic3VtIiwibGVzc29uIiwiYmxvY2tTaXplIiwibGVuZ3RoIiwic3VjY2VzcyIsInR5cGUiLCJtZXNzYWdlIiwic2NoZWR1bGVMZXNzb24iLCJzYXZlVG9EYXRhYmFzZSIsImVycm9yIiwiY29uc29sZSIsImdlbmVyYXRlRm9yQ2xhc3MiLCJjbGFzc0lkIiwib3B0aW9ucyIsImluY3JlbWVudGFsIiwicmVnZW5lcmF0ZSIsImluaXRpYWxpemVBdmFpbGFiaWxpdHlXaXRoRXhpc3RpbmdUaW1ldGFibGVzIiwiY2xhc3NMZXNzb25zIiwiZ2VuZXJhdGVGb3JUZWFjaGVyIiwidGVhY2hlcklkIiwidW5kZWZpbmVkIiwidGVhY2hlckxlc3NvbnMiLCJ0ZWFjaGVyc0FuZFRyYWluZXJzIiwidXNlciIsInJvbGUiLCJpbiIsImZvckVhY2giLCJwZXJzb24iLCJpZCIsIlNldCIsImNsYXNzZXMiLCJjbGFzcyIsImNscyIsImV4Y2x1ZGVDbGFzc0lkIiwiZXhjbHVkZVRlYWNoZXJJZCIsImV4aXN0aW5nVGltZXRhYmxlc1doZXJlQ2xhdXNlIiwibm90IiwiZXhpc3RpbmdUaW1ldGFibGVzIiwiaW5jbHVkZSIsInNlbGVjdCIsIm5hbWUiLCJ0ZWFjaGVyIiwic2xvdEtleSIsImFkZCIsImxvZyIsInNvcnQiLCJhIiwiYiIsImxlc3NvblR5cGUiLCJjYXRlZ29yeU9yZGVyIiwiYUNhdGVnb3J5IiwibW9kdWxlQ2F0ZWdvcnkiLCJiQ2F0ZWdvcnkiLCJwcmVmZXJyZWRUaW1lIiwiaXNNYXRoUGh5c2ljc0EiLCJzdWJqZWN0TmFtZSIsInRvTG93ZXJDYXNlIiwiaXNNYXRoUGh5c2ljc0IiLCJwcmlvcml0eSIsInRvdGFsTGVzc29ucyIsInBlcmlvZHNQZXJXZWVrIiwidGVhY2hlckNvbnN0cmFpbnRzIiwiZ2V0VGVhY2hlckNvbnN0cmFpbnRzIiwidGVhY2hlcldvcmtsb2FkIiwiZ2V0VGVhY2hlcldvcmtsb2FkIiwiaXNUU1NNb2R1bGUiLCJwcmVmZXJzTW9ybmluZyIsInRlYWNoZXJBbGxBc3NpZ25tZW50cyIsImdldFRlYWNoZXJBbGxBc3NpZ25tZW50cyIsInRlYWNoZXJDbGFzc2VzIiwibWFwIiwidGVhY2hlclN1YmplY3RzIiwic3ViamVjdElkIiwibW9kdWxlSWQiLCJsZXNzb25JbmRleCIsImlzQ29tcGxlbWVudGFyeSIsInNsb3RzVG9UcnkiLCJzZXNzaW9uIiwiaXNXaXRoaW5UaW1lV2luZG93Iiwic29ydFNsb3RzRm9yRXZlbkRpc3RyaWJ1dGlvbiIsInVuYXZhaWxhYmxlRGF5cyIsInVuYXZhaWxhYmxlUGVyaW9kcyIsInRvU3RyaW5nIiwiY2FuU2NoZWR1bGVCbG9ja1NpemUiLCJpc1NwZWNpZmljT3JHZW5lcmFsIiwiY2FuU2NoZWR1bGVCbG9jayIsImlzT2RkUGVyaW9kcyIsInRlYWNoZXJBdmFpbGFibGUiLCJoYXMiLCJjbGFzc0F2YWlsYWJsZSIsInJlc3BlY3RzQ29uc2VjdXRpdmVSdWxlIiwiY2FuU2NoZWR1bGVDb25zZWN1dGl2ZSIsInJlc3BlY3RzV29ya2xvYWRCYWxhbmNlIiwiaXNXb3JrbG9hZEJhbGFuY2VkIiwiaSIsImN1cnJlbnRQZXJpb2QiLCJjdXJyZW50U2xvdEtleSIsImN1cnJlbnRUaW1lU2xvdCIsImZpbmQiLCJwdXNoIiwic2xvdCIsInRpbWVTbG90SWQiLCJibG9ja0Rlc2NyaXB0aW9uIiwidGVhY2hlck5hbWUiLCJnZXRUZWFjaGVyTmFtZSIsImNsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsIm1vZHVsZU5hbWUiLCJnZXRTdWJqZWN0TmFtZSIsImdldE1vZHVsZU5hbWUiLCJpc0dsb2JhbENvbmZsaWN0IiwiaXNUZWFjaGVyT3ZlcmJvb2tlZCIsImhhc011bHRpcGxlQ2xhc3NlcyIsInNpemUiLCJoYXNNdWx0aXBsZVN1YmplY3RzIiwic2NvcGVDb25mbGljdCIsImNvbmZsaWN0RGV0YWlsIiwiZGV0YWlscyIsImpvaW4iLCJjb25mbGljdE1lc3NhZ2UiLCJjb25mbGljdFN1Z2dlc3Rpb25zIiwic3VnZ2VzdGlvbnMiLCJCb29sZWFuIiwic2xvdHMiLCJ0ZWFjaGVyTGVzc29uc0J5RGF5IiwiTWFwIiwiY2xhc3NMZXNzb25zQnlEYXkiLCJjb3VudCIsImdldCIsInNldCIsInRlYWNoZXJTY29yZUEiLCJjbGFzc1Njb3JlQSIsInRvdGFsU2NvcmVBIiwidGVhY2hlclNjb3JlQiIsImNsYXNzU2NvcmVCIiwidG90YWxTY29yZUIiLCJsb2NhbGVDb21wYXJlIiwic3RhcnRQZXJpb2QiLCJlbmRQZXJpb2QiLCJtYXhDb25zZWN1dGl2ZSIsInRlYWNoZXJTbG90cyIsIkFycmF5IiwiZnJvbSIsInN0YXJ0c1dpdGgiLCJwYXJzZUludCIsInNwbGl0IiwiY29uc2VjdXRpdmVCZWZvcmUiLCJnZXRDb25zZWN1dGl2ZUNvdW50IiwiY29uc2VjdXRpdmVBZnRlciIsImN1cnJlbnQiLCJmaW5kVW5pcXVlIiwic3ViamVjdCIsIm1vZHVsZSIsImNsYXNzSWRzIiwibCIsImFsbEFzc2lnbm1lbnRzIiwic3ViamVjdElkcyIsImRhaWx5RGlzdHJpYnV0aW9uIiwiY2xhc3Nlc0NvdW50Iiwic3ViamVjdHNDb3VudCIsImFzc2lnbm1lbnRzIiwidGVhY2hlckNsYXNzU3ViamVjdHMiLCJ0ZWFjaGVyQ2xhc3NTdWJqZWN0IiwibGV2ZWwiLCJhc3NpZ25tZW50IiwiZGV0ZXJtaW5lU2Nob29sVHlwZSIsInRyYWluZXJDbGFzc01vZHVsZXMiLCJ0cmFpbmVyQ2xhc3NNb2R1bGUiLCJ0cmFpbmVySWQiLCJ0YXJnZXRDbGFzc0lkIiwibGVzc29uc0J5Q2xhc3MiLCJ0YXJnZXRDbGFzc0RheUxlc3NvbnMiLCJjcmVhdGUiLCJkYXRhIiwiZ2VuZXJhdGVGb3JBbGxDbGFzc2VzIiwiZ2VuZXJhdGVGb3JBbGxUZWFjaGVycyIsImdlbmVyYXRlVGltZXRhYmxlIiwic2NvcGUiLCJnZW5lcmF0b3IiLCJnZW5lcmF0ZVRpbWV0YWJsZUZvckNsYXNzIiwiZ2VuZXJhdGVUaW1ldGFibGVGb3JUZWFjaGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/timetable-generator.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/utils.ts":
/*!**************************!*\
  !*** ./src/lib/utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateWeeklyHours: () => (/* binding */ calculateWeeklyHours),\n/* harmony export */   cn: () => (/* binding */ cn),\n/* harmony export */   formatTime: () => (/* binding */ formatTime),\n/* harmony export */   generateTimeSlots: () => (/* binding */ generateTimeSlots),\n/* harmony export */   getDayName: () => (/* binding */ getDayName),\n/* harmony export */   getDaysOfWeek: () => (/* binding */ getDaysOfWeek),\n/* harmony export */   getModuleCategoryPriority: () => (/* binding */ getModuleCategoryPriority),\n/* harmony export */   isMorningPeriod: () => (/* binding */ isMorningPeriod),\n/* harmony export */   validateEmail: () => (/* binding */ validateEmail),\n/* harmony export */   validatePassword: () => (/* binding */ validatePassword)\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(rsc)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tailwind-merge */ \"(rsc)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\");\n\n\nfunction cn(...inputs) {\n    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_1__.twMerge)((0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(inputs));\n}\nfunction formatTime(date) {\n    return date.toLocaleTimeString(\"en-US\", {\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        hour12: true\n    });\n}\nfunction getDaysOfWeek() {\n    return [\n        \"MONDAY\",\n        \"TUESDAY\",\n        \"WEDNESDAY\",\n        \"THURSDAY\",\n        \"FRIDAY\",\n        \"SATURDAY\"\n    ];\n}\nfunction getDayName(day) {\n    const days = {\n        MONDAY: \"Monday\",\n        TUESDAY: \"Tuesday\",\n        WEDNESDAY: \"Wednesday\",\n        THURSDAY: \"Thursday\",\n        FRIDAY: \"Friday\",\n        SATURDAY: \"Saturday\"\n    };\n    return days[day] || day;\n}\nfunction getModuleCategoryPriority(category) {\n    const priorities = {\n        SPECIFIC: 1,\n        GENERAL: 2,\n        COMPLEMENTARY: 3\n    };\n    return priorities[category] || 4;\n}\nfunction isMorningPeriod(period, totalPeriods = 8) {\n    return period <= Math.ceil(totalPeriods * 0.6) // First 60% of periods are morning\n    ;\n}\nfunction generateTimeSlots(startHour = 8, periods = 8, duration = 45) {\n    const slots = [];\n    for(let i = 0; i < periods; i++){\n        const startTime = new Date();\n        startTime.setHours(startHour + Math.floor(i * (duration + 15) / 60), i * (duration + 15) % 60, 0);\n        const endTime = new Date(startTime);\n        endTime.setMinutes(endTime.getMinutes() + duration);\n        slots.push({\n            startTime,\n            endTime\n        });\n    }\n    return slots;\n}\nfunction calculateWeeklyHours(periods, duration = 45, daysPerWeek = 6) {\n    return Math.round(periods * duration * daysPerWeek / 60 * 100) / 100;\n}\nfunction validateEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\nfunction validatePassword(password) {\n    if (password.length < 8) {\n        return {\n            isValid: false,\n            message: \"Password must be at least 8 characters long\"\n        };\n    }\n    if (!/(?=.*[a-z])/.test(password)) {\n        return {\n            isValid: false,\n            message: \"Password must contain at least one lowercase letter\"\n        };\n    }\n    if (!/(?=.*[A-Z])/.test(password)) {\n        return {\n            isValid: false,\n            message: \"Password must contain at least one uppercase letter\"\n        };\n    }\n    if (!/(?=.*\\d)/.test(password)) {\n        return {\n            isValid: false,\n            message: \"Password must contain at least one number\"\n        };\n    }\n    return {\n        isValid: true\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL3V0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE0QztBQUNKO0FBRWpDLFNBQVNFLEdBQUcsR0FBR0MsTUFBb0I7SUFDdEMsT0FBT0YsdURBQU9BLENBQUNELDBDQUFJQSxDQUFDRztBQUN4QjtBQUVPLFNBQVNDLFdBQVdDLElBQVU7SUFDakMsT0FBT0EsS0FBS0Msa0JBQWtCLENBQUMsU0FBUztRQUNwQ0MsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLFFBQVE7SUFDWjtBQUNKO0FBRU8sU0FBU0M7SUFDWixPQUFPO1FBQUM7UUFBVTtRQUFXO1FBQWE7UUFBWTtRQUFVO0tBQVc7QUFDL0U7QUFFTyxTQUFTQyxXQUFXQyxHQUFXO0lBQ2xDLE1BQU1DLE9BQStCO1FBQ2pDQyxRQUFRO1FBQ1JDLFNBQVM7UUFDVEMsV0FBVztRQUNYQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsVUFBVTtJQUNkO0lBQ0EsT0FBT04sSUFBSSxDQUFDRCxJQUFJLElBQUlBO0FBQ3hCO0FBRU8sU0FBU1EsMEJBQTBCQyxRQUFnQjtJQUN0RCxNQUFNQyxhQUFxQztRQUN2Q0MsVUFBVTtRQUNWQyxTQUFTO1FBQ1RDLGVBQWU7SUFDbkI7SUFDQSxPQUFPSCxVQUFVLENBQUNELFNBQVMsSUFBSTtBQUNuQztBQUVPLFNBQVNLLGdCQUFnQkMsTUFBYyxFQUFFQyxlQUF1QixDQUFDO0lBQ3BFLE9BQU9ELFVBQVVFLEtBQUtDLElBQUksQ0FBQ0YsZUFBZSxLQUFLLG1DQUFtQzs7QUFDdEY7QUFFTyxTQUFTRyxrQkFBa0JDLFlBQW9CLENBQUMsRUFBRUMsVUFBa0IsQ0FBQyxFQUFFQyxXQUFtQixFQUFFO0lBQy9GLE1BQU1DLFFBQVEsRUFBRTtJQUNoQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsU0FBU0csSUFBSztRQUM5QixNQUFNQyxZQUFZLElBQUlDO1FBQ3RCRCxVQUFVRSxRQUFRLENBQUNQLFlBQVlILEtBQUtXLEtBQUssQ0FBQyxJQUFNTixDQUFBQSxXQUFXLEVBQUMsSUFBTSxLQUFLLElBQU1BLENBQUFBLFdBQVcsRUFBQyxJQUFNLElBQUk7UUFFbkcsTUFBTU8sVUFBVSxJQUFJSCxLQUFLRDtRQUN6QkksUUFBUUMsVUFBVSxDQUFDRCxRQUFRRSxVQUFVLEtBQUtUO1FBRTFDQyxNQUFNUyxJQUFJLENBQUM7WUFBRVA7WUFBV0k7UUFBUTtJQUNwQztJQUNBLE9BQU9OO0FBQ1g7QUFFTyxTQUFTVSxxQkFBcUJaLE9BQWUsRUFBRUMsV0FBbUIsRUFBRSxFQUFFWSxjQUFzQixDQUFDO0lBQ2hHLE9BQU9qQixLQUFLa0IsS0FBSyxDQUFDLFVBQVdiLFdBQVdZLGNBQWUsS0FBSyxPQUFPO0FBQ3ZFO0FBRU8sU0FBU0UsY0FBY0MsS0FBYTtJQUN2QyxNQUFNQyxhQUFhO0lBQ25CLE9BQU9BLFdBQVdDLElBQUksQ0FBQ0Y7QUFDM0I7QUFFTyxTQUFTRyxpQkFBaUJDLFFBQWdCO0lBQzdDLElBQUlBLFNBQVNDLE1BQU0sR0FBRyxHQUFHO1FBQ3JCLE9BQU87WUFBRUMsU0FBUztZQUFPQyxTQUFTO1FBQThDO0lBQ3BGO0lBRUEsSUFBSSxDQUFDLGNBQWNMLElBQUksQ0FBQ0UsV0FBVztRQUMvQixPQUFPO1lBQUVFLFNBQVM7WUFBT0MsU0FBUztRQUFzRDtJQUM1RjtJQUVBLElBQUksQ0FBQyxjQUFjTCxJQUFJLENBQUNFLFdBQVc7UUFDL0IsT0FBTztZQUFFRSxTQUFTO1lBQU9DLFNBQVM7UUFBc0Q7SUFDNUY7SUFFQSxJQUFJLENBQUMsV0FBV0wsSUFBSSxDQUFDRSxXQUFXO1FBQzVCLE9BQU87WUFBRUUsU0FBUztZQUFPQyxTQUFTO1FBQTRDO0lBQ2xGO0lBRUEsT0FBTztRQUFFRCxTQUFTO0lBQUs7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zY2hvb2wtdGltZXRhYmxlLW1hbmFnZW1lbnQvLi9zcmMvbGliL3V0aWxzLnRzPzdjMWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBDbGFzc1ZhbHVlLCBjbHN4IH0gZnJvbSAnY2xzeCdcclxuaW1wb3J0IHsgdHdNZXJnZSB9IGZyb20gJ3RhaWx3aW5kLW1lcmdlJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNuKC4uLmlucHV0czogQ2xhc3NWYWx1ZVtdKSB7XHJcbiAgICByZXR1cm4gdHdNZXJnZShjbHN4KGlucHV0cykpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUaW1lKGRhdGU6IERhdGUpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVUaW1lU3RyaW5nKCdlbi1VUycsIHtcclxuICAgICAgICBob3VyOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgaG91cjEyOiB0cnVlXHJcbiAgICB9KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF5c09mV2VlaygpIHtcclxuICAgIHJldHVybiBbJ01PTkRBWScsICdUVUVTREFZJywgJ1dFRE5FU0RBWScsICdUSFVSU0RBWScsICdGUklEQVknLCAnU0FUVVJEQVknXVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF5TmFtZShkYXk6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBkYXlzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgICAgIE1PTkRBWTogJ01vbmRheScsXHJcbiAgICAgICAgVFVFU0RBWTogJ1R1ZXNkYXknLFxyXG4gICAgICAgIFdFRE5FU0RBWTogJ1dlZG5lc2RheScsXHJcbiAgICAgICAgVEhVUlNEQVk6ICdUaHVyc2RheScsXHJcbiAgICAgICAgRlJJREFZOiAnRnJpZGF5JyxcclxuICAgICAgICBTQVRVUkRBWTogJ1NhdHVyZGF5J1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRheXNbZGF5XSB8fCBkYXlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vZHVsZUNhdGVnb3J5UHJpb3JpdHkoY2F0ZWdvcnk6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICBjb25zdCBwcmlvcml0aWVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xyXG4gICAgICAgIFNQRUNJRklDOiAxLFxyXG4gICAgICAgIEdFTkVSQUw6IDIsXHJcbiAgICAgICAgQ09NUExFTUVOVEFSWTogM1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW9yaXRpZXNbY2F0ZWdvcnldIHx8IDRcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTW9ybmluZ1BlcmlvZChwZXJpb2Q6IG51bWJlciwgdG90YWxQZXJpb2RzOiBudW1iZXIgPSA4KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gcGVyaW9kIDw9IE1hdGguY2VpbCh0b3RhbFBlcmlvZHMgKiAwLjYpIC8vIEZpcnN0IDYwJSBvZiBwZXJpb2RzIGFyZSBtb3JuaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRpbWVTbG90cyhzdGFydEhvdXI6IG51bWJlciA9IDgsIHBlcmlvZHM6IG51bWJlciA9IDgsIGR1cmF0aW9uOiBudW1iZXIgPSA0NSk6IEFycmF5PHsgc3RhcnRUaW1lOiBEYXRlLCBlbmRUaW1lOiBEYXRlIH0+IHtcclxuICAgIGNvbnN0IHNsb3RzID0gW11cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVyaW9kczsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKVxyXG4gICAgICAgIHN0YXJ0VGltZS5zZXRIb3VycyhzdGFydEhvdXIgKyBNYXRoLmZsb29yKChpICogKGR1cmF0aW9uICsgMTUpKSAvIDYwKSwgKGkgKiAoZHVyYXRpb24gKyAxNSkpICUgNjAsIDApXHJcblxyXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZShzdGFydFRpbWUpXHJcbiAgICAgICAgZW5kVGltZS5zZXRNaW51dGVzKGVuZFRpbWUuZ2V0TWludXRlcygpICsgZHVyYXRpb24pXHJcblxyXG4gICAgICAgIHNsb3RzLnB1c2goeyBzdGFydFRpbWUsIGVuZFRpbWUgfSlcclxuICAgIH1cclxuICAgIHJldHVybiBzbG90c1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlV2Vla2x5SG91cnMocGVyaW9kczogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyID0gNDUsIGRheXNQZXJXZWVrOiBudW1iZXIgPSA2KTogbnVtYmVyIHtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKChwZXJpb2RzICogZHVyYXRpb24gKiBkYXlzUGVyV2VlaykgLyA2MCAqIDEwMCkgLyAxMDBcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRW1haWwoZW1haWw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvXHJcbiAgICByZXR1cm4gZW1haWxSZWdleC50ZXN0KGVtYWlsKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQYXNzd29yZChwYXNzd29yZDogc3RyaW5nKTogeyBpc1ZhbGlkOiBib29sZWFuOyBtZXNzYWdlPzogc3RyaW5nIH0ge1xyXG4gICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IDgpIHtcclxuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgbWVzc2FnZTogJ1Bhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzIGxvbmcnIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIS8oPz0uKlthLXpdKS8udGVzdChwYXNzd29yZCkpIHtcclxuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgbWVzc2FnZTogJ1Bhc3N3b3JkIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgbG93ZXJjYXNlIGxldHRlcicgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghLyg/PS4qW0EtWl0pLy50ZXN0KHBhc3N3b3JkKSkge1xyXG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnUGFzc3dvcmQgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSB1cHBlcmNhc2UgbGV0dGVyJyB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEvKD89LipcXGQpLy50ZXN0KHBhc3N3b3JkKSkge1xyXG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnUGFzc3dvcmQgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBudW1iZXInIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlIH1cclxufSJdLCJuYW1lcyI6WyJjbHN4IiwidHdNZXJnZSIsImNuIiwiaW5wdXRzIiwiZm9ybWF0VGltZSIsImRhdGUiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJob3VyIiwibWludXRlIiwiaG91cjEyIiwiZ2V0RGF5c09mV2VlayIsImdldERheU5hbWUiLCJkYXkiLCJkYXlzIiwiTU9OREFZIiwiVFVFU0RBWSIsIldFRE5FU0RBWSIsIlRIVVJTREFZIiwiRlJJREFZIiwiU0FUVVJEQVkiLCJnZXRNb2R1bGVDYXRlZ29yeVByaW9yaXR5IiwiY2F0ZWdvcnkiLCJwcmlvcml0aWVzIiwiU1BFQ0lGSUMiLCJHRU5FUkFMIiwiQ09NUExFTUVOVEFSWSIsImlzTW9ybmluZ1BlcmlvZCIsInBlcmlvZCIsInRvdGFsUGVyaW9kcyIsIk1hdGgiLCJjZWlsIiwiZ2VuZXJhdGVUaW1lU2xvdHMiLCJzdGFydEhvdXIiLCJwZXJpb2RzIiwiZHVyYXRpb24iLCJzbG90cyIsImkiLCJzdGFydFRpbWUiLCJEYXRlIiwic2V0SG91cnMiLCJmbG9vciIsImVuZFRpbWUiLCJzZXRNaW51dGVzIiwiZ2V0TWludXRlcyIsInB1c2giLCJjYWxjdWxhdGVXZWVrbHlIb3VycyIsImRheXNQZXJXZWVrIiwicm91bmQiLCJ2YWxpZGF0ZUVtYWlsIiwiZW1haWwiLCJlbWFpbFJlZ2V4IiwidGVzdCIsInZhbGlkYXRlUGFzc3dvcmQiLCJwYXNzd29yZCIsImxlbmd0aCIsImlzVmFsaWQiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/utils.ts\n");

/***/ })

};
;